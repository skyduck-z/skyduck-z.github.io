<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go tips(持续更新) | Duck</title><meta name=keywords content="Golang,2025"><meta name=description content="有很多从其他大佬的总结中抄来的，不注明出处了
会记录一些:

有意义的小操作(可能有些比较tricky)
容易理解偏差的点
日常开发低频使用的知识点


golang代码执行顺序
没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。
了解更多可查看Golang内存模型规范。
golang内存对齐
内存对齐：数据在内存中的存储位置必须是特定字节数的倍数

CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问


golang内存对齐：

基础类型：通常是其自身大小（如int32为4字节，int64为8字节）
结构体

每个字段按各自的对齐系数作对齐
结构体自身的对齐系数为所有字段中最大的对齐系数


数组：与元素类型的对齐系数相同

例：
type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
    fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
demo1:

a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节
b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节
c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可

demo2:"><meta name=author content><link rel=canonical href=https://duck-dd.github.io/posts/2025-06-22-go-tips/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://duck-dd.github.io/posts/2025-06-22-go-tips/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://duck-dd.github.io/posts/2025-06-22-go-tips/"><meta property="og:site_name" content="Duck"><meta property="og:title" content="go tips(持续更新)"><meta property="og:description" content="有很多从其他大佬的总结中抄来的，不注明出处了
会记录一些:
有意义的小操作(可能有些比较tricky) 容易理解偏差的点 日常开发低频使用的知识点 golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。
了解更多可查看Golang内存模型规范。
golang内存对齐 内存对齐：数据在内存中的存储位置必须是特定字节数的倍数
CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问 golang内存对齐：
基础类型：通常是其自身大小（如int32为4字节，int64为8字节） 结构体 每个字段按各自的对齐系数作对齐 结构体自身的对齐系数为所有字段中最大的对齐系数 数组：与元素类型的对齐系数相同 例：
type demo1 struct { a int8 b int16 c int32 } type demo2 struct { a int8 c int32 b int16 } type demo3 struct { a int8 c int32 b int16 d int16 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) // 8 fmt.Println(unsafe.Sizeof(demo2{})) // 12 fmt.Println(unsafe.Sizeof(demo3{})) // 12 } demo1:
a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节 c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可 demo2:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-01T00:00:00+00:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="2025"><meta property="og:image" content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="go tips(持续更新)"><meta name=twitter:description content="有很多从其他大佬的总结中抄来的，不注明出处了
会记录一些:

有意义的小操作(可能有些比较tricky)
容易理解偏差的点
日常开发低频使用的知识点


golang代码执行顺序
没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。
了解更多可查看Golang内存模型规范。
golang内存对齐
内存对齐：数据在内存中的存储位置必须是特定字节数的倍数

CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问


golang内存对齐：

基础类型：通常是其自身大小（如int32为4字节，int64为8字节）
结构体

每个字段按各自的对齐系数作对齐
结构体自身的对齐系数为所有字段中最大的对齐系数


数组：与元素类型的对齐系数相同

例：
type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
    fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
demo1:

a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节
b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节
c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可

demo2:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://duck-dd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"go tips(持续更新)","item":"https://duck-dd.github.io/posts/2025-06-22-go-tips/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go tips(持续更新)","name":"go tips(持续更新)","description":"有很多从其他大佬的总结中抄来的，不注明出处了\n会记录一些:\n有意义的小操作(可能有些比较tricky) 容易理解偏差的点 日常开发低频使用的知识点 golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。\n了解更多可查看Golang内存模型规范。\ngolang内存对齐 内存对齐：数据在内存中的存储位置必须是特定字节数的倍数\nCPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问 golang内存对齐：\n基础类型：通常是其自身大小（如int32为4字节，int64为8字节） 结构体 每个字段按各自的对齐系数作对齐 结构体自身的对齐系数为所有字段中最大的对齐系数 数组：与元素类型的对齐系数相同 例：\ntype demo1 struct { a int8 b int16 c int32 } type demo2 struct { a int8 c int32 b int16 } type demo3 struct { a int8 c int32 b int16 d int16 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) // 8 fmt.Println(unsafe.Sizeof(demo2{})) // 12 fmt.Println(unsafe.Sizeof(demo3{})) // 12 } demo1:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节 c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可 demo2:\n","keywords":["Golang","2025"],"articleBody":"有很多从其他大佬的总结中抄来的，不注明出处了\n会记录一些:\n有意义的小操作(可能有些比较tricky) 容易理解偏差的点 日常开发低频使用的知识点 golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。\n了解更多可查看Golang内存模型规范。\ngolang内存对齐 内存对齐：数据在内存中的存储位置必须是特定字节数的倍数\nCPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问 golang内存对齐：\n基础类型：通常是其自身大小（如int32为4字节，int64为8字节） 结构体 每个字段按各自的对齐系数作对齐 结构体自身的对齐系数为所有字段中最大的对齐系数 数组：与元素类型的对齐系数相同 例：\ntype demo1 struct { a int8 b int16 c int32 } type demo2 struct { a int8 c int32 b int16 } type demo3 struct { a int8 c int32 b int16 d int16 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) // 8 fmt.Println(unsafe.Sizeof(demo2{})) // 12 fmt.Println(unsafe.Sizeof(demo3{})) // 12 } demo1:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节 c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可 demo2:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节 b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节 最终，demo2 的对齐倍数由 c 的对齐倍数决定，也是 4，因此，demo2还要占据 2 字节 ，内存占用为 12 字节 demo3:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节 b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节 d 是第四个字段，对齐倍数为 2，从第 10 个位置开始占据 2 字节 PS: 空 struct{} 的内存对齐\n空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）：\ntype demo3 struct { c int32 a struct{} } type demo4 struct { a struct{} c int32 } func main() { fmt.Println(unsafe.Sizeof(demo3{})) // 8 fmt.Println(unsafe.Sizeof(demo4{})) // 4 } 所以，我们一般可以通过结构体字段从大到小顺序排列来节约内存\ninternal包只导出到父目录 internal包，只能被和internal目录有同一个父目录的包所导入，go语言层面没有这个限制，这是通过go命令实现的。 例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。\n变量交换 go可以这样一行完成交换，官方Swap一般也都是这个写法\ni, j = j, i // 交换 i 和 j 的值 for循环break for循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。\nfor { select { case \u003c-sigChan: // exit for break default: // do something } } 以上break并不能退出for循环，可以使用标签或goto解决：\n// 1 标签 FOR: for { select { case \u003c-sigChan: // exit for break FOR default: // do something } } ------ // 2 goto for { select { case \u003c-sigChan: // exit for goto ENDFOR default: // do something } } ENDFOR: ------ 但请注意，goto一般由于影响可读性是禁用的 读取stdin(刷题别再踩坑了) fmt包内 Scan系列 SScan系列 Fscan系列如下：\n系列 无后缀 f后缀 ln后缀 Scan系列 Scan() Scanf() Scanln Sscan系列 Sscan() Sscanf() Sscanln() Fscan系列 Fscan() Fscanf() Fscanln() 将换行符当空格处理 根据给定的format读取 遇到换行符停止 他们的定义：\nfunc Scan(a ...interface{}) (n int, err error) func Scanf(format string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) func Sscan(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) 从定义可见，Scanln(其他同理)直接读取一行然后结束，但是从函数入参...interface{}就能知道，你需要明确的知道这一行空格会分隔出多少个你需要的值；可是平时做题最多的场景，一般是每一行有多少个值是个变量，需要先将一行按string读入，然后strings.Fields()直接获得一个[]string再慢慢处理。所以你应该这样做：\n// each line in stdin corresponding to a string in lines lines := make([]string, 0, anExpectedCap) scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { line := scanner.Text() lines = append(lines, line) } PS: 命令行 ctrl+d == EOF，结束输入。\n函数参数 函数参数别太多，必要时使用 结构体 ...values WithOption 来优化。\nWithOption模式:\n一个配置结构体，包含所有可选参数 多个以 With为前缀的函数（Option函数），每个函数负责设置一个或多个配置项 一个创建函数，接收这些Option函数作为参数，并应用这些配置 举个例子：\npackage main import \"fmt\" // Config 包含所有可选配置项 type Config struct { Timeout int MaxRetry int LogLevel string } // Option 定义函数类型，用于修改配置 type Option func(*Config) // WithTimeout 设置超时时间 func WithTimeout(timeout int) Option { return func(c *Config) { c.Timeout = timeout } } // WithMaxRetry 设置最大重试次数 func WithMaxRetry(maxRetry int) Option { return func(c *Config) { c.MaxRetry = maxRetry } } // WithLogLevel 设置日志级别 func WithLogLevel(level string) Option { return func(c *Config) { c.LogLevel = level } } // Client 客户端结构体 type Client struct { config Config } // NewClient 创建一个新的客户端，接收可选配置 func NewClient(options ...Option) *Client { // 设置默认配置 config := Config{ Timeout: 5, // 默认超时 5 秒 MaxRetry: 3, // 默认重试 3 次 LogLevel: \"info\", // 默认日志级别 info } // 应用所有选项 for _, opt := range options { opt(\u0026config) } return \u0026Client{config: config} } func main() { opts:=[]Option{ WithTimeout(10), WithLogLevel(\"debug\"), } client := NewClient(opts...) } 初始化顺序 任意文件可以有多个init函数用来做初始化工作。 Golang包初始化顺序为 全局变量\u003einit函数。 全局变量初始化顺序由他们之间的依赖关系决定(所以全局变量、type等的声明可忽略顺序)，无依赖关系时按声明顺序执行。 init函数的初始化顺序按init()函数声明顺序执行。\nfunc init(){ ... } func init(){ ... } func main(){ ... } // 复杂的初始化工作除了可以用init()函数解决外，还可以使用匿名函数，且在init函数之前执行 var ComplexTable [][]int = func()([][]int){ ... ... ... }() 看下匿名函数+init初始化混合的场景：\npackage main import ( \"fmt\" \"time\" ) func init(){ fmt.Println(\"3\") } func init(){ fmt.Println(\"2\") } func init(){ fmt.Println(\"1\") } var _ = func()bool{ fmt.Println(\"var init\") return true }() func main() { time.Sleep(time.Second) } ------ output: var init 3 2 1 init()初始化和匿名变量初始化这一类的操作，应该尽量避免使用\n*指针 = 表达式 “*指针 = 表达式” 形式可以直接修改指针指向的变量的值：\nx := 1 p := \u0026x // p, of type *int, points to x fmt.Println(*p) // \"1\" *p = 2 // equivalent to x = 2 fmt.Println(*p) // \"2\" fmt.Println(x) // \"2\" ,与} 使用逗号处理多item（函数参数，结构体成员等）时，结束的 )或} 可以跟在最后一行，也可以另起一行，当另起一行时，为避免编译器行尾自动补充分号导致编译错误，应在末尾的参数后显示插入逗号。\nfunc tt(a,b,c string)(){ ... } tt( \"a\", \"b\", \"c\", ) == tt( \"a\", \"b\", \"c\") ------ type TT struct{ A string B string C string } tt := TT{ A: \"a\", B: \"b\", C: \"c\", } == tt := TT{ A: \"a\", B: \"b\", C: \"c\"} 返回值数量不固定 以下场景，既可以返回两个值，也可以返回一个\nmap查找 类型断言 通道接收 v, ok = m[key] // map lookup v, ok = x.(T) // type assertion v, ok = \u003c-ch // channel receive v = m[key] // map查找，失败时返回零值 v = x.(T) // type断言，失败时panic异常 v = \u003c-ch // 管道接收，失败时返回零值（阻塞不算是失败） 中文名称不导出 Golang支持中文变量和类型名，对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出。\ntype 测试人员 struct { name string age int } func main(){ 测试人员_某某某 := \u0026测试人员{\"test\", 1} fmt.Printf(\"%v,%T,%+v\\n\", 测试人员_某某某, 测试人员_某某某, 测试人员_某某某) // 输出：\u0026{test 1},*main.测试人员,\u0026{name:test age:1} } 包注释写法 一个包通常只有一个源文件有包注释，如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释；如果某个包注释很大，通常会放到一个独立的doc.go文件中。\n{}语法块 {}包含的部分为一个句法块，可以显式的使用{}做作用域隔离：\nfunc main(){ tmp := 10 { tmp2 := 20 fmt.Println(tmp, tmp2) } fmt.Println(tmp) // can not recognize tmp2 here } 类似的，一组关联性比较高的变量，可以放在一起声明以使得可读性更高\npackage main import ( \"fmt\" ) func main() { var( a = 1 b = 2 c = 3 ) var( as = \"4\" bs = \"5\" cs = \"6\" ) fmt.Println(a,b,c,as,bs,cs) } ------ output: 1 2 3 4 5 6 if+return vs if+else Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进：\n// right res,err := doSomething() if err != nil{ printErr(err) return } res.DoSomething() // wrong res,err := doSomething() if err != nil{ printErr(err) } else { // res.DoSomething() 应该在主执行逻辑中，不建议缩进 res.DoSomething() } 格式化输出的[n]副词 fmt包Printf函数格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后添加[n]副词告诉Printf函数再次使用第n个操作数。\nfmt.Printf(\"%d, %d\\n\", 1, 2) // 1, 2 fmt.Printf(\"%d, %[1]d\\n\", 1) // 1, 1 二进制 fmt.Println(strconv.FormatInt(int64(123), 2)) // \"1111011\" fmt.Printf(\"%b\", 123) // \"1111011\" (deprecated - 没必要，不清晰) 创建slice简洁版 创建长度和容量都是100的string slice的简洁方法：\n// 正常 testSlice := make([]string, 100, 100) // 简洁版 testSlice := []string{99: \"\"} slice切割 当使用[:]切割int数组创建slice时，slice底层数组共用原数组，新slice的cap为切割起始位置至原数组末尾；因此，修改切割后的slice内元素时，将同时修改原数组，且修改slice的len以外cap以内的值时，也同时能够修改原数组：\ntestArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} cutTestArray := testArray[5:9] fmt.Println(cutTestArray, len(cutTestArray), cap(cutTestArray)) // [5 6 7 8] 4 7 cutTestArray[0] = 50 fmt.Println(cutTestArray, testArray) // [50 6 7 8] [0 1 2 3 4 50 6 7 8 9 10 11] cutTestArray = append(cutTestArray, 90) fmt.Println(cutTestArray, testArray) // [50 6 7 8 90] [0 1 2 3 4 50 6 7 8 90 10 11] 使用[:]切割字符串时，获得一个字符串且发生一次拷贝：\ntestStr := \"hello world\" cutTestStr := testStr[6:] fmt.Println(testStr, \u0026testStr, cutTestStr, \u0026cutTestStr) // hello world 0xc000010240 world 0xc000010250 … in Golang Golang …(3 dots) 用法: 参考 3 dots in Go\nslice操作考虑内存 给定一个string slice，去除其中\"“项：\n// 你可能想这么写： func filterEmptyStr(input []string) []string { ret := make([]string, 0) for _, item := range input { if item != \"\" { ret = append(ret, item) } } return ret } // 再想想，为了避免发生扩容拷贝，你可能会这么写： func filterEmptyStr(input []string) []string { ret := make([]string, 0, len(input)) for _, item := range input { if item != \"\" { ret = append(ret, item) } } return ret } // 其实，可以共用底层数据结构，这么写（问题是，输入的[]string被修改了）： func nonempty(strings []string) []string { i := 0 for _, s := range strings { if s != \"\" { strings[i] = s i++ } } return strings[:i] } // 再思考下，共用底层结构也可以这么写(太tricky，上一个更直观)： func nonempty2(strings []string) []string { out := strings[:0] // zero-length slice of original for _, s := range strings { if s != \"\" { out = append(out, s) } } return out } golang没有set类型 Go语言中没有提供set类型，一般用map实现类似set的功能。一般习惯是使用map[key]bool创建set，但是在高性能场景下，考虑到bool占一字节，可以使用map[key]struct{}, struct{}大小为0\n构造struct建议声明字段名 明确写好字段，更清晰直观\ntype Point struct{ X, Y int } p := Point{1, 2} // 建议： p := Point{ X: 1, Y: 2, } json.MarshalIndent json.MarshalIndent函数将产生整齐缩进的输出，该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：\ntype JsonTest struct { Item1 string Item2 string } jt1 := JsonTest{\"item1\", \"item2\"} msg, _ := json.Marshal(jt1) msgIndent, _ := json.MarshalIndent(jt1, \"\", \" \") fmt.Println(string(msg)) fmt.Println(string(msgIndent)) ------ output: {\"Item1\":\"item1\",\"Item2\":\"item2\"} { \"Item1\": \"item1\", \"Item2\": \"item2\" } “函数值\"使用前先判空 当使用“函数值”作为函数参数时，函数内部调用传入的函数值时记得先判空，函数值零值为nil，直接调用nil的函数值会引发panic。\n扩展来看，引用类型，能够与nil做==判断的，使用前都应该判空。\n(deprecated - go新特性)捕获迭代变量 for循环(尤其需要在for循环内开goroutine)时，使用循环变量之前需要先将循环变量赋值给循环体内的一个局部变量，如下例。\n问题的原因在于循环变量的作用域。在下面的例子中，for循环语句引入了新的词法块，循环变量name\u0026age在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以name为例，后续的迭代会不断更新name的值，当最终printer操作执行时，for循环已完成，name中存储的值等于最后一次迭代的值。这意味着，每次printer的调用输出的都是相同的最后那一个名字。\n为了解决这个问题，可以引入一个与循环变量同名的局部变量，作为循环变量的副本。\n// wrong, output: /* Pike 13 Pike 13 */ var printers []func() name2Age := map[string]string{\"Rob\": \"12\", \"Pike\": \"13\"} for name, age := range name2Age { printers = append(printers, func() { fmt.Println(name, age) }) } for _, printer := range printers { printer() } ------ // right, output: /* Rob 12 Pike 13 */ var printers []func() name2Age := map[string]string{\"Rob\": \"12\", \"Pike\": \"13\"} for name, age := range name2Age { name := name age := age printers = append(printers, func() { fmt.Println(name, age) }) } for _, printer := range printers { printer() } ------ // 下面两个例子的输出是一致的，因为fmt.Println()在每次循环内部即时调用 // 1 name2Age := map[string]string{\"Rob\": \"12\", \"Pike\": \"13\"} for name, age := range name2Age { fmt.Println(name, age) } // 2 name2Age := map[string]string{\"Rob\": \"12\", \"Pike\": \"13\"} for name, age := range name2Age { name := name age := age fmt.Println(name, age) } defer 被延迟执行的匿名函数可以修改函数返回给调用者的返回值：\nfunc add(x int) (result int) { defer func() { result += x }() return x + x } fmt.Println(add(4)) // \"12\" // 如果是参数那么将无法成功修改返回值: func add(x int) (result int) { defer func(result int) { result += x }(result) return x + x } fmt.Println(add(4)) // \"8\" 这里首先必须显示声明了返回值，以下方法不能成功修改返回值：\nfunc add(x int) int { result := x + x defer func() { result += x }() return result } fmt.Println(add(4)) // \"8\" 这是为什么呢？看下面例子，显示声明的返回值，defer中直接修改时，其实修改的是同一个地址，所以能够成功修改返回值。但是在上面的例子中，defer修改的仅仅是函数内的局部变量，而函数在return时将该局部变量拷贝到了调用栈的返回值中，所以defer修改局部变量成功，但是并不会体现在返回值上。\n上面的例子能说明defer的执行时机是返回值返回给调用者之后吗？ 不能，其实defer的执行时机是return之后，且返回值返回给调用方之前，看下面的例子，也正是因为defer执行在返回值真正返回给调用方之前，所以才能成功修改返回值。\nfunc add(x int) (result int) { fmt.Println(\"addr of result in add: \", \u0026result) defer func() { fmt.Println(\"addr of result in defer: \", \u0026result) result += x }() return x + x } fmt.Println(add(4)) // \"12\" ------ output: addr of result in add: 0xc00009e018 addr of result in defer: 0xc00009e018 12 为了证明 “defer执行在return之后，且返回值返回给调用方之前”，可以看下面的例子，可以看到调用方获得返回值紧跟defer完成以后。 因此啊，defer里面逻辑写不好，也会严重影响性能啊，如果是一些可并发的逻辑，可以defer里开新的goroutine去搞。\nfunc add(x int) (result int) { defer func() { fmt.Println(\"defer start \", time.Now()) time.Sleep(time.Second) result += x fmt.Println(time.Now(), \"result value in defer: \", result) time.Sleep(10 * time.Second) fmt.Println(\"defer end \", time.Now()) }() return x + x } x := add(4) fmt.Println(\"caller time: \", time.Now(), \"caller got: \", x) ------ output: defer start 2021-07-23 15:19:35.264078 +0800 CST m=+0.000999863 2021-07-23 15:19:36.265726 +0800 CST m=+1.002653773 result value in defer: 12 defer end 2021-07-23 15:19:46.270896 +0800 CST m=+11.007876743 caller time: 2021-07-23 15:19:46.270939 +0800 CST m=+11.007920326 caller got: 12 别在循环体内用defer 在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭：\nfor _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // NOTE: risky; could run out of file descriptors // ...process f… } 方法接收者(类型or其指针)一致性 如果某个struct有一个指针作为接收器的方法，那么该struct的所有方法都必须有一个指针接收器，即使并不需要。 换句话说，一个struct T，他的方法集要么都是func(t *T)DoSomething(){}，要么都是func (t T)DoSomething(){}。 Why？一致性吧。。。\n引用类型作为参数 函数参数是引用类型时，虽然仍可修改相同的底层数据，但是引用本身却是一份拷贝，当函数内修改引用本身时不会影响原值（比如赋值nil，或将引用指向其他对象）。 方法表达式中，接收者是表达式函数的第一个参数，所以该说明同样适用于方法；类型方法其接收者是类型的拷贝，类型指针方法其接收者是拷贝出的一份指向该类型的指针。\nfunc clearMap(input map[string]bool) { input = nil } func main() { tm := map[string]bool{\"test\": true, \"test1\": true} fmt.Println(tm) clearMap(tm) fmt.Println(tm) } ------ output: map[test:true test1:true] map[test:true test1:true] 内嵌 内嵌：一个 结构体/接口 直接包含另一个 结构体/接口 的成员\nGolang方法的接收者只能是命名类型或者其指针，但是由于内嵌这一特性，匿名struct也有手段可以拥有方法：\n// 两个包级别变量实现缓存 var ( mu sync.Mutex // guards mapping mapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() v := mapping[key] mu.Unlock() return v } ------ // 匿名struct存储在变量cache中，并且具备其内嵌struct Mutex的所有方法 var cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() v := cache.mapping[key] cache.Unlock() return v } 方法表达式 PS: 一般适合函数声明一致的一系列方法，再次封装后用参数指定操作方法\n当你根据一个变量来决定调用同一个类型的哪个函数时，可以根据选择来调用接收器各不相同的方法：\ntype Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } bit数组(本质上就是一个二维矩阵) Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。(再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组)。 一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i：\n// An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint64 } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/64, uint(x%64) return word \u003c len(s.words) \u0026\u0026 s.words[word]\u0026(1\u003c= len(s.words) { s.words = append(s.words, 0) } s.words[word] |= 1 \u003c\u003c bit } // UnionWith sets s to the union of s and t. func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // String returns the set as a string of the form \"{1 2 3}\". func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } for j := 0; j \u003c 64; j++ { if word\u0026(1\u003c len(\"{\") { buf.WriteByte(' ') } fmt.Fprintf(\u0026buf, \"%d\", 64*i+j) } } } buf.WriteByte('}') return buf.String() } 接口命名 Golang接口命名一般\"er\"结尾，例如：Loser。 er的含义一般都是什么什么人，是一个类，而这个类一般有一些典型的行为，例如程序员，Coder:\ntype Coder interface { WriteBug() SloveBug() } 如果是组合的接口，一般这样：\n// 和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法 type ReadWriter interface { Reader Writer } 接口定义位置 一般认为接口应该在使用者处定义，而不是提供者处定义\n接口赋值接口 var w io.Writer var rwc io.ReadWriteCloser w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method 实现接口 若某类型指针接收者的方法实现了接口，那么该类型的指针实现了接口，但是该类型变量并没有：\ntype InterfaceTest interface { Read(string) Write() string } type interfaceTestImpl struct { Name string } func (i *interfaceTestImpl) Read(name string) { i.Name = name } func (i *interfaceTestImpl) Write() string { return i.Name } var it InterfaceTest iti := interfaceTestImpl{\"name\"} it = iti // Cannot use 'iti' (type interfaceTestImpl) as type testpac.InterfaceTest Type does not implement 'testpac.InterfaceTest' as 'Read' method has a pointer receiver it = \u0026iti // ok 编译期类型检查 匿名变量实现编码期(编译)检查接口的实现等其他类型检查\n// *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) 突破Golang的导出限制 time.Sleep经常使用，但是点进去会发现他没有函数体：\nfunc Sleet(d Duration) 那么是在哪里实现的呢？\nruntime包有如下一段：\n//go:linkname timeSleep time.Sleep func timeSleep(ns int64) { if ns \u003c= 0 { return } t := getg().timer if t == nil { t = new(timer) getg().timer = t } ...... } runtime中的go:linkname把runtime的timeSleep与time.Sleep绑定在了一起\n//go:linkname localname importpath.name 这样做的好处是，timeSleep在runtime包内可以访问runtime内部，相当于runtime主动放出了一个叛徒给time包，帮助time包实现了time.Sleep函数\n访问其他包struct的私有字段？reflect的FieldByName可以支持访问，但不能修改；还想修改？那么可以使用unsafe包借助指针+偏移来实现读写\n编译器指令: //go:xxx 上面我们使用过 //go:linkname了，那么//go:xxx这个注释到底是个啥呢？其实这是一系列编译器指令。\n为了将它们与非指令注释区分开来，指令在注释开头和指令名称之间不需要空格 由于它们是注释，因此不了解指令约定或特定指令的工具可以像其他注释一样跳过指令 现在有的指令：\n//go:build xxx: 指定文件在xxx条件下会被编译 //go:build linux \u0026\u0026 amd64 // 仅在 Linux 系统且 amd64 架构下编译此文件 package main import \"fmt\" func main() { fmt.Println(\"Running on Linux amd64\") } //go:generate xxx: 在编译前自动生成代码，需通过go generate命令触发(不会被go build自动执行) //go:generate echo \"generate test\" package main func main(){} 执行go generate可输出 generate test pb桩代码就是//go:generate protoc ***生成的 //go:noinline : 告诉编译器不要对该函数进行内联优化 //go:inline : 提示编译器尽可能对该函数进行内联 //go:nosplit : 告诉编译器该函数不会触发栈分裂，即函数执行期间不会动态扩容栈空间 //go:linkname localname [importpath.name] : stringer + //go:generate go install golang.org/x/tools/cmd/stringer@latest 安装stringer工具\n//go:generate stringer -type=TT package main import ( \"fmt\" ) type TT int const( TT1 TT = iota + 1 TT2 TT3 ) func main() { fmt.Println(TT1) fmt.Println(TT2) fmt.Println(TT3) } 执行go generate，同目录下会出现tt_string.go:\n// Code generated by \"stringer -type=TT\"; DO NOT EDIT. package main import \"strconv\" func _() { // An \"invalid array index\" compiler error signifies that the constant values have changed. // Re-run the stringer command to generate them again. var x [1]struct{} _ = x[TT1-1] _ = x[TT2-2] _ = x[TT3-3] } const _TT_name = \"TT1TT2TT3\" var _TT_index = [...]uint8{0, 3, 6, 9} func (i TT) String() string { i -= 1 if i \u003c 0 || i \u003e= TT(len(_TT_index)-1) { return \"TT(\" + strconv.FormatInt(int64(i+1), 10) + \")\" } return _TT_name[_TT_index[i]:_TT_index[i+1]] } 再执行go run ./*.go会得到（而不是 1 2 3）：\nTT1 TT2 TT3 两个接口值的比较可能会panic 接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。 然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\nvar x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int 考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较非常确定它们的动态值是可比较类型的接口值。\n一个包含nil指针的接口不是nil接口 一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。 例：\nconst debug = true func main() { var buf *bytes.Buffer if debug { buf = new(bytes.Buffer) // enable collection of output } f(buf) // NOTE: subtly incorrect! if debug { // ...use buf... } } // If out is non-nil, output will be written to it. func f(out io.Writer) { // ...do something... if out != nil { out.Write([]byte(\"done!\\n\")) } } 当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\nif out != nil { out.Write([]byte(\"done!\\n\")) // panic: nil pointer dereference } 当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true。 动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者，但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。]\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\nvar buf io.Writer if debug { buf = new(bytes.Buffer) // enable collection of output } f(buf) // OK 通过断言询问接口的\"动态类型\"是否具备某些接口定义外的行为并使用 看例子：\nfunc writeHeader(w io.Writer, contentType string) error { if _, err := w.Write([]byte(\"Content-Type: \")); err != nil { return err } if _, err := w.Write([]byte(contentType)); err != nil { return err } // ... } io.Writer接口有方法func Write([]byte)(int, error)，但是这里做[]byte(string)的类型转换会引入开销：分配内存并拷贝。新分配的这块空间除了向io.Writer内写入就没有其他作用了，那么如果是在高并发场景这个操作可能会成为性能瓶颈，如何优化呢？\nio.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。查看net/http包源码，可以看到在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法(许多满足io.Writer接口的重要类型都有WriteString方法，包括*bytes.Buffer，*os.File和*bufio.Writer)。如何使用WriteString方法避免[]byte(string)类型转换的拷贝呢：\n// writeString writes s to w. // If w has a WriteString method, it is invoked instead of w.Write. func writeString(w io.Writer, s string) (n int, err error) { type stringWriter interface { WriteString(string) (n int, err error) } if sw, ok := w.(stringWriter); ok { return sw.WriteString(s) // avoid a copy } return w.Write([]byte(s)) // allocate temporary copy } func writeHeader(w io.Writer, contentType string) error { if _, err := writeString(w, \"Content-Type: \"); err != nil { return err } if _, err := writeString(w, contentType); err != nil { return err } // ... } 关于接口 当设计一个新的包时，somebody总是习惯先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗，并且代码可读性大大降低。可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。\n当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。\n因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）\nfmt.Printf + \\r 实现动态输出 \\r == 返回行首，覆盖之前的文字，可以实现动态滚动输出\nfor _, r := range `-\\|/` { fmt.Printf(\"\\r%c\", r) time.Sleep(100 * time.Millisecond) } ------ output: -转圈圈 channel由生产者关闭 因为向关闭的channel写入会引发panic，channel的close应该有写入方执行\nchannel 与 (for range, select case) 无论是有缓存还是无缓存，可以for range持续从channel获取值：\nfor i := range someChan { println(i) } 对于无缓存channel, for range读取后且channel关闭，则循环结束。 对于有缓存channel, 即使channel关闭，for range也会继续读取直到读取完毕。 总结：for range监听channel，结束条件为 channel关闭且channel内容读取完毕。\nselect和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身或者包含在一个简短的变量声明中:\nselect { case \u003c-ch1: // ... case x := \u003c-ch2: // ...use x... case ch3 \u003c- y: // ... default: // ... } select特性：\n如果某个case代码块准备好发送或接收，执行对应内容 如果多个(\u003e1)case代码块准备好发送或接收，随机选取一个并执行对应内容 如果所有case代码块都没有准备好 无default，等待 有default，执行default select{}永远等待 一个没有任何case的select语句写作select{}，会永远地等待下去。\nselect 与 time.After time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句包含了一个超时保护：\nselect { case \u003c-time.After(10 * time.Second): // 超时时间10s，若超时什么都不做，退出select case \u003c-aSigChan: doSomething() } ... select的一个骚操作 ch := make(chan int, 1) for i := 0; i \u003c 10; i++ { select { case x := \u003c-ch: fmt.Println(x) // \"0\" \"2\" \"4\" \"6\" \"8\" case ch \u003c- i: } } 轮询channel 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作就是“轮询channel”\nselect { case \u003c-abort: fmt.Printf(\"Launch aborted!\\n\") return default: // do nothing } time.Tick(内存泄漏风险) time.Tick通常用作定时器：\nfunc main() { tick := time.Tick(time.Second) for { \u003c-tick fmt.Println(\"hello\") } } 以上例子每秒输出一个hello，但是time.Tick如果像下面这样使用：\ntick := time.Tick(time.Second) select { case \u003c-tick: // do something case \u003c-aChanSig: // do something } 当select逻辑执行完毕后，tick的goroutine仍然存活着，周期性的尝试向tick中发送值，导致goroutine泄露。 只有当程序整个生命周期都需要时才适合使用time.Tick。否则的话，可以这样用：\nticker := time.NewTicker(1 * time.Second) \u003c-ticker.C // receive from the ticker's channel ticker.Stop() // cause the ticker's goroutine to terminate 单方向channel 例如：\nchan\u003c- int:只发送 \u003c-chan int:只接收 通常一个函数参数的channel，参数输入(in)是一个只接受的channel，结果输出(out)是一个只发送的channel：\nfunc doSomeCalc(in \u003c-chan int, out chan\u003c- int){ for input := range in{ out \u003c- calc(input) } } 对一个只接收的channel调用close是一个编译错误。\nmake(chan int) 和 make(chan int, 1) 的区别 test := make(chan int)无缓存，无接收时，test \u003c- 1阻塞。 test := make(chan int, 1)带缓存，容量1，无接收时，test \u003c- 1不阻塞。\n如何判断channel关闭 a := make(chan int) // a没有关闭，以下语句会阻塞，直到a有值输入，intV==值，ok==true intV, ok := \u003c-a ------ a := make(chan int) close(a) // a关闭，以下语句不会阻塞，intV==0(int零值)，ok==false intV, ok := \u003c-a 避免将一个channel用在唯一一个goroutine中 无缓存channel当然不能只在同一个goroutine使用，这必然会导致该goroutine阻塞。 有缓存的channel可以用在一个goroutine中，可以作队列用，但是不建议这样使用。\n带缓存channel的竞速 下面例子并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。\nfunc mirroredQuery() string { responses := make(chan string, 3) go func() { responses \u003c- request(\"asia.gopl.io\") }() go func() { responses \u003c- request(\"europe.gopl.io\") }() go func() { responses \u003c- request(\"americas.gopl.io\") }() return \u003c-responses // return the quickest response } func request(hostname string) (response string) { /* ... */ } 上面的竞速和下面有什么区别呢？下面的竞速使用了无缓存的channel，两个比较慢的goroutine将因为channel无人接收而永远卡住，并且不会被自动回收，从而导致goroutine泄漏。\nfunc mirroredQuery() string { responses := make(chan string) go func() { responses \u003c- request(\"asia.gopl.io\") }() go func() { responses \u003c- request(\"europe.gopl.io\") }() go func() { responses \u003c- request(\"americas.gopl.io\") }() return \u003c-responses // return the quickest response } func request(hostname string) (response string) { /* ... */ } pipeline(串联channels) channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline），见下例和图：\nfunc main() { naturals := make(chan int) squares := make(chan int) // Counter go func() { for x := 0; x \u003c 100; x++ { naturals \u003c- x } close(naturals) }() // Squarer go func() { for x := range naturals { squares \u003c- x * x } close(squares) }() // Printer (in main goroutine) for x := range squares { fmt.Println(x) } } counter是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给squarer求平方，squarer将平方结果通过第二个channel发送给printer。\n并发的非阻塞缓存 场景：缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。 需求：并发安全，且避免对整个缓存加锁而导致所有操作都去争一个锁。\n函数例程：\n// 进行HTTP GET请求并且获取http响应body, 开销大, 应避免在不必要的时候反复调用 func httpGetBody(url string) (interface{}, error) { resp, err := http.Get(url) if err != nil { return nil, err } defer resp.Body.Close() return ioutil.ReadAll(resp.Body) } 缓存实现：\n// Package memo provides a concurrency-unsafe // memoization of a function of type Func. package memo // A Memo caches the results of calling a Func. type Memo struct { f Func cache map[string]result } // Func is the type of the function to memoize. type Func func(key string) (interface{}, error) type result struct { value interface{} err error } func New(f Func) *Memo { return \u0026Memo{f: f, cache: make(map[string]result)} } // NOTE: not concurrency-safe! func (memo *Memo) Get(key string) (interface{}, error) { res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } return res.value, res.err } 顺序的测试缓存：\nm := memo.New(httpGetBody) for url := range incomingURLs() { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\"%s, %s, %d bytes\\n\", url, time.Since(start), len(value.([]byte))) } ------ output: https://golang.org, 175.026418ms, 7537 bytes https://godoc.org, 172.686825ms, 6878 bytes https://play.golang.org, 115.762377ms, 5767 bytes http://gopl.io, 749.887242ms, 2856 bytes https://golang.org, 721ns, 7537 bytes https://godoc.org, 152ns, 6878 bytes https://play.golang.org, 205ns, 5767 bytes http://gopl.io, 326ns, 2856 bytes 那么如果像下面这样并发的测试缓存，由于Get函数不是concurrency-safe，所有会有数据竞争。\nm := memo.New(httpGetBody) var n sync.WaitGroup for url := range incomingURLs() { n.Add(1) go func(url string) { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\"%s, %s, %d bytes\\n\", url, time.Since(start), len(value.([]byte))) n.Done() }(url) } n.Wait() 使用-race来观察数据竞争会看到：\n... WARNING: DATA RACE Write by goroutine 36: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 *** *** ... Previous write by goroutine 35: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 *** *** ... Found 1 data race(s) 消除数据竞争最简单的方法就是加锁：\ntype Memo struct { f Func mu sync.Mutex // guards cache cache map[string]result } // Get is concurrency-safe. func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } memo.mu.Unlock() return res.value, res.err } 但是加了这个锁，Get就将本来可以并行的I/O操作串行化了。\n怎么优化呢？上面Lock锁的范围太大了，考虑缩小临界区，下面的优化把开销最大的I/O操作从临界区分离出来，使得I/O操作可并发，但是，对于相同的key，memo.f(key)可能会重复执行。\nfunc (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] memo.mu.Unlock() if !ok { res.value, res.err = memo.f(key) // Between the two critical sections, several goroutines // may race to compute f(key) and update the map. memo.mu.Lock() memo.cache[key] = res memo.mu.Unlock() } return res.value, res.err } 上述的重复工作是应该避免的，即duplicate suppression(重复抑制)。看下面的优化。获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成(也就是有其它的goroutine在调用f这个慢函数)时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。 如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。 条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到\"ready\"的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。 这样并发、不重复、无阻塞的cache就完成了。\ntype entry struct { res result ready chan struct{} // closed when res is ready } func New(f Func) *Memo { return \u0026Memo{f: f, cache: make(map[string]*entry)} } type Memo struct { f Func mu sync.Mutex // guards cache cache map[string]*entry } func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() e := memo.cache[key] if e == nil { // This is the first request for this key. // This goroutine becomes responsible for computing // the value and broadcasting the ready condition. e = \u0026entry{ready: make(chan struct{})} memo.cache[key] = e memo.mu.Unlock() e.res.value, e.res.err = memo.f(key) close(e.ready) // broadcast ready condition } else { // This is a repeat request for this key. memo.mu.Unlock() \u003c-e.ready // wait for ready condition } return e.res.value, e.res.err } 上面的例子使用互斥量来保护多个goroutine调用Get时的共享map变量。接下来使用monitor goroutine(把map变量限制在一个单独goroutine)方案再实现一遍，使用monitor goroutine时需要使用到消息。（共享内存通信 vs 消息通信）\n// Func is the type of the function to memoize. type Func func(key string) (interface{}, error) // A result is the result of calling a Func. type result struct { value interface{} err error } type entry struct { res result ready chan struct{} // closed when res is ready } // A request is a message requesting that the Func be applied to key. type request struct { key string response chan\u003c- result // the client wants a single result } type Memo struct{ requests chan request } // New returns a memoization of f. Clients must subsequently call Close. func New(f Func) *Memo { memo := \u0026Memo{requests: make(chan request)} go memo.server(f) return memo } func (memo *Memo) Get(key string) (interface{}, error) { response := make(chan result) memo.requests \u003c- request{key, response} res := \u003c-response return res.value, res.err } func (memo *Memo) Close() { close(memo.requests) } func (memo *Memo) server(f Func) { cache := make(map[string]*entry) for req := range memo.requests { e := cache[req.key] if e == nil { // This is the first request for this key. e = \u0026entry{ready: make(chan struct{})} cache[req.key] = e go e.call(f, req.key) // call f(key) } go e.deliver(req.response) } } func (e *entry) call(f Func, key string) { // Evaluate the function. e.res.value, e.res.err = f(key) // Broadcast the ready condition. close(e.ready) } func (e *entry) deliver(response chan\u003c- result) { // Wait for the ready condition. \u003c-e.ready // Send the result to the client. response \u003c- e.res } context context翻译：\n上下文;语境;(事情发生的)背景，环境 上下文，就是一段代码(线程、协程等调度单元)在CPU的寄存器状态集，运行代码就把这段状态加载到寄存器，切出代码就把寄存器的状态保存到缓存或内存。\ngo的context本质上也是goroutine间通信的工具，用于在多个goroutine之间共享消息。channel是goroutine之间传递消息的桥梁，当然也可以用来传递一个关闭信号(channel+select实现)，但是如果需要“广播”，可以使用close channel的方式发送一个“广播”信号；context其实就是帮助做了“广播”，其Done方法就是利用一个 \u003c-chan struct{} 的关闭来实现“广播”效果；此外，context还能存储一些信息，用来在多个goroutine之间共享。\n关于context的几点说明：\n不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据，例如：登陆的 session、cookie 等 同一个 context 可能会被传递到多个 goroutine，但 context 是并发安全，所以没关系 几个关键函数：\n// Background returns a non-nil, empty Context. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context // TODO returns a non-nil, empty Context. Code should use context.TODO when // it's unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context // 与共享信息有关的 WithValue // WithValue returns a copy of parent in which the value associated with key is // val. // // Use context Values only for request-scoped data that transits processes and // APIs, not for passing optional parameters to functions. // // The provided key must be comparable and should not be of type // string or any other built-in type to avoid collisions between // packages using context. Users of WithValue should define their own // types for keys. To avoid allocating when assigning to an // interface{}, context keys often have concrete type // struct{}. Alternatively, exported context key variables' static // type should be a pointer or interface. func WithValue(parent Context, key, val interface{}) Context // 与“广播”控制有关的 WithCancel WithDeadline WithTimeout // WithCancel returns a copy of parent with a new Done channel. The returned // context's Done channel is closed when the returned cancel function is called // or when the parent context's Done channel is closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this Context complete. func WithCancel(parent Context) (ctx Context, cancel CancelFunc) // WithDeadline returns a copy of the parent context with the deadline adjusted // to be no later than d. If the parent's deadline is already earlier than d, // WithDeadline(parent, d) is semantically equivalent to parent. The returned // context's Done channel is closed when the deadline expires, when the returned // cancel function is called, or when the parent context's Done channel is // closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this Context complete. func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 从上面函数的定义可以看到，context的cancelFunc是与context一同分开返回的，context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context。\n举个简单栗子：\npackage main import ( \"context\" \"fmt\" \"time\" ) func main() { background := context.Background() // input values values := map[string]string{ \"key1\": \"value1\", \"key2\": \"value2\", } ctxWithValue, _ := context.WithCancel(background) for k, v := range values { ctxWithValue = context.WithValue(ctxWithValue, k, v) } // timeout: 10s, protect usage ctxWithTimeout, cancelFunc := context.WithTimeout(ctxWithValue, time.Second*10) goroutineCount := 10 for i := 0; i \u003c goroutineCount; i++ { go func(ctx context.Context, index int) { count := 0 for { fmt.Println(\"gouroutine index: \", index, \" \", \"count: \", count, \" \", \"key1: \", ctx.Value(\"key1\")) count++ time.Sleep(time.Millisecond * 500) } }(ctxWithTimeout, i) } // sleep 3s, actually should do something time.Sleep(time.Second * 3) cancelFunc() } context可能不是很完美：\nctx放在函数第一个参数，导致代码中ctx泛滥 ctx创建子节点，底层实际是在链表中创建节点，链表的O(n)有些时候会降低效率 但是，context简便的解决了\"cancelation\"的问题。\n*context context限制信息流向，子context一般不允许修改父context内容，并且一般函数传递(ctx context.Context)参数时就直接避免了这一点，但是，如果某些场景需要修改context内容，需要使用(ctxPtr *context.Context)参数。\n*_test 测试package 包net/url(例子)同路径可以再声明一个net/url_test包。包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。 可以将这个外部测试包的导入路径视作是net/url_test会，但是实际上，它并不能被其他任何包导入。\n包内测试函数就可以测试逻辑，为啥还要搞外部测试包？ 外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包，包内的测试代码无法做到这点。 在设计层面，外部测试包是在所有它依赖的包的上层。 举个具体的例子，B包依赖的A包，A包在进行测试时，希望使用B包的功能，可是如果A直接importB，那么就发生了循环依赖，将导致编译报错。此时就可以在A同级开一个A_test的外部测试包，这个测试包可以以一个第三方包的角色同时import A B，这样就可以测试了\n别写脆弱的测试代码 避免脆弱测试代码的方法是只检测真正关心的属性。\n保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串（很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试）。\n总之单元测试的原则是：\n逻辑覆盖全面 尽量保持自身鲁棒性，少依赖不稳定性因素 表驱动测试 单元测试的测试用例最好按照input=\u003eexpected output映射表方式管理，不仅可以简化测试代码(for循环完成检测)，同时也能更方便的管理测试用例\ngo test + go tool cover 关于go test, go tool cover可具体查看命令文档。\n实践：\n// 生成测试文件test-tmp.out // -coverprofile 通过在测试代码中插入生成钩子来统计覆盖率数据 // 在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入输出文件，并打印一部分执行的语句的一个总结 // 如果只需要摘要，可以使用 -cover go test -covermode=count -coverprofile=test-tmp.out ./... // 浏览器html形式查看测试报告 go tool cover -html=test-tmp.out go test + 性能分析 go test -cpuprofile=cpu.out // cpu go test -blockprofile=block.out // 阻塞：记录阻塞goroutine最久的操作 go test -memprofile=mem.out // 内存 benchmark(基准测试) go的testing包提供的更直观的测试代码性能的方法，要学会使用benchmark优化自己的代码。\n举个例子：\nxxx.go: ------ package xxx // 被测试的函数：计算第n个斐波那契数 func fib(n int) int { if n \u003c= 1 { return n } return fib(n-1) + fib(n-2) } ------ xxx_test.go ------ package xxx import \"testing\" // 基准测试函数 func BenchmarkFib(b *testing.B) { // b.N会由测试框架根据情况自动调整，确保测试有足够的运行时间 for i := 0; i \u003c b.N; i++ { fib(10) // 测试计算第10个斐波那契数的性能 } } // 可以为不同的输入添加多个基准测试 func BenchmarkFib20(b *testing.B) { for i := 0; i \u003c b.N; i++ { fib(20) // 测试计算第20个斐波那契数的性能 } } benchmark测试命令：\ngo test [-bench=\u003c正则表达式\u003e] [其他选项] [包路径] -bench：指定要运行的基准测试，支持正则表达式匹配测试函数名 其他选项 -benchtime=5s 指定基准测试的最小运行时间(默认1秒) -benchmem 显示内存分配信息 包路径：若不指定，默认测试当前目录下的包 golang指针运算 Go的指针是不支持运算的，但是借助unsafe.Pointer和uintptr可以实现这个骚操作。\n类型 概念 持有对象(即指针不释放，其持有的对象GC无法回收) 指针运算 转换 * 普通的指针，传递对象的地址 可持有 不支持 与unsafe.Pointer相互转换 unsafe.Pointer 类似C的void*，可以包含任意类型变量的地址 可持有 不支持 与 *和uintptr 相互转换 uintptr 可以理解为一个纯数值?(字节长度与int一致，uintptr is an integer type that is large enough to hold the bit pattern of any pointer) 不可持有(GC 不把 uintptr 当指针，uintptr 类型的目标会被回收) 支持 与unsafe.Pointer相互转换 如上表，unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。\n举个栗子：\npackage main ​ import ( \"fmt\" \"unsafe\" ) ​ func main() { //定义一个长度为3的int8类型数组 a:=[3]int8{6,8,9} //取出数组第一个位置的地址 a_first_point:=\u0026a[0] a_first_unsafe_point:=unsafe.Pointer(a_first_point) fmt.Println(\"a[0]的地址为：\",a_first_unsafe_point) //指针只能一个字节字节取，int8占一个字节，所以看到值只加了1 fmt.Println(\"a[1]的地址为：\",unsafe.Pointer(\u0026a[1])) //把a_first_unsafe_point转成uintptr类型，就可以指针运算了 a_uintptr_first_unsafe_point:=uintptr(a_first_unsafe_point) //指针+1 表示到了数组的第二个位置 a_uintptr_first_unsafe_point++ fmt.Println(\"a[0]位置指针自增1后，的指针位置：\",a_uintptr_first_unsafe_point) //打印出来可以看到跟\u0026a[1]的地址是一样的 a_uintptr_second_unsafe_point:=unsafe.Pointer(a_uintptr_first_unsafe_point) fmt.Println(\"a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型：\",a_uintptr_second_unsafe_point) //将该指针转换成 *int8类型（因为它本身就是*int8类型） int8_point:=(*int8)(a_uintptr_second_unsafe_point) //解引用，得到指针对应的结果，就是数组的第二个值，8 fmt.Println(*int8_point) ​ } ------ output: a[0]的地址为： 0xc000118000 a[1]的地址为： 0xc000118001 a[0]位置指针自增1后，的指针位置： 824634867713 a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型： 0xc000118001 8 再举个正反栗：\n// right var x struct { a bool b int16 c []int } // 和 pb := \u0026x.b 等价 pb := (*int16)(unsafe.Pointer( uintptr(unsafe.Pointer(\u0026x)) + unsafe.Offsetof(x.b))) *pb = 42 fmt.Println(x.b) // \"42\" ------ // wrong // NOTE: subtly incorrect! // 错误的原因是引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针 // 当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的\u0026x.b地址 // 第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序 tmp := uintptr(unsafe.Pointer(\u0026x)) + unsafe.Offsetof(x.b) pb := (*int16)(unsafe.Pointer(tmp)) *pb = 42 ------ // 错误的原因是，并没有指针引用new新创建的变量，因此该语句执行完成之后， // 垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址 pT := uintptr(unsafe.Pointer(new(T))) 看了上面的例子，当从其他地方获取到了uintptr以后，为了避免GC回收其对应地址的变量，应该尽快将uintptr转化为unsafe.Pointer。\n错误处理习惯 优先使用 errors.New 来创建错误变量，如果有格式化需求，可以使用 fmt.Errorf 在 fmt.Errorf 中使用 : %w 关键字来将一个错误 wrap 至其错误链中 Go1.20后，使用errors.Join取代上一点 使用 errors.Unwrap 来获得其错误链的上一个错误 使用 errors.Is 而非 == 来判定一个错误是否为特定错误(能够追溯错误链) 在错误链上获取特定种类的错误，使用 errors.As 预先定义枚举好error然后返回，在错误场景比较清晰明确的时候推荐使用 自定义错误：内部逻辑可以使用，一般不要向外传递 一行代码recover 平时goroutine场景我们经常需要recover()保护一下我们的goroutine，以将panic影响范围控制到最小，这个高频使用场景如何简化呢？\n首先，panic信息的输出可以按自己习惯封装一下，一般使用明显的\"panic\"关键字标识，排查方便一般也会同时补充一下栈信息 ------ // FormatRecover - generate error from recover(). func FormatRecover(recoverErr any) error { if recoverErr == nil { return nil } return fmt.Errorf(\"panic: %v\\n%s\", recoverErr, string(debug.Stack())) } ------ 然后我们一般使用\"err error\"形式的具名返回值给defer操作空间，然后像下面这样一行搞定。 我们不需要判空，nil error经过errors.Join后还是一个nil error。 ------ func xxx() (ret int, err error) { defer func() { err = errors.Join(err, util.FormatRecover(recover())) }() } 一行代码统计函数耗时 package main import( \"fmt\" \"time\" ) func main() { defer CostRecord(\"main\", someLogger)() xxx } func CostRecord(funcName string, logger) func(){ start:=time.Now() logger.Infof(\"%s start\", funcName) return func(){ logger.Infof(\"%s cost: %v\", funcName, time.Since(start)) } } 方法优先使用指针接受者 方法链 在定义struct内部操作方法时，仍然返回其自身，这样多个操作就可以做成“链”\n注意：指针接收\nPS: gorm的源码大量的使用方法链方便处理\npackage main import( \"fmt\" \"time\" ) type Somebody struct{ Name string Age int } func (s *Somebody)UpdateName(n string)*Somebody{ s.Name = n return s } func (s *Somebody)UpdateAge(a int)*Somebody{ s.Age = a return s } func main() { s:=Somebody{\"heihei\", 1} fmt.Println(s) s.UpdateName(\"haha\").UpdateAge(10) // 这里更清晰优雅 fmt.Println(s) } ------ output: {heihei 1} {haha 10} 函数链 上一条我们看到了方法链很方便，那么我们日常的函数呢？ 下面可能是一个常见的代码：\nfunc a()(int,error) func process(input int) error func main(){ ret,err:=a() if err!=nil{ xxx return } err=process(ret) if err!=nil{ xxx } } 如果process能够接受a的全部返回值并且有能力处理a返回的错误，那么我们可以这样写\nfunc a()(int,error) func process(input int, err error) error func main(){ err:=process(a()) if err!=nil{ xxx } } 数字分隔符_ 用_分隔长数字串提升可读性\npackage main import( \"fmt\" ) const( pai = 3.141_592_6 bi = 1_000_000 ) func main() { fmt.Println(pai) fmt.Println(bi) } ------ output: 3.1415926 1000000 crypto/rand \u003e math/rand math/rand手动指定种子，尤其适用时间戳做种子时，临近时间的种子几乎相等，更加伪随机； crypto/rand随机性更好。\n== 比较 对于any(interface{})的比较，只有当类型和值都相同时，才被判定为==;\n注意区分类型定义和类型别名: type A int // 新类型, 不是int type B = int // 类型别名, 类型是int ------ package main import( \"fmt\" \"reflect\" ) type A int // 新类型 type B = int // 类型别名 func main() { var a A = 1 var b B = 1 var c int =1 fmt.Println(reflect.DeepEqual(a, c)) // false fmt.Println(reflect.DeepEqual(b, c)) // true } 利用这个特性，在context.WithValue传递数据时，为避免key冲突，可以考虑使用特定的类型或者结构体来作为key\npanic的使用 panic必须在同goroutine捕获处理 尽量少主动抛出panic, 做好error处理 如果有些场景可能主动panic,函数命名一般采用MustXXX 尽量保留对goroutine声明周期的管理 例如下面这样，使用ctx来管理goroutine生命周期\nfunc do(ctx context.Context){ select{ case \u003c-ctx.Done(): return default: // do sth time.Sleep(time.Second) } } 简单并发场景使用好errorgroup 默认情况下，errorgroup会等待所有任务完成并返回第一个错误(仅返回第一个非nil错误，后续错误会被忽略) errorgroup会等待所有任务完成，即不主动终止其他正在运行的任务；如果希望第一个错误发生后立即取消其他任务，可以结合context.WithCancel实现\npackage main import ( \"context\" \"errors\" \"fmt\" \"golang.org/x/sync/errorgroup\" \"time\" ) func main() { // 创建带取消功能的上下文 ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 确保最终释放 // 创建关联上下文的 errorgroup eg, ctx := errorgroup.WithContext(ctx) // 任务1：监听上下文取消 eg.Go(func() error { select { case \u003c-time.After(200 * time.Millisecond): fmt.Println(\"任务1完成\") return nil case \u003c-ctx.Done(): // 若上下文被取消，提前退出 fmt.Println(\"任务1被取消\") return ctx.Err() } }) // 任务2：主动返回错误（触发取消） eg.Go(func() error { time.Sleep(100 * time.Millisecond) fmt.Println(\"任务2失败\") return errors.New(\"任务2出错了\") }) // 任务3：监听上下文取消 eg.Go(func() error { select { case \u003c-time.After(300 * time.Millisecond): fmt.Println(\"任务3完成\") return nil case \u003c-ctx.Done(): fmt.Println(\"任务3被取消\") return ctx.Err() } }) // 等待结果 if err := eg.Wait(); err != nil { fmt.Printf(\"整体执行失败：%v\\n\", err) } else { fmt.Println(\"所有任务执行成功\") } } 带ctx的Sleep函数 通常我们等待会直接time.Sleep，但是这样不受控制，因此可以这样改进：\nfunc SleepWithContext(ctx context.Context, duration time.Duration) error { select { case \u003c-time.After(duration): // 睡眠时间到，正常返回 return nil case \u003c-ctx.Done(): // 上下文被取消（超时、取消等），返回上下文的错误 return ctx.Err() } } func xxx(ctx context.Context){ for{ select{ case \u003c-ctx.Done(): return default: if err:=SleepWithContext(ctx,time.Second);err!=nil{ xxx } } } } %s vs %q %s输出字符串，特殊字符会处理 %q带\"“输出字符串，特殊字符原样输出 package main import( \"fmt\" ) func main() { abc := \"aa\\nbb\\tcc\" fmt.Printf(\"%s\\n\",abc) fmt.Println() fmt.Printf(\"%q\\n\",abc) } ------ output: aa bb\tcc \"aa\\nbb\\tcc\" ","wordCount":"5264","inLanguage":"en","image":"https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-06-22T00:00:00Z","dateModified":"2021-07-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://duck-dd.github.io/posts/2025-06-22-go-tips/"},"publisher":{"@type":"Organization","name":"Duck","logo":{"@type":"ImageObject","url":"https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://duck-dd.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://duck-dd.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://duck-dd.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://duck-dd.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://duck-dd.github.io/about_me title=关于我><span>关于我</span></a></li><li><a href=https://duck-dd.github.io/about_space title=关于这里><span>关于这里</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://duck-dd.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://duck-dd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">go tips(持续更新)</h1><div class=post-meta><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;创建于:&nbsp;2021-07-01&nbsp;·&nbsp;25 min&nbsp;·&nbsp;5264 words<div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/categories/cs/>CS</a></div><div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/tags/golang/>Golang</a>
<span>,</span>
<a href=https://duck-dd.github.io/tags/2025/>2025</a></div></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#golang%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f aria-label=golang代码执行顺序>golang代码执行顺序</a></li><li><a href=#golang%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 aria-label=golang内存对齐>golang内存对齐</a></li><li><a href=#internal%e5%8c%85%e5%8f%aa%e5%af%bc%e5%87%ba%e5%88%b0%e7%88%b6%e7%9b%ae%e5%bd%95 aria-label=internal包只导出到父目录>internal包只导出到父目录</a></li><li><a href=#%e5%8f%98%e9%87%8f%e4%ba%a4%e6%8d%a2 aria-label=变量交换>变量交换</a></li><li><a href=#for%e5%be%aa%e7%8e%afbreak aria-label=for循环break>for循环break</a></li><li><a href=#%e8%af%bb%e5%8f%96stdin%e5%88%b7%e9%a2%98%e5%88%ab%e5%86%8d%e8%b8%a9%e5%9d%91%e4%ba%86 aria-label=读取stdin(刷题别再踩坑了)>读取stdin(刷题别再踩坑了)</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0 aria-label=函数参数>函数参数</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f aria-label=初始化顺序>初始化顺序</a></li><li><a href=#%e6%8c%87%e9%92%88--%e8%a1%a8%e8%be%be%e5%bc%8f aria-label="*指针 = 表达式">*指针 = 表达式</a></li><li><a href=#%e4%b8%8e aria-label=,与}>,与}</a></li><li><a href=#%e8%bf%94%e5%9b%9e%e5%80%bc%e6%95%b0%e9%87%8f%e4%b8%8d%e5%9b%ba%e5%ae%9a aria-label=返回值数量不固定>返回值数量不固定</a></li><li><a href=#%e4%b8%ad%e6%96%87%e5%90%8d%e7%a7%b0%e4%b8%8d%e5%af%bc%e5%87%ba aria-label=中文名称不导出>中文名称不导出</a></li><li><a href=#%e5%8c%85%e6%b3%a8%e9%87%8a%e5%86%99%e6%b3%95 aria-label=包注释写法>包注释写法</a></li><li><a href=#%e8%af%ad%e6%b3%95%e5%9d%97 aria-label={}语法块>{}语法块</a></li><li><a href=#ifreturn-vs-ifelse aria-label="if+return vs if+else">if+return vs if+else</a></li><li><a href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba%e7%9a%84n%e5%89%af%e8%af%8d aria-label=格式化输出的[n]副词>格式化输出的[n]副词</a></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6 aria-label=二进制>二进制</a></li><li><a href=#deprecated---%e6%b2%a1%e5%bf%85%e8%a6%81%e4%b8%8d%e6%b8%85%e6%99%b0-%e5%88%9b%e5%bb%baslice%e7%ae%80%e6%b4%81%e7%89%88 aria-label="(deprecated - 没必要，不清晰) 创建slice简洁版">(deprecated - 没必要，不清晰) 创建slice简洁版</a></li><li><a href=#slice%e5%88%87%e5%89%b2 aria-label=slice切割>slice切割</a></li><li><a href=#-in-golang aria-label="&mldr; in Golang">&mldr; in Golang</a></li><li><a href=#slice%e6%93%8d%e4%bd%9c%e8%80%83%e8%99%91%e5%86%85%e5%ad%98 aria-label=slice操作考虑内存>slice操作考虑内存</a></li><li><a href=#golang%e6%b2%a1%e6%9c%89set%e7%b1%bb%e5%9e%8b aria-label=golang没有set类型>golang没有set类型</a></li><li><a href=#%e6%9e%84%e9%80%a0struct%e5%bb%ba%e8%ae%ae%e5%a3%b0%e6%98%8e%e5%ad%97%e6%ae%b5%e5%90%8d aria-label=构造struct建议声明字段名>构造struct建议声明字段名</a></li><li><a href=#jsonmarshalindent aria-label=json.MarshalIndent>json.MarshalIndent</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%80%bc%e4%bd%bf%e7%94%a8%e5%89%8d%e5%85%88%e5%88%a4%e7%a9%ba aria-label='&ldquo;函数值"使用前先判空'>&ldquo;函数值"使用前先判空</a></li><li><a href=#deprecated---go%e6%96%b0%e7%89%b9%e6%80%a7%e6%8d%95%e8%8e%b7%e8%bf%ad%e4%bb%a3%e5%8f%98%e9%87%8f aria-label="(deprecated - go新特性)捕获迭代变量">(deprecated - go新特性)捕获迭代变量</a></li><li><a href=#defer aria-label=defer>defer</a></li><li><a href=#%e5%88%ab%e5%9c%a8%e5%be%aa%e7%8e%af%e4%bd%93%e5%86%85%e7%94%a8defer aria-label=别在循环体内用defer>别在循环体内用defer</a></li><li><a href=#%e6%96%b9%e6%b3%95%e6%8e%a5%e6%94%b6%e8%80%85%e7%b1%bb%e5%9e%8bor%e5%85%b6%e6%8c%87%e9%92%88%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=方法接收者(类型or其指针)一致性>方法接收者(类型or其指针)一致性</a></li><li><a href=#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e4%bd%9c%e4%b8%ba%e5%8f%82%e6%95%b0 aria-label=引用类型作为参数>引用类型作为参数</a></li><li><a href=#%e5%86%85%e5%b5%8c aria-label=内嵌>内嵌</a></li><li><a href=#%e6%96%b9%e6%b3%95%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=方法表达式>方法表达式</a></li><li><a href=#bit%e6%95%b0%e7%bb%84%e6%9c%ac%e8%b4%a8%e4%b8%8a%e5%b0%b1%e6%98%af%e4%b8%80%e4%b8%aa%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5 aria-label=bit数组(本质上就是一个二维矩阵)>bit数组(本质上就是一个二维矩阵)</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e5%91%bd%e5%90%8d aria-label=接口命名>接口命名</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e4%bd%8d%e7%bd%ae aria-label=接口定义位置>接口定义位置</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e8%b5%8b%e5%80%bc%e6%8e%a5%e5%8f%a3 aria-label=接口赋值接口>接口赋值接口</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3 aria-label=实现接口>实现接口</a></li><li><a href=#%e7%bc%96%e8%af%91%e6%9c%9f%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5 aria-label=编译期类型检查>编译期类型检查</a></li><li><a href=#%e7%aa%81%e7%a0%b4golang%e7%9a%84%e5%af%bc%e5%87%ba%e9%99%90%e5%88%b6 aria-label=突破Golang的导出限制>突破Golang的导出限制</a></li><li><a href=#%e7%bc%96%e8%af%91%e5%99%a8%e6%8c%87%e4%bb%a4-goxxx aria-label="编译器指令: //go:xxx">编译器指令: //go:xxx</a></li><li><a href=#stringer--gogenerate aria-label="stringer + //go:generate">stringer + //go:generate</a></li><li><a href=#%e4%b8%a4%e4%b8%aa%e6%8e%a5%e5%8f%a3%e5%80%bc%e7%9a%84%e6%af%94%e8%be%83%e5%8f%af%e8%83%bd%e4%bc%9apanic aria-label=两个接口值的比较可能会panic>两个接口值的比较可能会panic</a></li><li><a href=#%e4%b8%80%e4%b8%aa%e5%8c%85%e5%90%abnil%e6%8c%87%e9%92%88%e7%9a%84%e6%8e%a5%e5%8f%a3%e4%b8%8d%e6%98%afnil%e6%8e%a5%e5%8f%a3 aria-label=一个包含nil指针的接口不是nil接口>一个包含nil指针的接口不是nil接口</a></li><li><a href=#%e9%80%9a%e8%bf%87%e6%96%ad%e8%a8%80%e8%af%a2%e9%97%ae%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e5%85%b7%e5%a4%87%e6%9f%90%e4%ba%9b%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e5%a4%96%e7%9a%84%e8%a1%8c%e4%b8%ba%e5%b9%b6%e4%bd%bf%e7%94%a8 aria-label='通过断言询问接口的"动态类型"是否具备某些接口定义外的行为并使用'>通过断言询问接口的"动态类型"是否具备某些接口定义外的行为并使用</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%8e%a5%e5%8f%a3 aria-label=关于接口>关于接口</a></li><li><a href=#fmtprintf--r-%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e8%be%93%e5%87%ba aria-label="fmt.Printf + \r 实现动态输出">fmt.Printf + \r 实现动态输出</a></li><li><a href=#channel%e7%94%b1%e7%94%9f%e4%ba%a7%e8%80%85%e5%85%b3%e9%97%ad aria-label=channel由生产者关闭>channel由生产者关闭</a></li><li><a href=#channel-%e4%b8%8e-for-range-select-case aria-label="channel 与 (for range, select case)">channel 与 (for range, select case)</a></li><li><a href=#select%e6%b0%b8%e8%bf%9c%e7%ad%89%e5%be%85 aria-label=select{}永远等待>select{}永远等待</a></li><li><a href=#select-%e4%b8%8e-timeafter aria-label="select 与 time.After">select 与 time.After</a></li><li><a href=#select%e7%9a%84%e4%b8%80%e4%b8%aa%e9%aa%9a%e6%93%8d%e4%bd%9c aria-label=select的一个骚操作>select的一个骚操作</a></li><li><a href=#%e8%bd%ae%e8%af%a2channel aria-label=轮询channel>轮询channel</a></li><li><a href=#timetick%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e9%a3%8e%e9%99%a9 aria-label=time.Tick(内存泄漏风险)>time.Tick(内存泄漏风险)</a></li><li><a href=#%e5%8d%95%e6%96%b9%e5%90%91channel aria-label=单方向channel>单方向channel</a></li><li><a href=#makechan-int-%e5%92%8c-makechan-int-1-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="make(chan int) 和 make(chan int, 1) 的区别">make(chan int) 和 make(chan int, 1) 的区别</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%adchannel%e5%85%b3%e9%97%ad aria-label=如何判断channel关闭>如何判断channel关闭</a></li><li><a href=#%e9%81%bf%e5%85%8d%e5%b0%86%e4%b8%80%e4%b8%aachannel%e7%94%a8%e5%9c%a8%e5%94%af%e4%b8%80%e4%b8%80%e4%b8%aagoroutine%e4%b8%ad aria-label=避免将一个channel用在唯一一个goroutine中>避免将一个channel用在唯一一个goroutine中</a></li><li><a href=#%e5%b8%a6%e7%bc%93%e5%ad%98channel%e7%9a%84%e7%ab%9e%e9%80%9f aria-label=带缓存channel的竞速>带缓存channel的竞速</a></li><li><a href=#pipeline%e4%b8%b2%e8%81%94channels aria-label=pipeline(串联channels)>pipeline(串联channels)</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e7%9a%84%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%bc%93%e5%ad%98 aria-label=并发的非阻塞缓存>并发的非阻塞缓存</a></li><li><a href=#context aria-label=context>context</a></li><li><a href=#context-1 aria-label=*context>*context</a></li><li><a href=#_test-%e6%b5%8b%e8%af%95package aria-label="*_test 测试package">*_test 测试package</a></li><li><a href=#%e5%88%ab%e5%86%99%e8%84%86%e5%bc%b1%e7%9a%84%e6%b5%8b%e8%af%95%e4%bb%a3%e7%a0%81 aria-label=别写脆弱的测试代码>别写脆弱的测试代码</a></li><li><a href=#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95 aria-label=表驱动测试>表驱动测试</a></li><li><a href=#go-test--go-tool-cover aria-label="go test + go tool cover">go test + go tool cover</a></li><li><a href=#go-test--%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 aria-label="go test + 性能分析">go test + 性能分析</a></li><li><a href=#benchmark%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95 aria-label=benchmark(基准测试)>benchmark(基准测试)</a></li><li><a href=#golang%e6%8c%87%e9%92%88%e8%bf%90%e7%ae%97 aria-label=golang指针运算>golang指针运算</a></li><li><a href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86%e4%b9%a0%e6%83%af aria-label=错误处理习惯>错误处理习惯</a></li><li><a href=#%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81recover aria-label=一行代码recover>一行代码recover</a></li><li><a href=#%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%bb%9f%e8%ae%a1%e5%87%bd%e6%95%b0%e8%80%97%e6%97%b6 aria-label=一行代码统计函数耗时>一行代码统计函数耗时</a></li><li><a href=#%e6%96%b9%e6%b3%95%e4%bc%98%e5%85%88%e4%bd%bf%e7%94%a8%e6%8c%87%e9%92%88%e6%8e%a5%e5%8f%97%e8%80%85 aria-label=方法优先使用指针接受者>方法优先使用指针接受者</a></li><li><a href=#%e6%96%b9%e6%b3%95%e9%93%be aria-label=方法链>方法链</a></li><li><a href=#%e5%87%bd%e6%95%b0%e9%93%be aria-label=函数链>函数链</a></li><li><a href=#%e6%95%b0%e5%ad%97%e5%88%86%e9%9a%94%e7%ac%a6_ aria-label=数字分隔符_>数字分隔符_</a></li><li><a href=#cryptorand--mathrand aria-label="crypto/rand > math/rand">crypto/rand > math/rand</a></li><li><a href=#-%e6%af%94%e8%be%83 aria-label="== 比较">== 比较</a></li><li><a href=#panic%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=panic的使用>panic的使用</a></li><li><a href=#%e5%b0%bd%e9%87%8f%e4%bf%9d%e7%95%99%e5%af%b9goroutine%e5%a3%b0%e6%98%8e%e5%91%a8%e6%9c%9f%e7%9a%84%e7%ae%a1%e7%90%86 aria-label=尽量保留对goroutine声明周期的管理>尽量保留对goroutine声明周期的管理</a></li><li><a href=#%e7%ae%80%e5%8d%95%e5%b9%b6%e5%8f%91%e5%9c%ba%e6%99%af%e4%bd%bf%e7%94%a8%e5%a5%bderrorgroup aria-label=简单并发场景使用好errorgroup>简单并发场景使用好errorgroup</a></li><li><a href=#%e5%b8%a6ctx%e7%9a%84sleep%e5%87%bd%e6%95%b0 aria-label=带ctx的Sleep函数>带ctx的Sleep函数</a></li><li><a href=#s-vs-q aria-label="%s vs %q">%s vs %q</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>有很多从其他大佬的总结中抄来的，不注明出处了</p><p>会记录一些:</p><ul><li>有意义的小操作(可能有些比较tricky)</li><li>容易理解偏差的点</li><li>日常开发低频使用的知识点</li></ul><hr><h2 id=golang代码执行顺序>golang代码执行顺序<a hidden class=anchor aria-hidden=true href=#golang代码执行顺序>#</a></h2><p>没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。</p><p>了解更多可查看Golang内存模型规范。</p><h2 id=golang内存对齐>golang内存对齐<a hidden class=anchor aria-hidden=true href=#golang内存对齐>#</a></h2><p>内存对齐：数据在内存中的存储位置必须是特定字节数的倍数</p><ul><li>CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问</li><li></li></ul><p>golang内存对齐：</p><ul><li>基础类型：通常是其自身大小（如int32为4字节，int64为8字节）</li><li>结构体<ul><li>每个字段按各自的对齐系数作对齐</li><li>结构体自身的对齐系数为所有字段中最大的对齐系数</li></ul></li><li>数组：与元素类型的对齐系数相同</li></ul><p>例：</p><pre tabindex=0><code>type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
    fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
</code></pre><p>demo1:</p><ul><li>a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节</li><li>b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节</li><li>c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可</li></ul><p>demo2:</p><ul><li>a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节</li><li>c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节</li><li>b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节</li><li>最终，demo2 的对齐倍数由 c 的对齐倍数决定，也是 4，因此，demo2还要占据 2 字节 ，内存占用为 12 字节</li></ul><p>demo3:</p><ul><li>a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节</li><li>c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节</li><li>b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节</li><li>d 是第四个字段，对齐倍数为 2，从第 10 个位置开始占据 2 字节</li></ul><p><strong>PS: 空 struct{} 的内存对齐</strong></p><p>空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。<strong>因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）</strong>：</p><pre tabindex=0><code>type demo3 struct {
	c int32
	a struct{}
}

type demo4 struct {
	a struct{}
	c int32
}

func main() {
	fmt.Println(unsafe.Sizeof(demo3{})) // 8
	fmt.Println(unsafe.Sizeof(demo4{})) // 4
}
</code></pre><p>所以，我们一般可以通过结构体字段<code>从大到小</code>顺序排列来节约内存</p><h2 id=internal包只导出到父目录>internal包只导出到父目录<a hidden class=anchor aria-hidden=true href=#internal包只导出到父目录>#</a></h2><p>internal包，只能被和internal目录有同一个父目录的包所导入，go语言层面没有这个限制，这是通过go命令实现的。
例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。</p><h2 id=变量交换>变量交换<a hidden class=anchor aria-hidden=true href=#变量交换>#</a></h2><p>go可以这样一行完成交换，官方Swap一般也都是这个写法</p><pre tabindex=0><code>i, j = j, i // 交换 i 和 j 的值
</code></pre><h2 id=for循环break>for循环break<a hidden class=anchor aria-hidden=true href=#for循环break>#</a></h2><p>for循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。</p><pre tabindex=0><code>for {
		select {
		case &lt;-sigChan:
			// exit for  
			break
		default:
		  // do something
		}
	}
</code></pre><p>以上break并不能退出for循环，可以使用标签或goto解决：</p><pre tabindex=0><code>// 1 标签
FOR:
	for {
		select {
		case &lt;-sigChan:
			// exit for  
			break FOR
		default:
		  // do something
		}
	}

------
// 2 goto
	for {
		select {
		case &lt;-sigChan:
			// exit for  
			goto ENDFOR
		default:
		  // do something
		}
	}
ENDFOR:

------
但请注意，goto一般由于影响可读性是禁用的
</code></pre><h2 id=读取stdin刷题别再踩坑了>读取stdin(刷题别再踩坑了)<a hidden class=anchor aria-hidden=true href=#读取stdin刷题别再踩坑了>#</a></h2><p>fmt包内 Scan系列 SScan系列 Fscan系列如下：</p><table><thead><tr><th>系列</th><th>无后缀</th><th>f后缀</th><th>ln后缀</th></tr></thead><tbody><tr><td>Scan系列</td><td>Scan()</td><td>Scanf()</td><td>Scanln</td></tr><tr><td>Sscan系列</td><td>Sscan()</td><td>Sscanf()</td><td>Sscanln()</td></tr><tr><td>Fscan系列</td><td>Fscan()</td><td>Fscanf()</td><td>Fscanln()</td></tr><tr><td></td><td>将换行符当空格处理</td><td>根据给定的format读取</td><td>遇到换行符停止</td></tr></tbody></table><p>他们的定义：</p><pre tabindex=0><code>func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)

func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)

func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
</code></pre><p>从定义可见，Scanln(其他同理)直接读取一行然后结束，但是从函数入参<code>...interface{}</code>就能知道，你需要明确的知道这一行空格会分隔出多少个你需要的值；可是平时做题最多的场景，一般是每一行有多少个值是个变量，需要先将一行按<code>string</code>读入，然后<code>strings.Fields()</code>直接获得一个<code>[]string</code>再慢慢处理。所以你应该这样做：</p><pre tabindex=0><code>// each line in stdin corresponding to a string in lines
lines := make([]string, 0, anExpectedCap)
scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
	line := scanner.Text()
	lines = append(lines, line)
}
</code></pre><p>PS: 命令行 <code>ctrl+d == EOF</code>，结束输入。</p><h2 id=函数参数>函数参数<a hidden class=anchor aria-hidden=true href=#函数参数>#</a></h2><p>函数参数别太多，必要时使用 <code>结构体</code> <code>...values</code> <code>WithOption</code> 来优化。</p><p><code>WithOption</code>模式:</p><ul><li>一个配置结构体，包含所有可选参数</li><li>多个以 With为前缀的函数（Option函数），每个函数负责设置一个或多个配置项</li><li>一个创建函数，接收这些Option函数作为参数，并应用这些配置</li></ul><p>举个例子：</p><pre tabindex=0><code>package main

import &#34;fmt&#34;

// Config 包含所有可选配置项
type Config struct {
	Timeout  int
	MaxRetry int
	LogLevel string
}

// Option 定义函数类型，用于修改配置
type Option func(*Config)

// WithTimeout 设置超时时间
func WithTimeout(timeout int) Option {
	return func(c *Config) {
		c.Timeout = timeout
	}
}

// WithMaxRetry 设置最大重试次数
func WithMaxRetry(maxRetry int) Option {
	return func(c *Config) {
		c.MaxRetry = maxRetry
	}
}

// WithLogLevel 设置日志级别
func WithLogLevel(level string) Option {
	return func(c *Config) {
		c.LogLevel = level
	}
}

// Client 客户端结构体
type Client struct {
	config Config
}

// NewClient 创建一个新的客户端，接收可选配置
func NewClient(options ...Option) *Client {
	// 设置默认配置
	config := Config{
		Timeout:  5,   // 默认超时 5 秒
		MaxRetry: 3,   // 默认重试 3 次
		LogLevel: &#34;info&#34;, // 默认日志级别 info
	}

	// 应用所有选项
	for _, opt := range options {
		opt(&amp;config)
	}

	return &amp;Client{config: config}
}

func main() {
	opts:=[]Option{
        WithTimeout(10),
		WithLogLevel(&#34;debug&#34;),
    }
	client := NewClient(opts...)
}
</code></pre><h2 id=初始化顺序>初始化顺序<a hidden class=anchor aria-hidden=true href=#初始化顺序>#</a></h2><p>任意文件可以有多个init函数用来做初始化工作。
Golang包初始化顺序为 全局变量>init函数。
全局变量初始化顺序由他们之间的依赖关系决定(所以全局变量、type等的声明可忽略顺序)，无依赖关系时按声明顺序执行。
init函数的初始化顺序按init()函数声明顺序执行。</p><pre tabindex=0><code>func init(){
    ...
}

func init(){
    ...
}

func main(){
    ...
}

// 复杂的初始化工作除了可以用init()函数解决外，还可以使用匿名函数，且在init函数之前执行
var ComplexTable [][]int = func()([][]int){
    ...
    ...
    ...
}()
</code></pre><p>看下匿名函数+init初始化混合的场景：</p><pre tabindex=0><code>package main

import (
	&#34;fmt&#34;
	&#34;time&#34;
)

func init(){
	fmt.Println(&#34;3&#34;)
}

func init(){
	fmt.Println(&#34;2&#34;)
}

func init(){
	fmt.Println(&#34;1&#34;)
}

var _ = func()bool{
	fmt.Println(&#34;var init&#34;)
	return true
}()

func main() {
	time.Sleep(time.Second)
}


------
output:

var init
3
2
1
</code></pre><p><strong>init()初始化和匿名变量初始化这一类的操作，应该尽量避免使用</strong></p><h2 id=指针--表达式>*指针 = 表达式<a hidden class=anchor aria-hidden=true href=#指针--表达式>#</a></h2><p>&ldquo;*指针 = 表达式&rdquo; 形式可以直接修改指针指向的变量的值：</p><pre tabindex=0><code>x := 1
p := &amp;x         // p, of type *int, points to x
fmt.Println(*p) // &#34;1&#34;
*p = 2          // equivalent to x = 2
fmt.Println(*p) // &#34;2&#34;
fmt.Println(x)  // &#34;2&#34;
</code></pre><h2 id=与>,与}<a hidden class=anchor aria-hidden=true href=#与>#</a></h2><p>使用逗号处理多item（函数参数，结构体成员等）时，结束的 )或} 可以跟在最后一行，也可以另起一行，当另起一行时，为避免编译器行尾自动补充分号导致编译错误，应在末尾的参数后显示插入逗号。</p><pre tabindex=0><code>func tt(a,b,c string)(){
    ...
}

tt(
    &#34;a&#34;,
    &#34;b&#34;,
    &#34;c&#34;,
)
==
tt(
    &#34;a&#34;,
    &#34;b&#34;,
    &#34;c&#34;)
    
------

type TT struct{
    A string
    B string
    C string
}

tt := TT{
    A: &#34;a&#34;,
    B: &#34;b&#34;,
    C: &#34;c&#34;,
}
==
tt := TT{
    A: &#34;a&#34;,
    B: &#34;b&#34;,
    C: &#34;c&#34;}
</code></pre><h2 id=返回值数量不固定>返回值数量不固定<a hidden class=anchor aria-hidden=true href=#返回值数量不固定>#</a></h2><p>以下场景，既可以返回两个值，也可以返回一个</p><ul><li>map查找</li><li>类型断言</li><li>通道接收</li></ul><pre tabindex=0><code>v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = &lt;-ch               // channel receive

v = m[key]                // map查找，失败时返回零值
v = x.(T)                 // type断言，失败时panic异常
v = &lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）
</code></pre><h2 id=中文名称不导出>中文名称不导出<a hidden class=anchor aria-hidden=true href=#中文名称不导出>#</a></h2><p>Golang支持中文变量和类型名，对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出。</p><pre tabindex=0><code>type 测试人员 struct {
	name string
	age  int
}

func main(){
    测试人员_某某某 := &amp;测试人员{&#34;test&#34;, 1}
    fmt.Printf(&#34;%v,%T,%+v\n&#34;, 测试人员_某某某, 测试人员_某某某, 测试人员_某某某)
    // 输出：&amp;{test 1},*main.测试人员,&amp;{name:test age:1}
}
</code></pre><h2 id=包注释写法>包注释写法<a hidden class=anchor aria-hidden=true href=#包注释写法>#</a></h2><p>一个包通常只有一个源文件有包注释，如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释；如果某个包注释很大，通常会放到一个独立的doc.go文件中。</p><h2 id=语法块>{}语法块<a hidden class=anchor aria-hidden=true href=#语法块>#</a></h2><p>{}包含的部分为一个句法块，可以显式的使用{}做作用域隔离：</p><pre tabindex=0><code>func main(){
    tmp := 10
    
    {
        tmp2 := 20
        fmt.Println(tmp, tmp2)
    }
    
    fmt.Println(tmp) // can not recognize tmp2 here
}
</code></pre><p>类似的，一组关联性比较高的变量，可以放在一起声明以使得可读性更高</p><pre tabindex=0><code>package main

import (
	&#34;fmt&#34;
)

func main() {
	var(
		a = 1
		b = 2
		c = 3
	)
	
	var(
		as = &#34;4&#34;
		bs = &#34;5&#34;
		cs = &#34;6&#34;
	)
	
	fmt.Println(a,b,c,as,bs,cs)
}
------
output:
1 2 3 4 5 6
</code></pre><h2 id=ifreturn-vs-ifelse>if+return vs if+else<a hidden class=anchor aria-hidden=true href=#ifreturn-vs-ifelse>#</a></h2><p>Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进：</p><pre tabindex=0><code>// right
res,err := doSomething()
if err != nil{
    printErr(err)
    return
}
res.DoSomething()

// wrong
res,err := doSomething()
if err != nil{
    printErr(err)
} else {
    // res.DoSomething() 应该在主执行逻辑中，不建议缩进
    res.DoSomething()
}
</code></pre><h2 id=格式化输出的n副词>格式化输出的[n]副词<a hidden class=anchor aria-hidden=true href=#格式化输出的n副词>#</a></h2><p>fmt包Printf函数格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后添加[n]副词告诉Printf函数再次使用第n个操作数。</p><pre tabindex=0><code>fmt.Printf(&#34;%d, %d\n&#34;, 1, 2)    // 1, 2
fmt.Printf(&#34;%d, %[1]d\n&#34;, 1)    // 1, 1
</code></pre><h2 id=二进制>二进制<a hidden class=anchor aria-hidden=true href=#二进制>#</a></h2><pre tabindex=0><code>fmt.Println(strconv.FormatInt(int64(123), 2))   // &#34;1111011&#34;
fmt.Printf(&#34;%b&#34;, 123)                           // &#34;1111011&#34;
</code></pre><h2 id=deprecated---没必要不清晰-创建slice简洁版>(deprecated - 没必要，不清晰) 创建slice简洁版<a hidden class=anchor aria-hidden=true href=#deprecated---没必要不清晰-创建slice简洁版>#</a></h2><p>创建长度和容量都是100的string slice的简洁方法：</p><pre tabindex=0><code>// 正常
testSlice := make([]string, 100, 100)
// 简洁版
testSlice := []string{99: &#34;&#34;}
</code></pre><h2 id=slice切割>slice切割<a hidden class=anchor aria-hidden=true href=#slice切割>#</a></h2><p>当使用[:]切割int数组创建slice时，slice底层数组共用原数组，新slice的cap为切割起始位置至原数组末尾；因此，修改切割后的slice内元素时，将同时修改原数组，且修改slice的len以外cap以内的值时，也同时能够修改原数组：</p><pre tabindex=0><code>testArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
cutTestArray := testArray[5:9]
fmt.Println(cutTestArray, len(cutTestArray), cap(cutTestArray)) // [5 6 7 8] 4 7

cutTestArray[0] = 50
fmt.Println(cutTestArray, testArray) // [50 6 7 8] [0 1 2 3 4 50 6 7 8 9 10 11]


cutTestArray = append(cutTestArray, 90)
fmt.Println(cutTestArray, testArray) // [50 6 7 8 90] [0 1 2 3 4 50 6 7 8 90 10 11]
</code></pre><p>使用[:]切割字符串时，获得一个字符串且发生一次拷贝：</p><pre tabindex=0><code>testStr := &#34;hello world&#34;
cutTestStr := testStr[6:]
fmt.Println(testStr, &amp;testStr, cutTestStr, &amp;cutTestStr) // hello world 0xc000010240 world 0xc000010250
</code></pre><h2 id=-in-golang>&mldr; in Golang<a hidden class=anchor aria-hidden=true href=#-in-golang>#</a></h2><p>Golang &mldr;(3 dots) 用法:
参考 <a href=https://www.bookstack.cn/read/golang_development_notes/zh-9.14.md>3 dots in Go</a></p><h2 id=slice操作考虑内存>slice操作考虑内存<a hidden class=anchor aria-hidden=true href=#slice操作考虑内存>#</a></h2><p>给定一个string slice，去除其中"&ldquo;项：</p><pre tabindex=0><code>// 你可能想这么写：
func filterEmptyStr(input []string) []string {
	ret := make([]string, 0)

	for _, item := range input {
		if item != &#34;&#34; {
			ret = append(ret, item)
		}
	}

	return ret
}
// 再想想，为了避免发生扩容拷贝，你可能会这么写：
func filterEmptyStr(input []string) []string {
	ret := make([]string, 0, len(input))

	for _, item := range input {
		if item != &#34;&#34; {
			ret = append(ret, item)
		}
	}

	return ret
}
// 其实，可以共用底层数据结构，这么写（问题是，输入的[]string被修改了）：
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != &#34;&#34; {
            strings[i] = s
            i++
        }
    }
    return strings[:i]
}
// 再思考下，共用底层结构也可以这么写(太tricky，上一个更直观)：
func nonempty2(strings []string) []string {
    out := strings[:0] // zero-length slice of original
    for _, s := range strings {
        if s != &#34;&#34; {
            out = append(out, s)
        }
    }
    return out
}
</code></pre><h2 id=golang没有set类型>golang没有set类型<a hidden class=anchor aria-hidden=true href=#golang没有set类型>#</a></h2><p>Go语言中没有提供set类型，一般用map实现类似set的功能。一般习惯是使用map[key]bool创建set，但是在高性能场景下，考虑到bool占一字节，可以使用map[key]struct{}, struct{}大小为0</p><h2 id=构造struct建议声明字段名>构造struct建议声明字段名<a hidden class=anchor aria-hidden=true href=#构造struct建议声明字段名>#</a></h2><p>明确写好字段，更清晰直观</p><pre tabindex=0><code>type Point struct{ X, Y int }

p := Point{1, 2}

// 建议：
p := Point{
    X: 1,
    Y: 2,
}
</code></pre><h2 id=jsonmarshalindent>json.MarshalIndent<a hidden class=anchor aria-hidden=true href=#jsonmarshalindent>#</a></h2><p>json.MarshalIndent函数将产生整齐缩进的输出，该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p><pre tabindex=0><code>type JsonTest struct {
	Item1 string
	Item2 string
}

jt1 := JsonTest{&#34;item1&#34;, &#34;item2&#34;}
msg, _ := json.Marshal(jt1)
msgIndent, _ := json.MarshalIndent(jt1, &#34;&#34;, &#34;    &#34;)
fmt.Println(string(msg))
fmt.Println(string(msgIndent))

------
output:

{&#34;Item1&#34;:&#34;item1&#34;,&#34;Item2&#34;:&#34;item2&#34;}
{
    &#34;Item1&#34;: &#34;item1&#34;,
    &#34;Item2&#34;: &#34;item2&#34;
}
</code></pre><h2 id=函数值使用前先判空>&ldquo;函数值"使用前先判空<a hidden class=anchor aria-hidden=true href=#函数值使用前先判空>#</a></h2><p>当使用“函数值”作为函数参数时，函数内部调用传入的函数值时记得先判空，函数值零值为nil，直接调用nil的函数值会引发panic。</p><p>扩展来看，引用类型，能够与<code>nil</code>做<code>==</code>判断的，使用前都应该判空。</p><h2 id=deprecated---go新特性捕获迭代变量>(deprecated - go新特性)捕获迭代变量<a hidden class=anchor aria-hidden=true href=#deprecated---go新特性捕获迭代变量>#</a></h2><p>for循环(尤其需要在for循环内开goroutine)时，使用循环变量之前需要先将循环变量赋值给循环体内的一个局部变量，如下例。</p><p>问题的原因在于循环变量的作用域。在下面的例子中，for循环语句引入了新的词法块，循环变量name&amp;age在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以name为例，后续的迭代会不断更新name的值，当最终printer操作执行时，for循环已完成，name中存储的值等于最后一次迭代的值。这意味着，每次printer的调用输出的都是相同的最后那一个名字。</p><p>为了解决这个问题，可以<strong>引入一个与循环变量同名的局部变量，作为循环变量的副本</strong>。</p><pre tabindex=0><code>// wrong, output: 
/*
Pike 13
Pike 13
*/

var printers []func()

name2Age := map[string]string{&#34;Rob&#34;: &#34;12&#34;, &#34;Pike&#34;: &#34;13&#34;}
for name, age := range name2Age {
	printers = append(printers, func() { fmt.Println(name, age) })
}

for _, printer := range printers {
	printer()
}
------
// right, output:
/*
Rob 12
Pike 13
*/

var printers []func()

name2Age := map[string]string{&#34;Rob&#34;: &#34;12&#34;, &#34;Pike&#34;: &#34;13&#34;}
for name, age := range name2Age {
	name := name
	age := age
	printers = append(printers, func() { fmt.Println(name, age) })
}

for _, printer := range printers {
	printer()
}

------
// 下面两个例子的输出是一致的，因为fmt.Println()在每次循环内部即时调用

// 1
name2Age := map[string]string{&#34;Rob&#34;: &#34;12&#34;, &#34;Pike&#34;: &#34;13&#34;}
for name, age := range name2Age {
	fmt.Println(name, age)
}
// 2
name2Age := map[string]string{&#34;Rob&#34;: &#34;12&#34;, &#34;Pike&#34;: &#34;13&#34;}
for name, age := range name2Age {
	name := name
	age := age
	fmt.Println(name, age)
}
</code></pre><h2 id=defer>defer<a hidden class=anchor aria-hidden=true href=#defer>#</a></h2><p>被延迟执行的匿名函数可以修改函数返回给调用者的返回值：</p><pre tabindex=0><code>func add(x int) (result int) {
    defer func() { result += x }()
    return x + x
}
fmt.Println(add(4)) // &#34;12&#34;

// 如果是参数那么将无法成功修改返回值:
func add(x int) (result int) {
    defer func(result int) { result += x }(result)
    return x + x
}
fmt.Println(add(4)) // &#34;8&#34;
</code></pre><p>这里首先必须显示声明了返回值，以下方法不能成功修改返回值：</p><pre tabindex=0><code>func add(x int) int {
    result := x + x
    defer func() { result += x }()
    return result
}
fmt.Println(add(4)) // &#34;8&#34;
</code></pre><p>这是为什么呢？看下面例子，显示声明的返回值，defer中直接修改时，其实修改的是同一个地址，所以能够成功修改返回值。但是在上面的例子中，defer修改的仅仅是函数内的局部变量，而函数在return时将该局部变量拷贝到了调用栈的返回值中，所以defer修改局部变量成功，但是并不会体现在返回值上。</p><p>上面的例子能说明defer的执行时机是返回值返回给调用者之后吗？
不能，其实defer的执行时机是<strong>return之后，且返回值返回给调用方之前</strong>，看下面的例子，也正是因为defer执行在返回值真正返回给调用方之前，所以才能成功修改返回值。</p><pre tabindex=0><code>func add(x int) (result int) {
    fmt.Println(&#34;addr of result in add: &#34;, &amp;result)
    
    defer func() { 
      fmt.Println(&#34;addr of result in defer: &#34;, &amp;result)
      result += x 
    }()
      
    return x + x
}
fmt.Println(add(4)) // &#34;12&#34;
------
output:

addr of result in add:  0xc00009e018
addr of result in defer:  0xc00009e018
12
</code></pre><p>为了证明 “<strong>defer执行在return之后，且返回值返回给调用方之前</strong>”，可以看下面的例子，可以看到调用方获得返回值紧跟defer完成以后。 <strong>因此啊，defer里面逻辑写不好，也会严重影响性能啊，如果是一些可并发的逻辑，可以defer里开新的goroutine去搞</strong>。</p><pre tabindex=0><code>func add(x int) (result int) {
		defer func() {
		fmt.Println(&#34;defer start &#34;, time.Now())
		time.Sleep(time.Second)

		result += x
		fmt.Println(time.Now(), &#34;result value in defer: &#34;, result)

		time.Sleep(10 * time.Second)

		fmt.Println(&#34;defer end &#34;, time.Now())
	}()

	return x + x
}

x := add(4)
fmt.Println(&#34;caller time: &#34;, time.Now(), &#34;caller got: &#34;, x)
------
output:

defer start  2021-07-23 15:19:35.264078 +0800 CST m=+0.000999863
2021-07-23 15:19:36.265726 +0800 CST m=+1.002653773 result value in defer:  12
defer end  2021-07-23 15:19:46.270896 +0800 CST m=+11.007876743
caller time:  2021-07-23 15:19:46.270939 +0800 CST m=+11.007920326 caller got:  12
</code></pre><h2 id=别在循环体内用defer>别在循环体内用defer<a hidden class=anchor aria-hidden=true href=#别在循环体内用defer>#</a></h2><p>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭：</p><pre tabindex=0><code>for _, filename := range filenames {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // NOTE: risky; could run out of file descriptors
    // ...process f…
}
</code></pre><h2 id=方法接收者类型or其指针一致性>方法接收者(类型or其指针)一致性<a hidden class=anchor aria-hidden=true href=#方法接收者类型or其指针一致性>#</a></h2><p>如果某个struct有一个指针作为接收器的方法，那么该struct的所有方法都必须有一个指针接收器，即使并不需要。
换句话说，一个struct T，他的方法集要么都是<code>func(t *T)DoSomething(){}</code>，要么都是<code>func (t T)DoSomething(){}</code>。
Why？一致性吧。。。</p><h2 id=引用类型作为参数>引用类型作为参数<a hidden class=anchor aria-hidden=true href=#引用类型作为参数>#</a></h2><p>函数参数是引用类型时，虽然仍可修改相同的底层数据，但是引用本身却是一份拷贝，当函数内修改引用本身时不会影响原值（比如赋值nil，或将引用指向其他对象）。
方法表达式中，接收者是表达式函数的第一个参数，所以该说明同样适用于方法；类型方法其接收者是类型的拷贝，类型指针方法其接收者是拷贝出的一份指向该类型的指针。</p><pre tabindex=0><code>func clearMap(input map[string]bool) {
	input = nil
}

func main() {
	tm := map[string]bool{&#34;test&#34;: true, &#34;test1&#34;: true}
	fmt.Println(tm)
	clearMap(tm)
	fmt.Println(tm)
}

------
output:

map[test:true test1:true]
map[test:true test1:true]
</code></pre><h2 id=内嵌>内嵌<a hidden class=anchor aria-hidden=true href=#内嵌>#</a></h2><p>内嵌：一个 结构体/接口 直接包含另一个 结构体/接口 的成员</p><p>Golang方法的接收者只能是命名类型或者其指针，但是由于内嵌这一特性，匿名struct也有手段可以拥有方法：</p><pre tabindex=0><code>// 两个包级别变量实现缓存
var (
    mu sync.Mutex // guards mapping
    mapping = make(map[string]string)
)

func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}

------
// 匿名struct存储在变量cache中，并且具备其内嵌struct Mutex的所有方法
var cache = struct {
    sync.Mutex
    mapping map[string]string
}{
    mapping: make(map[string]string),
}


func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}
</code></pre><h2 id=方法表达式>方法表达式<a hidden class=anchor aria-hidden=true href=#方法表达式>#</a></h2><p>PS: 一般适合函数声明一致的一系列方法，再次封装后用参数指定操作方法</p><p>当你根据一个变量来决定调用同一个类型的哪个函数时，可以根据选择来调用接收器各不相同的方法：</p><pre tabindex=0><code>type Point struct{ X, Y float64 }

func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
</code></pre><h2 id=bit数组本质上就是一个二维矩阵>bit数组(本质上就是一个二维矩阵)<a hidden class=anchor aria-hidden=true href=#bit数组本质上就是一个二维矩阵>#</a></h2><p>Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。(再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组)。
一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i：</p><pre tabindex=0><code>// An IntSet is a set of small non-negative integers.
// Its zero value represents the empty set.
type IntSet struct {
    words []uint64
}

// Has reports whether the set contains the non-negative value x.
func (s *IntSet) Has(x int) bool {
    word, bit := x/64, uint(x%64)
    return word &lt; len(s.words) &amp;&amp; s.words[word]&amp;(1&lt;&lt;bit) != 0
}

// Add adds the non-negative value x to the set.
func (s *IntSet) Add(x int) {
    word, bit := x/64, uint(x%64)
    for word &gt;= len(s.words) {
        s.words = append(s.words, 0)
    }
    s.words[word] |= 1 &lt;&lt; bit
}

// UnionWith sets s to the union of s and t.
func (s *IntSet) UnionWith(t *IntSet) {
    for i, tword := range t.words {
        if i &lt; len(s.words) {
            s.words[i] |= tword
        } else {
            s.words = append(s.words, tword)
        }
    }
}

// String returns the set as a string of the form &#34;{1 2 3}&#34;.
func (s *IntSet) String() string {
    var buf bytes.Buffer
    buf.WriteByte(&#39;{&#39;)
    for i, word := range s.words {
        if word == 0 {
            continue
        }
        for j := 0; j &lt; 64; j++ {
            if word&amp;(1&lt;&lt;uint(j)) != 0 {
                if buf.Len() &gt; len(&#34;{&#34;) {
                    buf.WriteByte(&#39; &#39;)
                }
                fmt.Fprintf(&amp;buf, &#34;%d&#34;, 64*i+j)
            }
        }
    }
    buf.WriteByte(&#39;}&#39;)
    return buf.String()
}
</code></pre><h2 id=接口命名>接口命名<a hidden class=anchor aria-hidden=true href=#接口命名>#</a></h2><p>Golang接口命名一般"er"结尾，例如：Loser。
er的含义一般都是什么什么人，是一个类，而这个类一般有一些典型的行为，例如程序员，Coder:</p><pre tabindex=0><code>type Coder interface {
    WriteBug()
    SloveBug()
}
</code></pre><p>如果是组合的接口，一般这样：</p><pre tabindex=0><code>// 和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法
type ReadWriter interface {
    Reader
    Writer
}
</code></pre><h2 id=接口定义位置>接口定义位置<a hidden class=anchor aria-hidden=true href=#接口定义位置>#</a></h2><p>一般认为接口应该在使用者处定义，而不是提供者处定义</p><h2 id=接口赋值接口>接口赋值接口<a hidden class=anchor aria-hidden=true href=#接口赋值接口>#</a></h2><pre tabindex=0><code>var w io.Writer
var rwc io.ReadWriteCloser

w = rwc                 // OK: io.ReadWriteCloser has Write method
rwc = w                 // compile error: io.Writer lacks Close method
</code></pre><h2 id=实现接口>实现接口<a hidden class=anchor aria-hidden=true href=#实现接口>#</a></h2><p>若某类型指针接收者的方法实现了接口，那么该类型的指针实现了接口，但是该类型变量并没有：</p><pre tabindex=0><code>type InterfaceTest interface {
	Read(string)
	Write() string
}

type interfaceTestImpl struct {
	Name string
}

func (i *interfaceTestImpl) Read(name string) {
	i.Name = name
}

func (i *interfaceTestImpl) Write() string {
	return i.Name
}

var it InterfaceTest
iti := interfaceTestImpl{&#34;name&#34;}
it = iti    // Cannot use &#39;iti&#39; (type interfaceTestImpl) as type testpac.InterfaceTest Type does not implement &#39;testpac.InterfaceTest&#39; as &#39;Read&#39; method has a pointer receiver
it = &amp;iti   // ok
</code></pre><h2 id=编译期类型检查>编译期类型检查<a hidden class=anchor aria-hidden=true href=#编译期类型检查>#</a></h2><p>匿名变量实现编码期(编译)检查接口的实现等其他类型检查</p><pre tabindex=0><code>// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)
</code></pre><h2 id=突破golang的导出限制>突破Golang的导出限制<a hidden class=anchor aria-hidden=true href=#突破golang的导出限制>#</a></h2><p>time.Sleep经常使用，但是点进去会发现他没有函数体：</p><pre tabindex=0><code>func Sleet(d Duration)
</code></pre><p>那么是在哪里实现的呢？</p><p>runtime包有如下一段：</p><pre tabindex=0><code>//go:linkname timeSleep time.Sleep
func timeSleep(ns int64) {
	if ns &lt;= 0 {
		return
	}
	t := getg().timer
	if t == nil {
		t = new(timer)
		getg().timer = t
	}
    ......
}
</code></pre><p>runtime中的<code>go:linkname</code>把runtime的timeSleep与time.Sleep绑定在了一起</p><pre tabindex=0><code>//go:linkname localname importpath.name
</code></pre><p>这样做的好处是，timeSleep在runtime包内可以访问runtime内部，相当于runtime主动放出了一个叛徒给time包，帮助time包实现了time.Sleep函数</p><hr><p>访问其他包struct的私有字段？reflect的FieldByName可以支持访问，但不能修改；还想修改？那么可以使用unsafe包借助指针+偏移来实现读写</p><h2 id=编译器指令-goxxx>编译器指令: //go:xxx<a hidden class=anchor aria-hidden=true href=#编译器指令-goxxx>#</a></h2><p>上面我们使用过 <code>//go:linkname</code>了，那么<code>//go:xxx</code>这个注释到底是个啥呢？其实这是一系列编译器指令。</p><ul><li>为了将它们与非指令注释区分开来，指令在注释开头和指令名称之间不需要空格</li><li>由于它们是注释，因此不了解指令约定或特定指令的工具可以像其他注释一样跳过指令</li></ul><p>现在有的指令：</p><ul><li>//go:build xxx: 指定文件在xxx条件下会被编译</li></ul><pre tabindex=0><code>//go:build linux &amp;&amp; amd64
// 仅在 Linux 系统且 amd64 架构下编译此文件

package main

import &#34;fmt&#34;

func main() {
    fmt.Println(&#34;Running on Linux amd64&#34;)
}
</code></pre><ul><li>//go:generate xxx: 在编译前自动生成代码，需通过<code>go generate</code>命令触发(不会被<code>go build</code>自动执行)</li></ul><pre tabindex=0><code>//go:generate echo &#34;generate test&#34;
package main
func main(){}

执行go generate可输出 generate test

pb桩代码就是//go:generate protoc ***生成的
</code></pre><ul><li>//go:noinline : 告诉编译器不要对该函数进行内联优化</li><li>//go:inline : 提示编译器尽可能对该函数进行内联</li><li>//go:nosplit : 告诉编译器该函数不会触发栈分裂，即函数执行期间不会动态扩容栈空间</li><li>//go:linkname localname [importpath.name] :</li></ul><h2 id=stringer--gogenerate>stringer + //go:generate<a hidden class=anchor aria-hidden=true href=#stringer--gogenerate>#</a></h2><p><code>go install golang.org/x/tools/cmd/stringer@latest</code> 安装stringer工具</p><pre tabindex=0><code>//go:generate stringer -type=TT
package main

import (
    &#34;fmt&#34;
)

type TT int

const(
    TT1 TT = iota + 1
    TT2
    TT3
)

func main() {
    fmt.Println(TT1)
    fmt.Println(TT2)
    fmt.Println(TT3)
}
</code></pre><p>执行<code>go generate</code>，同目录下会出现<code>tt_string.go</code>:</p><pre tabindex=0><code>// Code generated by &#34;stringer -type=TT&#34;; DO NOT EDIT.

package main

import &#34;strconv&#34;

func _() {
	// An &#34;invalid array index&#34; compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TT1-1]
	_ = x[TT2-2]
	_ = x[TT3-3]
}

const _TT_name = &#34;TT1TT2TT3&#34;

var _TT_index = [...]uint8{0, 3, 6, 9}

func (i TT) String() string {
	i -= 1
	if i &lt; 0 || i &gt;= TT(len(_TT_index)-1) {
		return &#34;TT(&#34; + strconv.FormatInt(int64(i+1), 10) + &#34;)&#34;
	}
	return _TT_name[_TT_index[i]:_TT_index[i+1]]
}
</code></pre><p>再执行<code>go run ./*.go</code>会得到（而不是 1 2 3）：</p><pre tabindex=0><code>TT1
TT2
TT3
</code></pre><h2 id=两个接口值的比较可能会panic>两个接口值的比较可能会panic<a hidden class=anchor aria-hidden=true href=#两个接口值的比较可能会panic>#</a></h2><p>接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。
<strong>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic</strong>:</p><pre tabindex=0><code>var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
</code></pre><p><strong>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较非常确定它们的动态值是可比较类型的接口值。</strong></p><h2 id=一个包含nil指针的接口不是nil接口>一个包含nil指针的接口不是nil接口<a hidden class=anchor aria-hidden=true href=#一个包含nil指针的接口不是nil接口>#</a></h2><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。
例：</p><pre tabindex=0><code>const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.
func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte(&#34;done!\n&#34;))
    }
}
</code></pre><p>当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p><pre tabindex=0><code>if out != nil {
    out.Write([]byte(&#34;done!\n&#34;)) // panic: nil pointer dereference
}
</code></pre><p>当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true。
动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者，但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。]</p><p>问题在于<strong>尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求</strong>。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p><pre tabindex=0><code>var buf io.Writer
if debug {
    buf = new(bytes.Buffer) // enable collection of output
}
f(buf) // OK
</code></pre><h2 id=通过断言询问接口的动态类型是否具备某些接口定义外的行为并使用>通过断言询问接口的"动态类型"是否具备某些接口定义外的行为并使用<a hidden class=anchor aria-hidden=true href=#通过断言询问接口的动态类型是否具备某些接口定义外的行为并使用>#</a></h2><p>看例子：</p><pre tabindex=0><code>func writeHeader(w io.Writer, contentType string) error {
    if _, err := w.Write([]byte(&#34;Content-Type: &#34;)); err != nil {
        return err
    }
    if _, err := w.Write([]byte(contentType)); err != nil {
        return err
    }
    // ...
}
</code></pre><p><code>io.Writer</code>接口有方法<code>func Write([]byte)(int, error)</code>，但是这里做<code>[]byte(string)</code>的类型转换会引入开销：分配内存并拷贝。新分配的这块空间除了向<code>io.Writer</code>内写入就没有其他作用了，那么如果是在高并发场景这个操作可能会成为性能瓶颈，如何优化呢？</p><p><code>io.Writer</code>接口告诉我们关于<code>w</code>持有的具体类型的唯一东西：就是可以向它写入字节切片。查看net/http包源码，可以看到在这个程序中的<code>w</code>变量持有的动态类型也有一个允许字符串高效写入的<code>WriteString</code>方法(许多满足<code>io.Writer</code>接口的重要类型都有<code>WriteString</code>方法，包括<code>*bytes.Buffer</code>，<code>*os.File</code>和<code>*bufio.Writer</code>)。如何使用<code>WriteString</code>方法避免<code>[]byte(string)</code>类型转换的拷贝呢：</p><pre tabindex=0><code>// writeString writes s to w.
// If w has a WriteString method, it is invoked instead of w.Write.
func writeString(w io.Writer, s string) (n int, err error) {
    type stringWriter interface {
        WriteString(string) (n int, err error)
    }
    if sw, ok := w.(stringWriter); ok {
        return sw.WriteString(s) // avoid a copy
    }
    return w.Write([]byte(s)) // allocate temporary copy
}

func writeHeader(w io.Writer, contentType string) error {
    if _, err := writeString(w, &#34;Content-Type: &#34;); err != nil {
        return err
    }
    if _, err := writeString(w, contentType); err != nil {
        return err
    }
    // ...
}
</code></pre><h2 id=关于接口>关于接口<a hidden class=anchor aria-hidden=true href=#关于接口>#</a></h2><p>当设计一个新的包时，somebody总是习惯先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗，并且代码可读性大大降低。可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。<strong>接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要</strong>。</p><p><strong>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中</strong>。这种情况下，一个接口是解耦这两个包的一个好方式。</p><p>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</p><h2 id=fmtprintf--r-实现动态输出>fmt.Printf + \r 实现动态输出<a hidden class=anchor aria-hidden=true href=#fmtprintf--r-实现动态输出>#</a></h2><p>\r == 返回行首，覆盖之前的文字，可以实现动态滚动输出</p><pre tabindex=0><code>for _, r := range `-\|/` {
    fmt.Printf(&#34;\r%c&#34;, r)
    time.Sleep(100 * time.Millisecond)
}

------
output: -转圈圈
</code></pre><h2 id=channel由生产者关闭>channel由生产者关闭<a hidden class=anchor aria-hidden=true href=#channel由生产者关闭>#</a></h2><p>因为向关闭的channel写入会引发panic，channel的close应该有写入方执行</p><h2 id=channel-与-for-range-select-case>channel 与 (for range, select case)<a hidden class=anchor aria-hidden=true href=#channel-与-for-range-select-case>#</a></h2><p>无论是有缓存还是无缓存，可以<code>for range</code>持续从channel获取值：</p><pre tabindex=0><code>for i := range someChan {
	println(i)
}
</code></pre><p>对于无缓存channel, for range读取后且channel关闭，则循环结束。
对于有缓存channel, 即使channel关闭，for range也会继续读取直到读取完毕。
总结：for range监听channel，结束条件为 channel关闭且channel内容读取完毕。</p><p>select和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身或者包含在一个简短的变量声明中:</p><pre tabindex=0><code>select {
case &lt;-ch1:
    // ...
case x := &lt;-ch2:
    // ...use x...
case ch3 &lt;- y:
    // ...
default:
    // ...
}
</code></pre><p><strong>select特性</strong>：</p><ul><li>如果某个case代码块准备好发送或接收，执行对应内容</li><li>如果多个(>1)case代码块准备好发送或接收，随机选取一个并执行对应内容</li><li>如果所有case代码块都没有准备好<ul><li>无default，等待</li><li>有default，执行default</li></ul></li></ul><h2 id=select永远等待>select{}永远等待<a hidden class=anchor aria-hidden=true href=#select永远等待>#</a></h2><p>一个没有任何case的select语句写作select{}，会永远地等待下去。</p><h2 id=select-与-timeafter>select 与 time.After<a hidden class=anchor aria-hidden=true href=#select-与-timeafter>#</a></h2><p>time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句包含了一个超时保护：</p><pre tabindex=0><code>select {
case &lt;-time.After(10 * time.Second):
    // 超时时间10s，若超时什么都不做，退出select
case &lt;-aSigChan:
    doSomething()
}
...
</code></pre><h2 id=select的一个骚操作>select的一个骚操作<a hidden class=anchor aria-hidden=true href=#select的一个骚操作>#</a></h2><pre tabindex=0><code>ch := make(chan int, 1)
for i := 0; i &lt; 10; i++ {
    select {
    case x := &lt;-ch:
        fmt.Println(x) // &#34;0&#34; &#34;2&#34; &#34;4&#34; &#34;6&#34; &#34;8&#34;
    case ch &lt;- i:
    }
}
</code></pre><h2 id=轮询channel>轮询channel<a hidden class=anchor aria-hidden=true href=#轮询channel>#</a></h2><p>下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作就是“轮询channel”</p><pre tabindex=0><code>select {
case &lt;-abort:
    fmt.Printf(&#34;Launch aborted!\n&#34;)
    return
default:
    // do nothing
}
</code></pre><h2 id=timetick内存泄漏风险>time.Tick(内存泄漏风险)<a hidden class=anchor aria-hidden=true href=#timetick内存泄漏风险>#</a></h2><p>time.Tick通常用作定时器：</p><pre tabindex=0><code>func main() {
	tick := time.Tick(time.Second)
	for {
		&lt;-tick
		fmt.Println(&#34;hello&#34;)
	}
}
</code></pre><p>以上例子每秒输出一个hello，但是time.Tick如果像下面这样使用：</p><pre tabindex=0><code>tick := time.Tick(time.Second)

select {
case &lt;-tick:
    // do something
case &lt;-aChanSig:
    // do something
}
</code></pre><p>当select逻辑执行完毕后，tick的goroutine仍然存活着，周期性的尝试向tick中发送值，导致goroutine泄露。
<strong>只有当程序整个生命周期都需要时才适合使用time.Tick</strong>。否则的话，可以这样用：</p><pre tabindex=0><code>ticker := time.NewTicker(1 * time.Second)
&lt;-ticker.C    // receive from the ticker&#39;s channel
ticker.Stop() // cause the ticker&#39;s goroutine to terminate
</code></pre><h2 id=单方向channel>单方向channel<a hidden class=anchor aria-hidden=true href=#单方向channel>#</a></h2><p>例如：</p><ul><li>chan&lt;- int:只发送</li><li>&lt;-chan int:只接收</li></ul><p>通常一个函数参数的channel，参数输入(in)是一个只接受的channel，结果输出(out)是一个只发送的channel：</p><pre tabindex=0><code>func doSomeCalc(in &lt;-chan int, out chan&lt;- int){
    for input := range in{
        out &lt;- calc(input)
    }
}
</code></pre><p>对一个只接收的channel调用close是一个编译错误。</p><h2 id=makechan-int-和-makechan-int-1-的区别>make(chan int) 和 make(chan int, 1) 的区别<a hidden class=anchor aria-hidden=true href=#makechan-int-和-makechan-int-1-的区别>#</a></h2><p><code>test := make(chan int)</code>无缓存，无接收时，<code>test &lt;- 1</code>阻塞。
<code>test := make(chan int, 1)</code>带缓存，容量1，无接收时，<code>test &lt;- 1</code>不阻塞。</p><h2 id=如何判断channel关闭>如何判断channel关闭<a hidden class=anchor aria-hidden=true href=#如何判断channel关闭>#</a></h2><pre tabindex=0><code>a := make(chan int)

// a没有关闭，以下语句会阻塞，直到a有值输入，intV==值，ok==true
intV, ok := &lt;-a

------

a := make(chan int)
close(a)

// a关闭，以下语句不会阻塞，intV==0(int零值)，ok==false
intV, ok := &lt;-a
</code></pre><h2 id=避免将一个channel用在唯一一个goroutine中>避免将一个channel用在唯一一个goroutine中<a hidden class=anchor aria-hidden=true href=#避免将一个channel用在唯一一个goroutine中>#</a></h2><p>无缓存channel当然不能只在同一个goroutine使用，这必然会导致该goroutine阻塞。
有缓存的channel可以用在一个goroutine中，可以作队列用，但是不建议这样使用。</p><h2 id=带缓存channel的竞速>带缓存channel的竞速<a hidden class=anchor aria-hidden=true href=#带缓存channel的竞速>#</a></h2><p>下面例子并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。</p><pre tabindex=0><code>func mirroredQuery() string {
    responses := make(chan string, 3)
    go func() { responses &lt;- request(&#34;asia.gopl.io&#34;) }()
    go func() { responses &lt;- request(&#34;europe.gopl.io&#34;) }()
    go func() { responses &lt;- request(&#34;americas.gopl.io&#34;) }()
    return &lt;-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }
</code></pre><p>上面的竞速和下面有什么区别呢？下面的竞速使用了无缓存的channel，两个比较慢的goroutine将因为channel无人接收而永远卡住，并且不会被自动回收，从而导致goroutine泄漏。</p><pre tabindex=0><code>func mirroredQuery() string {
    responses := make(chan string)
    go func() { responses &lt;- request(&#34;asia.gopl.io&#34;) }()
    go func() { responses &lt;- request(&#34;europe.gopl.io&#34;) }()
    go func() { responses &lt;- request(&#34;americas.gopl.io&#34;) }()
    return &lt;-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }
</code></pre><h2 id=pipeline串联channels>pipeline(串联channels)<a hidden class=anchor aria-hidden=true href=#pipeline串联channels>#</a></h2><p>channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline），见下例和图：</p><pre tabindex=0><code>func main() {
    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func() {
        for x := 0; x &lt; 100; x++ {
            naturals &lt;- x
        }
        close(naturals)
    }()

    // Squarer
    go func() {
        for x := range naturals {
            squares &lt;- x * x
        }
        close(squares)
    }()

    // Printer (in main goroutine)
    for x := range squares {
        fmt.Println(x)
    }
}
</code></pre><p><img alt=pipeline loading=lazy src=/images/go-tips/pipeline.png>
counter是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给squarer求平方，squarer将平方结果通过第二个channel发送给printer。</p><h2 id=并发的非阻塞缓存>并发的非阻塞缓存<a hidden class=anchor aria-hidden=true href=#并发的非阻塞缓存>#</a></h2><p>场景：缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。
需求：并发安全，且避免对整个缓存加锁而导致所有操作都去争一个锁。</p><p>函数例程：</p><pre tabindex=0><code>// 进行HTTP GET请求并且获取http响应body, 开销大, 应避免在不必要的时候反复调用
func httpGetBody(url string) (interface{}, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    return ioutil.ReadAll(resp.Body)
}
</code></pre><p>缓存实现：</p><pre tabindex=0><code>// Package memo provides a concurrency-unsafe
// memoization of a function of type Func.
package memo

// A Memo caches the results of calling a Func.
type Memo struct {
    f     Func
    cache map[string]result
}

// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

type result struct {
    value interface{}
    err   error
}

func New(f Func) *Memo {
    return &amp;Memo{f: f, cache: make(map[string]result)}
}

// NOTE: not concurrency-safe!
func (memo *Memo) Get(key string) (interface{}, error) {
    res, ok := memo.cache[key]
    if !ok {
        res.value, res.err = memo.f(key)
        memo.cache[key] = res
    }
    return res.value, res.err
}
</code></pre><p>顺序的测试缓存：</p><pre tabindex=0><code>m := memo.New(httpGetBody)
for url := range incomingURLs() {
    start := time.Now()
    value, err := m.Get(url)
    if err != nil {
        log.Print(err)
    }
    fmt.Printf(&#34;%s, %s, %d bytes\n&#34;,
    url, time.Since(start), len(value.([]byte)))
}
------
output:

https://golang.org, 175.026418ms, 7537 bytes
https://godoc.org, 172.686825ms, 6878 bytes
https://play.golang.org, 115.762377ms, 5767 bytes
http://gopl.io, 749.887242ms, 2856 bytes
https://golang.org, 721ns, 7537 bytes
https://godoc.org, 152ns, 6878 bytes
https://play.golang.org, 205ns, 5767 bytes
http://gopl.io, 326ns, 2856 bytes
</code></pre><p>那么如果像下面这样并发的测试缓存，由于Get函数不是concurrency-safe，所有会有数据竞争。</p><pre tabindex=0><code>m := memo.New(httpGetBody)
var n sync.WaitGroup
for url := range incomingURLs() {
    n.Add(1)
    go func(url string) {
        start := time.Now()
        value, err := m.Get(url)
        if err != nil {
            log.Print(err)
        }
        fmt.Printf(&#34;%s, %s, %d bytes\n&#34;,
        url, time.Since(start), len(value.([]byte)))
        n.Done()
    }(url)
}
n.Wait()
</code></pre><p>使用-race来观察数据竞争会看到：</p><pre tabindex=0><code>...
WARNING: DATA RACE
Write by goroutine 36:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  ***
      ***
  ...
Previous write by goroutine 35:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  ***
      ***
...
Found 1 data race(s)
</code></pre><p>消除数据竞争最简单的方法就是加锁：</p><pre tabindex=0><code>type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]result
}

// Get is concurrency-safe.
func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    res, ok := memo.cache[key]
    if !ok {
        res.value, res.err = memo.f(key)
        memo.cache[key] = res
    }
    memo.mu.Unlock()
    return res.value, res.err
}
</code></pre><p>但是加了这个锁，Get就将本来可以并行的I/O操作串行化了。</p><p>怎么优化呢？上面Lock锁的范围太大了，考虑缩小临界区，下面的优化把开销最大的I/O操作从临界区分离出来，使得I/O操作可并发，但是，对于相同的<code>key</code>，<code>memo.f(key)</code>可能会重复执行。</p><pre tabindex=0><code>func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    res, ok := memo.cache[key]
    memo.mu.Unlock()
    if !ok {
        res.value, res.err = memo.f(key)

        // Between the two critical sections, several goroutines
        // may race to compute f(key) and update the map.
        
        memo.mu.Lock()
        memo.cache[key] = res
        memo.mu.Unlock()
    }
    return res.value, res.err
}
</code></pre><p>上述的重复工作是应该避免的，即<strong>duplicate suppression(重复抑制)</strong>。看下面的优化。获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成(也就是有其它的goroutine在调用f这个慢函数)时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。
如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。
条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到"ready"的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。
这样<strong>并发、不重复、无阻塞</strong>的cache就完成了。</p><pre tabindex=0><code>type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

func New(f Func) *Memo {
    return &amp;Memo{f: f, cache: make(map[string]*entry)}
}

type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]*entry
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    e := memo.cache[key]
    if e == nil {
        // This is the first request for this key.
        // This goroutine becomes responsible for computing
        // the value and broadcasting the ready condition.
        e = &amp;entry{ready: make(chan struct{})}
        memo.cache[key] = e
        memo.mu.Unlock()

        e.res.value, e.res.err = memo.f(key)

        close(e.ready) // broadcast ready condition
    } else {
        // This is a repeat request for this key.
        memo.mu.Unlock()

        &lt;-e.ready // wait for ready condition
    }
    return e.res.value, e.res.err
}
</code></pre><p>上面的例子使用互斥量来保护多个goroutine调用Get时的共享map变量。接下来使用monitor goroutine(把map变量限制在一个单独goroutine)方案再实现一遍，使用monitor goroutine时需要使用到消息。（<strong>共享内存通信 vs 消息通信</strong>）</p><pre tabindex=0><code>// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

// A result is the result of calling a Func.
type result struct {
    value interface{}
    err   error
}

type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

// A request is a message requesting that the Func be applied to key.
type request struct {
    key      string
    response chan&lt;- result // the client wants a single result
}

type Memo struct{ requests chan request }
// New returns a memoization of f.  Clients must subsequently call Close.
func New(f Func) *Memo {
    memo := &amp;Memo{requests: make(chan request)}
    go memo.server(f)
    return memo
}

func (memo *Memo) Get(key string) (interface{}, error) {
    response := make(chan result)
    memo.requests &lt;- request{key, response}
    res := &lt;-response
    return res.value, res.err
}

func (memo *Memo) Close() { close(memo.requests) }

func (memo *Memo) server(f Func) {
    cache := make(map[string]*entry)
    for req := range memo.requests {
        e := cache[req.key]
        if e == nil {
            // This is the first request for this key.
            e = &amp;entry{ready: make(chan struct{})}
            cache[req.key] = e
            go e.call(f, req.key) // call f(key)
        }
        go e.deliver(req.response)
    }
}

func (e *entry) call(f Func, key string) {
    // Evaluate the function.
    e.res.value, e.res.err = f(key)
    // Broadcast the ready condition.
    close(e.ready)
}

func (e *entry) deliver(response chan&lt;- result) {
    // Wait for the ready condition.
    &lt;-e.ready
    // Send the result to the client.
    response &lt;- e.res
}
</code></pre><h2 id=context>context<a hidden class=anchor aria-hidden=true href=#context>#</a></h2><p>context翻译：</p><pre tabindex=0><code>上下文;语境;(事情发生的)背景，环境
</code></pre><p>上下文，就是一段代码(线程、协程等调度单元)在CPU的寄存器状态集，运行代码就把这段状态加载到寄存器，切出代码就把寄存器的状态保存到缓存或内存。</p><p>go的context本质上也是goroutine间通信的工具，用于在多个goroutine之间共享消息。channel是goroutine之间传递消息的桥梁，当然也可以用来传递一个关闭信号(channel+select实现)，但是如果需要“广播”，可以使用close channel的方式发送一个“广播”信号；context其实就是帮助做了“广播”，其Done方法就是利用一个 <code>&lt;-chan struct{}</code> 的关闭来实现“广播”效果；此外，context还能存储一些信息，用来在多个goroutine之间共享。</p><p>关于context的几点说明：</p><ul><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据，例如：登陆的 session、cookie 等</li><li>同一个 context 可能会被传递到多个 goroutine，但 context 是并发安全，所以没关系</li></ul><p>几个关键函数：</p><pre tabindex=0><code>// Background returns a non-nil, empty Context. It is never canceled, has no
// values, and has no deadline. It is typically used by the main function,
// initialization, and tests, and as the top-level Context for incoming
// requests.
func Background() Context

// TODO returns a non-nil, empty Context. Code should use context.TODO when
// it&#39;s unclear which Context to use or it is not yet available (because the
// surrounding function has not yet been extended to accept a Context
// parameter).
func TODO() Context

// 与共享信息有关的 WithValue

// WithValue returns a copy of parent in which the value associated with key is
// val.
//
// Use context Values only for request-scoped data that transits processes and
// APIs, not for passing optional parameters to functions.
//
// The provided key must be comparable and should not be of type
// string or any other built-in type to avoid collisions between
// packages using context. Users of WithValue should define their own
// types for keys. To avoid allocating when assigning to an
// interface{}, context keys often have concrete type
// struct{}. Alternatively, exported context key variables&#39; static
// type should be a pointer or interface.
func WithValue(parent Context, key, val interface{}) Context

// 与“广播”控制有关的 WithCancel WithDeadline WithTimeout

// WithCancel returns a copy of parent with a new Done channel. The returned
// context&#39;s Done channel is closed when the returned cancel function is called
// or when the parent context&#39;s Done channel is closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// WithDeadline returns a copy of the parent context with the deadline adjusted
// to be no later than d. If the parent&#39;s deadline is already earlier than d,
// WithDeadline(parent, d) is semantically equivalent to parent. The returned
// context&#39;s Done channel is closed when the deadline expires, when the returned
// cancel function is called, or when the parent context&#39;s Done channel is
// closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre><p><strong>从上面函数的定义可以看到，context的cancelFunc是与context一同分开返回的，context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context</strong>。</p><p>举个简单栗子：</p><pre tabindex=0><code>package main

import (
	&#34;context&#34;
	&#34;fmt&#34;
	&#34;time&#34;
)

func main() {
	background := context.Background()

	// input values
	values := map[string]string{
		&#34;key1&#34;: &#34;value1&#34;,
		&#34;key2&#34;: &#34;value2&#34;,
	}
	ctxWithValue, _ := context.WithCancel(background)
	for k, v := range values {
		ctxWithValue = context.WithValue(ctxWithValue, k, v)
	}

	// timeout: 10s, protect usage
	ctxWithTimeout, cancelFunc := context.WithTimeout(ctxWithValue, time.Second*10)

	goroutineCount := 10
	for i := 0; i &lt; goroutineCount; i++ {
		go func(ctx context.Context, index int) {

			count := 0

			for {
				fmt.Println(&#34;gouroutine index: &#34;, index, &#34; &#34;, &#34;count: &#34;, 
				count, &#34; &#34;, &#34;key1: &#34;, ctx.Value(&#34;key1&#34;))

				count++
				time.Sleep(time.Millisecond * 500)
			}

		}(ctxWithTimeout, i)
	}

	// sleep 3s, actually should do something
	time.Sleep(time.Second * 3)

	cancelFunc()
}
</code></pre><p>context可能不是很完美：</p><ul><li>ctx放在函数第一个参数，导致代码中ctx泛滥</li><li>ctx创建子节点，底层实际是在链表中创建节点，链表的O(n)有些时候会降低效率</li></ul><p>但是，context简便的解决了"cancelation"的问题。</p><h2 id=context-1>*context<a hidden class=anchor aria-hidden=true href=#context-1>#</a></h2><p>context限制信息流向，子context一般不允许修改父context内容，并且一般函数传递(ctx context.Context)参数时就直接避免了这一点，但是，如果某些场景需要修改context内容，需要使用(ctxPtr *context.Context)参数。</p><h2 id=_test-测试package>*_test 测试package<a hidden class=anchor aria-hidden=true href=#_test-测试package>#</a></h2><p>包net/url(例子)同路径可以再声明一个net/url_test包。包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。
可以将这个外部测试包的导入路径视作是net/url_test会，但是实际上，它并不能被其他任何包导入。</p><p>包内测试函数就可以测试逻辑，为啥还要搞外部测试包？
<strong>外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包，包内的测试代码无法做到这点</strong>。
在设计层面，外部测试包是在所有它依赖的包的上层。
举个具体的例子，B包依赖的A包，A包在进行测试时，希望使用B包的功能，可是如果A直接importB，那么就发生了循环依赖，将导致编译报错。此时就可以在A同级开一个A_test的外部测试包，这个测试包可以以一个第三方包的角色同时import A B，这样就可以测试了</p><h2 id=别写脆弱的测试代码>别写脆弱的测试代码<a hidden class=anchor aria-hidden=true href=#别写脆弱的测试代码>#</a></h2><p>避免脆弱测试代码的方法是只检测真正关心的属性。</p><p>保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串（很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试）。</p><p>总之单元测试的原则是：</p><ul><li>逻辑覆盖全面</li><li>尽量保持自身鲁棒性，少依赖不稳定性因素</li></ul><h2 id=表驱动测试>表驱动测试<a hidden class=anchor aria-hidden=true href=#表驱动测试>#</a></h2><p>单元测试的测试用例最好按照<code>input=>expected output</code>映射表方式管理，不仅可以简化测试代码(for循环完成检测)，同时也能更方便的管理测试用例</p><h2 id=go-test--go-tool-cover>go test + go tool cover<a hidden class=anchor aria-hidden=true href=#go-test--go-tool-cover>#</a></h2><p>关于<code>go test</code>, <code>go tool cover</code>可具体查看命令文档。</p><p>实践：</p><pre tabindex=0><code>// 生成测试文件test-tmp.out
// -coverprofile 通过在测试代码中插入生成钩子来统计覆盖率数据
// 在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入输出文件，并打印一部分执行的语句的一个总结
// 如果只需要摘要，可以使用 -cover
go test -covermode=count -coverprofile=test-tmp.out ./...

// 浏览器html形式查看测试报告
go tool cover -html=test-tmp.out
</code></pre><h2 id=go-test--性能分析>go test + 性能分析<a hidden class=anchor aria-hidden=true href=#go-test--性能分析>#</a></h2><pre tabindex=0><code>go test -cpuprofile=cpu.out         // cpu
go test -blockprofile=block.out     // 阻塞：记录阻塞goroutine最久的操作
go test -memprofile=mem.out         // 内存
</code></pre><h2 id=benchmark基准测试>benchmark(基准测试)<a hidden class=anchor aria-hidden=true href=#benchmark基准测试>#</a></h2><p>go的testing包提供的更直观的测试代码性能的方法，要学会使用benchmark优化自己的代码。</p><p>举个例子：</p><pre tabindex=0><code>xxx.go:
------
package xxx

// 被测试的函数：计算第n个斐波那契数
func fib(n int) int {
    if n &lt;= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
------
xxx_test.go
------
package xxx

import &#34;testing&#34;

// 基准测试函数
func BenchmarkFib(b *testing.B) {
    // b.N会由测试框架根据情况自动调整，确保测试有足够的运行时间
    for i := 0; i &lt; b.N; i++ {
        fib(10) // 测试计算第10个斐波那契数的性能
    }
}

// 可以为不同的输入添加多个基准测试
func BenchmarkFib20(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        fib(20) // 测试计算第20个斐波那契数的性能
    }
}
</code></pre><p>benchmark测试命令：</p><pre tabindex=0><code>go test [-bench=&lt;正则表达式&gt;] [其他选项] [包路径]
</code></pre><ul><li>-bench：指定要运行的基准测试，支持正则表达式匹配测试函数名</li><li>其他选项<ul><li>-benchtime=5s 指定基准测试的最小运行时间(默认1秒)</li><li>-benchmem 显示内存分配信息</li></ul></li><li>包路径：若不指定，默认测试当前目录下的包</li></ul><h2 id=golang指针运算>golang指针运算<a hidden class=anchor aria-hidden=true href=#golang指针运算>#</a></h2><p>Go的指针是不支持运算的，但是借助unsafe.Pointer和uintptr可以实现这个骚操作。</p><table><thead><tr><th>类型</th><th>概念</th><th>持有对象(即指针不释放，其持有的对象GC无法回收)</th><th>指针运算</th><th>转换</th></tr></thead><tbody><tr><td>*</td><td>普通的指针，传递对象的地址</td><td>可持有</td><td>不支持</td><td>与unsafe.Pointer相互转换</td></tr><tr><td>unsafe.Pointer</td><td>类似C的void*，可以包含任意类型变量的地址</td><td>可持有</td><td>不支持</td><td>与 *和uintptr 相互转换</td></tr><tr><td>uintptr</td><td>可以理解为一个纯数值?(字节长度与int一致，uintptr is an integer type that is large enough to hold the bit pattern of any pointer)</td><td>不可持有(GC 不把 uintptr 当指针，uintptr 类型的目标会被回收)</td><td>支持</td><td>与unsafe.Pointer相互转换</td></tr></tbody></table><p>如上表，<strong>unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算</strong>。</p><p>举个栗子：</p><pre tabindex=0><code>package main
  ​
  import (
      &#34;fmt&#34;
      &#34;unsafe&#34;
  )
  ​
  func main() {
      //定义一个长度为3的int8类型数组
      a:=[3]int8{6,8,9}
      //取出数组第一个位置的地址
      a_first_point:=&amp;a[0]
      a_first_unsafe_point:=unsafe.Pointer(a_first_point)
      fmt.Println(&#34;a[0]的地址为：&#34;,a_first_unsafe_point)
      //指针只能一个字节字节取，int8占一个字节，所以看到值只加了1
      fmt.Println(&#34;a[1]的地址为：&#34;,unsafe.Pointer(&amp;a[1]))
      //把a_first_unsafe_point转成uintptr类型，就可以指针运算了
      a_uintptr_first_unsafe_point:=uintptr(a_first_unsafe_point)
      //指针+1 表示到了数组的第二个位置
      a_uintptr_first_unsafe_point++
      fmt.Println(&#34;a[0]位置指针自增1后，的指针位置：&#34;,a_uintptr_first_unsafe_point)
      //打印出来可以看到跟&amp;a[1]的地址是一样的
      a_uintptr_second_unsafe_point:=unsafe.Pointer(a_uintptr_first_unsafe_point)
      fmt.Println(&#34;a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型：&#34;,a_uintptr_second_unsafe_point)
      //将该指针转换成 *int8类型（因为它本身就是*int8类型）
      int8_point:=(*int8)(a_uintptr_second_unsafe_point)
      //解引用，得到指针对应的结果，就是数组的第二个值，8
      fmt.Println(*int8_point)  ​
}

------

output:

a[0]的地址为： 0xc000118000
a[1]的地址为： 0xc000118001
a[0]位置指针自增1后，的指针位置： 824634867713
a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型： 0xc000118001
8
</code></pre><p>再举个正反栗：</p><pre tabindex=0><code>// right
var x struct {
    a bool
    b int16
    c []int
}

// 和 pb := &amp;x.b 等价
pb := (*int16)(unsafe.Pointer(
    uintptr(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)))
*pb = 42
fmt.Println(x.b) // &#34;42&#34;

------

// wrong
// NOTE: subtly incorrect!
// 错误的原因是引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针
// 当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;x.b地址
// 第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序
tmp := uintptr(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)
pb := (*int16)(unsafe.Pointer(tmp))
*pb = 42

------

// 错误的原因是，并没有指针引用new新创建的变量，因此该语句执行完成之后，
// 垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址
pT := uintptr(unsafe.Pointer(new(T)))
</code></pre><p>看了上面的例子，当从其他地方获取到了<code>uintptr</code>以后，为了避免GC回收其对应地址的变量，应该尽快将<code>uintptr</code>转化为<code>unsafe.Pointer</code>。</p><h2 id=错误处理习惯>错误处理习惯<a hidden class=anchor aria-hidden=true href=#错误处理习惯>#</a></h2><ul><li>优先使用 errors.New 来创建错误变量，如果有格式化需求，可以使用 fmt.Errorf</li><li>在 fmt.Errorf 中使用 : %w 关键字来将一个错误 wrap 至其错误链中</li><li>Go1.20后，使用errors.Join取代上一点</li><li>使用 errors.Unwrap 来获得其错误链的上一个错误</li><li>使用 errors.Is 而非 == 来判定一个错误是否为特定错误(能够追溯错误链)</li><li>在错误链上获取特定种类的错误，使用 errors.As</li><li>预先定义枚举好error然后返回，在错误场景比较清晰明确的时候推荐使用</li><li>自定义错误：内部逻辑可以使用，一般不要向外传递</li></ul><h2 id=一行代码recover>一行代码recover<a hidden class=anchor aria-hidden=true href=#一行代码recover>#</a></h2><p>平时goroutine场景我们经常需要recover()保护一下我们的goroutine，以将panic影响范围控制到最小，这个高频使用场景如何简化呢？</p><pre tabindex=0><code>首先，panic信息的输出可以按自己习惯封装一下，一般使用明显的&#34;panic&#34;关键字标识，排查方便一般也会同时补充一下栈信息
------

// FormatRecover - generate error from recover().
func FormatRecover(recoverErr any) error {
	if recoverErr == nil {
		return nil
	}

	return fmt.Errorf(&#34;panic: %v\n%s&#34;, recoverErr, string(debug.Stack()))
}

------
然后我们一般使用&#34;err error&#34;形式的具名返回值给defer操作空间，然后像下面这样一行搞定。
我们不需要判空，nil error经过errors.Join后还是一个nil error。
------

func xxx() (ret int, err error) {
	defer func() { err = errors.Join(err, util.FormatRecover(recover())) }()
}
</code></pre><h2 id=一行代码统计函数耗时>一行代码统计函数耗时<a hidden class=anchor aria-hidden=true href=#一行代码统计函数耗时>#</a></h2><pre tabindex=0><code>package main

import(
	&#34;fmt&#34;
	&#34;time&#34;
)

func main() {
    defer CostRecord(&#34;main&#34;, someLogger)()
	
	xxx
}

func CostRecord(funcName string, logger) func(){
	start:=time.Now()
    logger.Infof(&#34;%s start&#34;, funcName)
	return func(){
        logger.Infof(&#34;%s cost: %v&#34;, funcName, time.Since(start))
	}
}
</code></pre><h2 id=方法优先使用指针接受者>方法优先使用指针接受者<a hidden class=anchor aria-hidden=true href=#方法优先使用指针接受者>#</a></h2><ul><li></li></ul><h2 id=方法链>方法链<a hidden class=anchor aria-hidden=true href=#方法链>#</a></h2><p>在定义struct内部操作方法时，仍然返回其自身，这样多个操作就可以做成“链”</p><p><strong>注意：指针接收</strong></p><p>PS: gorm的源码大量的使用方法链方便处理</p><pre tabindex=0><code>package main

import(
	&#34;fmt&#34;
	&#34;time&#34;
)

type Somebody struct{
	Name string
	Age int
}

func (s *Somebody)UpdateName(n string)*Somebody{
	s.Name = n
	return s
}

func (s *Somebody)UpdateAge(a int)*Somebody{
	s.Age = a
	return s
}

func main() {
    s:=Somebody{&#34;heihei&#34;, 1}
	fmt.Println(s)
	s.UpdateName(&#34;haha&#34;).UpdateAge(10) // 这里更清晰优雅
	fmt.Println(s)
}
------
output:

{heihei 1}
{haha 10}
</code></pre><h2 id=函数链>函数链<a hidden class=anchor aria-hidden=true href=#函数链>#</a></h2><p>上一条我们看到了方法链很方便，那么我们日常的函数呢？
下面可能是一个常见的代码：</p><pre tabindex=0><code>func a()(int,error)
func process(input int) error
func main(){
    ret,err:=a()
    if err!=nil{
        xxx
        return
    }

    err=process(ret)
    if err!=nil{
        xxx
    }
}
</code></pre><p>如果process能够接受a的全部返回值并且有能力处理a返回的错误，那么我们可以这样写</p><pre tabindex=0><code>func a()(int,error)
func process(input int, err error) error
func main(){
    err:=process(a())
    if err!=nil{
        xxx
    }
}
</code></pre><h2 id=数字分隔符_>数字分隔符_<a hidden class=anchor aria-hidden=true href=#数字分隔符_>#</a></h2><p>用<code>_</code>分隔长数字串提升可读性</p><pre tabindex=0><code>package main

import(
	&#34;fmt&#34;
)

const(
	pai = 3.141_592_6
	bi = 1_000_000
)

func main() {
    fmt.Println(pai)
	fmt.Println(bi)
}

------
output:

3.1415926
1000000
</code></pre><h2 id=cryptorand--mathrand>crypto/rand > math/rand<a hidden class=anchor aria-hidden=true href=#cryptorand--mathrand>#</a></h2><p>math/rand手动指定种子，尤其适用时间戳做种子时，临近时间的种子几乎相等，更加伪随机；
crypto/rand随机性更好。</p><h2 id=-比较>== 比较<a hidden class=anchor aria-hidden=true href=#-比较>#</a></h2><p>对于<code>any(interface{})</code>的比较，只有当类型和值都相同时，才被判定为<code>==</code>;</p><pre tabindex=0><code>注意区分类型定义和类型别名:
type A int // 新类型, 不是int
type B = int // 类型别名, 类型是int

------
package main

import(
	&#34;fmt&#34;
	&#34;reflect&#34;
)

type A int // 新类型
type B = int // 类型别名

func main() {
	var a A = 1
	var b B = 1
	var c int  =1
    fmt.Println(reflect.DeepEqual(a, c)) // false
	fmt.Println(reflect.DeepEqual(b, c)) // true
}
</code></pre><p>利用这个特性，在context.WithValue传递数据时，为避免key冲突，可以考虑使用特定的类型或者结构体来作为key</p><h2 id=panic的使用>panic的使用<a hidden class=anchor aria-hidden=true href=#panic的使用>#</a></h2><ul><li>panic必须在同goroutine捕获处理</li><li>尽量少主动抛出panic, 做好error处理</li><li>如果有些场景可能主动panic,函数命名一般采用MustXXX</li></ul><h2 id=尽量保留对goroutine声明周期的管理>尽量保留对goroutine声明周期的管理<a hidden class=anchor aria-hidden=true href=#尽量保留对goroutine声明周期的管理>#</a></h2><p>例如下面这样，使用ctx来管理goroutine生命周期</p><pre tabindex=0><code>func do(ctx context.Context){
    select{
    case &lt;-ctx.Done():
        return
    default:
        // do sth
        time.Sleep(time.Second)
    }
}
</code></pre><h2 id=简单并发场景使用好errorgroup>简单并发场景使用好errorgroup<a hidden class=anchor aria-hidden=true href=#简单并发场景使用好errorgroup>#</a></h2><p>默认情况下，errorgroup会等待所有任务完成并返回第一个错误(<strong>仅返回第一个非nil错误，后续错误会被忽略</strong>)
errorgroup会等待所有任务完成，即不主动终止其他正在运行的任务；如果希望第一个错误发生后立即取消其他任务，可以结合context.WithCancel实现</p><pre tabindex=0><code>package main

import (
	&#34;context&#34;
	&#34;errors&#34;
	&#34;fmt&#34;
	&#34;golang.org/x/sync/errorgroup&#34;
	&#34;time&#34;
)

func main() {
	// 创建带取消功能的上下文
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // 确保最终释放

	// 创建关联上下文的 errorgroup
	eg, ctx := errorgroup.WithContext(ctx)

	// 任务1：监听上下文取消
	eg.Go(func() error {
		select {
		case &lt;-time.After(200 * time.Millisecond):
			fmt.Println(&#34;任务1完成&#34;)
			return nil
		case &lt;-ctx.Done(): // 若上下文被取消，提前退出
			fmt.Println(&#34;任务1被取消&#34;)
			return ctx.Err()
		}
	})

	// 任务2：主动返回错误（触发取消）
	eg.Go(func() error {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(&#34;任务2失败&#34;)
		return errors.New(&#34;任务2出错了&#34;)
	})

	// 任务3：监听上下文取消
	eg.Go(func() error {
		select {
		case &lt;-time.After(300 * time.Millisecond):
			fmt.Println(&#34;任务3完成&#34;)
			return nil
		case &lt;-ctx.Done():
			fmt.Println(&#34;任务3被取消&#34;)
			return ctx.Err()
		}
	})

	// 等待结果
	if err := eg.Wait(); err != nil {
		fmt.Printf(&#34;整体执行失败：%v\n&#34;, err)
	} else {
		fmt.Println(&#34;所有任务执行成功&#34;)
	}
}
</code></pre><h2 id=带ctx的sleep函数>带ctx的Sleep函数<a hidden class=anchor aria-hidden=true href=#带ctx的sleep函数>#</a></h2><p>通常我们等待会直接time.Sleep，但是这样不受控制，因此可以这样改进：</p><pre tabindex=0><code>func SleepWithContext(ctx context.Context, duration time.Duration) error {
	select {
	case &lt;-time.After(duration):
		// 睡眠时间到，正常返回
		return nil
	case &lt;-ctx.Done():
		// 上下文被取消（超时、取消等），返回上下文的错误
		return ctx.Err()
	}
}

func xxx(ctx context.Context){
    for{
        select{
        case &lt;-ctx.Done():
            return
        default:
            if err:=SleepWithContext(ctx,time.Second);err!=nil{
                xxx
            }
        }
    }
}
</code></pre><h2 id=s-vs-q>%s vs %q<a hidden class=anchor aria-hidden=true href=#s-vs-q>#</a></h2><ul><li>%s输出字符串，特殊字符会处理</li><li>%q带"&ldquo;输出字符串，特殊字符原样输出</li></ul><pre tabindex=0><code>package main

import(
	&#34;fmt&#34;
)

func main() {
	abc := &#34;aa\nbb\tcc&#34;
	fmt.Printf(&#34;%s\n&#34;,abc)
	fmt.Println()
	fmt.Printf(&#34;%q\n&#34;,abc)
}

------
output:

aa
bb	cc

&#34;aa\nbb\tcc&#34;
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://duck-dd.github.io/tags/golang/>Golang</a></li><li><a href=https://duck-dd.github.io/tags/2025/>2025</a></li></ul><nav class=paginav><a class=prev href=https://duck-dd.github.io/posts/2025-06-23-shortest-path/><span class=title>« Prev</span><br><span>The Shortest Path</span>
</a><a class=next href=https://duck-dd.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/><span class=title>Next »</span><br><span>相似度</span></a></nav></footer><script src=https://utteranc.es/client.js repo=duck-dd/blog-comment issue-term=pathname label='💬 Comments' theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://duck-dd.github.io/>Duck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$",right:"$",display:!1},{left:"$$",right:"$$",display:!0}],throwOnError:!1})})</script></body></html>