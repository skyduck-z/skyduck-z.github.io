<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MCMF from scratch | Duck</title><meta name=keywords content="Algorithm,2025"><meta name=description content='需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。
记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。
MCMF概念
Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：
有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；
求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量
在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。
最大流问题
最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。
第一印象
简单描述，有向有权图，起点s，终点t，我们要寻找s->t的最大的流量。
那么朴素的第一印象来看，暴力呗，BFS把所有s->t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边->剩余容量)，结束后得到一个总的流量值。
提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。
好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：

图1 blocking-flow(黑色数字=容量,红色数字=流量)
如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。
结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。
那么如何修正能够确保准确的找到最大流呢？

再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度)
前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈)

我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的
那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了



Ford-Fulkerson
一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。
从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。
但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径)
不是的，还是用图1左举例，他的residual graph如下：

图2 图1左部的residual-graph
图2中，我们可以继续找到这样一条路径s->v2->v4->v1->v3->t 流量=1，其中v4->v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。
那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s&mdash;>t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。'><meta name=author content><link rel=canonical href=https://duck-dd.github.io/posts/2025-06-24-mcmf/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://duck-dd.github.io/posts/2025-06-24-mcmf/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://duck-dd.github.io/posts/2025-06-24-mcmf/"><meta property="og:site_name" content="Duck"><meta property="og:title" content="MCMF from scratch"><meta property="og:description" content='需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。 记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。
MCMF概念 Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：
有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；
求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量
在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。
最大流问题 最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。
第一印象 简单描述，有向有权图，起点s，终点t，我们要寻找s->t的最大的流量。 那么朴素的第一印象来看，暴力呗，BFS把所有s->t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边->剩余容量)，结束后得到一个总的流量值。 提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。 好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：
图1 blocking-flow(黑色数字=容量,红色数字=流量) 如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。 结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。
那么如何修正能够确保准确的找到最大流呢？
再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度) 前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈) 我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的 那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了 Ford-Fulkerson 一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。 从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。 但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径) 不是的，还是用图1左举例，他的residual graph如下：
图2 图1左部的residual-graph 图2中，我们可以继续找到这样一条路径s->v2->v4->v1->v3->t 流量=1，其中v4->v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。 那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s—>t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-24T00:00:00+00:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="2025"><meta property="og:image" content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MCMF from scratch"><meta name=twitter:description content='需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。
记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。
MCMF概念
Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：
有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；
求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量
在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。
最大流问题
最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。
第一印象
简单描述，有向有权图，起点s，终点t，我们要寻找s->t的最大的流量。
那么朴素的第一印象来看，暴力呗，BFS把所有s->t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边->剩余容量)，结束后得到一个总的流量值。
提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。
好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：

图1 blocking-flow(黑色数字=容量,红色数字=流量)
如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。
结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。
那么如何修正能够确保准确的找到最大流呢？

再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度)
前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈)

我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的
那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了



Ford-Fulkerson
一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。
从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。
但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径)
不是的，还是用图1左举例，他的residual graph如下：

图2 图1左部的residual-graph
图2中，我们可以继续找到这样一条路径s->v2->v4->v1->v3->t 流量=1，其中v4->v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。
那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s&mdash;>t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://duck-dd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"MCMF from scratch","item":"https://duck-dd.github.io/posts/2025-06-24-mcmf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MCMF from scratch","name":"MCMF from scratch","description":"需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。 记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。\nMCMF概念 Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：\n有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；\n求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量\n在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。\n最大流问题 最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。\n第一印象 简单描述，有向有权图，起点s，终点t，我们要寻找s-\u0026gt;t的最大的流量。 那么朴素的第一印象来看，暴力呗，BFS把所有s-\u0026gt;t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边-\u0026gt;剩余容量)，结束后得到一个总的流量值。 提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。 好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：\n图1 blocking-flow(黑色数字=容量,红色数字=流量) 如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。 结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。\n那么如何修正能够确保准确的找到最大流呢？\n再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度) 前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈) 我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的 那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了 Ford-Fulkerson 一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。 从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。 但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径) 不是的，还是用图1左举例，他的residual graph如下：\n图2 图1左部的residual-graph 图2中，我们可以继续找到这样一条路径s-\u0026gt;v2-\u0026gt;v4-\u0026gt;v1-\u0026gt;v3-\u0026gt;t 流量=1，其中v4-\u0026gt;v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了\u0026quot;撤销\u0026quot;)，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。 那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s\u0026mdash;\u0026gt;t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。\n","keywords":["Algorithm","2025"],"articleBody":"需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。 记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。\nMCMF概念 Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：\n有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；\n求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量\n在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。\n最大流问题 最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。\n第一印象 简单描述，有向有权图，起点s，终点t，我们要寻找s-\u003et的最大的流量。 那么朴素的第一印象来看，暴力呗，BFS把所有s-\u003et路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边-\u003e剩余容量)，结束后得到一个总的流量值。 提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。 好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：\n图1 blocking-flow(黑色数字=容量,红色数字=流量) 如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。 结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。\n那么如何修正能够确保准确的找到最大流呢？\n再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度) 前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈) 我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的 那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了 Ford-Fulkerson 一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。 从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。 但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径) 不是的，还是用图1左举例，他的residual graph如下：\n图2 图1左部的residual-graph 图2中，我们可以继续找到这样一条路径s-\u003ev2-\u003ev4-\u003ev1-\u003ev3-\u003et 流量=1，其中v4-\u003ev1 流量=1这一段是我们选中的反向边(我们只对这一条边做了\"撤销\")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。 那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s—\u003et的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。\nFord-Fulkerson优化 Edmonds-Karp 每次迭代选取路径时，把residual graph当作无权图寻找最短路径，价值是证明了这里复杂度降低了，证明过程自求多福吧\nDinic(Dinitz) 每次迭代时，按照residual graph中将各个节点与起点s的距离将图分层，只保留 s到第一层 第一层到第二层 … 的边，构造出level graph，然后在level graph中寻找阻塞流，而后更新residual graph(同样是记录反向边)，迭代迭代迭代…\nMinimum Cut(S-T Cut, 最小割) 最小割定义 在一个带权有向图（通常为流量网络）中，割(Cut)是将顶点集V划分为两个不相交子集S和T（即S ∪ T = V，S ∩ T = ∅）的分割方式，其中源点s ∈ S，汇点t ∈ T. 割的容量定义为从子集S指向子集T的所有边的总容量(不包含反向边)，记为c(S, T). 最小割则是所有可能的割中，容量最小的那个割；一个网络可能存在多个最小割，但它们的容量相等(==最大流)。\n最大流最小割定理 在任何流量网络中，从源点到汇点的最大流值等于最小割的容量.\n要理解这个定理，还是结合物理意义最直观；我们这样想，流量一定是从s流向t的，我们把整个图抽象成一整根粗细不均的水管，那么每一个割，就是组成这个水管的一个个截面，那么那个最小的截面，就是这根水管的容量；为什么一个割是一个截面呢？因为割的性质就是把整个图完全切成了S和T（S ∪ T = V, S ∩ T = ∅, s ∈ S, t ∈ T ），就像在水管上切了一刀，切出了一个平面。\n寻找最小割 先求最大流：通过最大流算法（如Dinic、Edmonds-Karp等）计算从源点s到汇点t的最大流f 利用残量网络确定割集：在最大流对应的残量网络中，从源点s出发，通过所有 “剩余容量大于0” 的边可到达的顶点构成集合S，其余顶点构成集合T(t ∈ T)，则 (S, T) 为最小割。 为啥这样找？最终的残量网络中，那些完全被跑满的边，就是被割断的边，所以起点s还能触达的部分，就是割完以后S的部分，剩下的能触达t的部分，就是T。\n最小费用流问题 在满足流量需求的前提下，使网络中传输流量的总费用最低。\n网络模型 最小费用流问题基于一个带权有向图G=(V, E)，其中：V为顶点集（包含源点s和汇点t）；E为边集，每条边(u, v)具有两个属性：容量c(u, v)：该边可传输的最大流量；单位费用w(u, v)：通过该边传输 1 单位流量的费用（可正可负，但需避免负权环影响可行性）。\n核心需求 给定一个流量需求F（需从源点s传输到汇点t的总流量），找到一个可行流f，使得：\n流量满足：总流量 f 总 = F （若F等于最大流，则问题退化为最小费用最大流）； 费用最小：总费用 cost = ∑ ( u , v ) ∈ E f ( u , v ) × w ( u , v ) 最小。 Successive Shortest Paths（连续最短增广路算法） 每次从残量网络中寻找从s到t的费用最小的增广路径，沿该路径增广尽可能多的流量，重复直到满足流量F或无法增广。\n步骤：\n初始化流f为 0，总费用为 在残量网络中，用最短路径算法（如 SPFA、Dijkstra + 势函数）寻找s到t的最小费用路 计算该路径的最大可增广流量（路径上的最小残量容量 沿路径增广流量，更新残量网络和总费 重复步骤 2-4，直到总流量达到F或无增广路径（此时F不可行） 还有很多算法，此处不赘述。\n再来看MCMF 现在就好理解了，我们按照Ford-Fulkerson一定能够找到最大流，但是每次选择 增广路(继续扩大流量的起点到终点的路径) 时，结合最短路(带权)，寻找费用(权重)最小的那条路拉满，直至无法找到新的增广路为止。\n思考：每次都是贪心寻找最小费用增广路，能够确保最终找到的一定是最小费用吗？\n","wordCount":"201","inLanguage":"en","image":"https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-06-24T00:00:00Z","dateModified":"2025-06-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://duck-dd.github.io/posts/2025-06-24-mcmf/"},"publisher":{"@type":"Organization","name":"Duck","logo":{"@type":"ImageObject","url":"https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://duck-dd.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://duck-dd.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://duck-dd.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://duck-dd.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://duck-dd.github.io/about_me title=关于我><span>关于我</span></a></li><li><a href=https://duck-dd.github.io/about_space title=关于这里><span>关于这里</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://duck-dd.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://duck-dd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MCMF from scratch</h1><div class=post-meta><span title='2025-06-24 00:00:00 +0000 UTC'>2025-06-24</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-24&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words<div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/categories/cs/>CS</a></div><div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/tags/algorithm/>Algorithm</a>
<span>,</span>
<a href=https://duck-dd.github.io/tags/2025/>2025</a></div></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#mcmf%e6%a6%82%e5%bf%b5 aria-label=MCMF概念>MCMF概念</a></li><li><a href=#%e6%9c%80%e5%a4%a7%e6%b5%81%e9%97%ae%e9%a2%98 aria-label=最大流问题>最大流问题</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e5%8d%b0%e8%b1%a1 aria-label=第一印象>第一印象</a></li><li><a href=#ford-fulkerson aria-label=Ford-Fulkerson>Ford-Fulkerson</a></li><li><a href=#ford-fulkerson%e4%bc%98%e5%8c%96 aria-label=Ford-Fulkerson优化>Ford-Fulkerson优化</a><ul><li><a href=#edmonds-karp aria-label=Edmonds-Karp>Edmonds-Karp</a></li><li><a href=#dinicdinitz aria-label=Dinic(Dinitz)>Dinic(Dinitz)</a></li></ul></li><li><a href=#minimum-cuts-t-cut-%e6%9c%80%e5%b0%8f%e5%89%b2 aria-label="Minimum Cut(S-T Cut, 最小割)">Minimum Cut(S-T Cut, 最小割)</a><ul><li><a href=#%e6%9c%80%e5%b0%8f%e5%89%b2%e5%ae%9a%e4%b9%89 aria-label=最小割定义>最小割定义</a></li><li><a href=#%e6%9c%80%e5%a4%a7%e6%b5%81%e6%9c%80%e5%b0%8f%e5%89%b2%e5%ae%9a%e7%90%86 aria-label=最大流最小割定理>最大流最小割定理</a></li><li><a href=#%e5%af%bb%e6%89%be%e6%9c%80%e5%b0%8f%e5%89%b2 aria-label=寻找最小割>寻找最小割</a></li></ul></li></ul></li><li><a href=#%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8%e6%b5%81%e9%97%ae%e9%a2%98 aria-label=最小费用流问题>最小费用流问题</a><ul><li><a href=#successive-shortest-paths%e8%bf%9e%e7%bb%ad%e6%9c%80%e7%9f%ad%e5%a2%9e%e5%b9%bf%e8%b7%af%e7%ae%97%e6%b3%95 aria-label="Successive Shortest Paths（连续最短增广路算法）">Successive Shortest Paths（连续最短增广路算法）</a></li></ul></li><li><a href=#%e5%86%8d%e6%9d%a5%e7%9c%8bmcmf aria-label=再来看MCMF>再来看MCMF</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。
记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。</p><h1 id=mcmf概念>MCMF概念<a hidden class=anchor aria-hidden=true href=#mcmf概念>#</a></h1><p>Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：</p><p><code>有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；</code></p><p><code>求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量</code></p><p>在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。</p><h1 id=最大流问题>最大流问题<a hidden class=anchor aria-hidden=true href=#最大流问题>#</a></h1><p>最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：<code>Ford-Fulkerson</code>算法。</p><h2 id=第一印象>第一印象<a hidden class=anchor aria-hidden=true href=#第一印象>#</a></h2><p>简单描述，有向有权图，起点<code>s</code>，终点<code>t</code>，我们要寻找<code>s->t</code>的最大的流量。
那么朴素的第一印象来看，暴力呗，BFS把所有<code>s->t</code>路径集合<code>P</code>全部记录下来，然后逐条路径遍历<code>P</code>，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个<code>边->剩余容量</code>)，结束后得到一个总的流量值。
提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于<code>s</code>的所有出边都满，或者<code>t</code>的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，<code>P</code>的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，<code>P</code>中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对<code>P</code>剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。
好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：</p><p><img alt="图1 blocking-flow(黑色数字=容量,红色数字=流量)" loading=lazy src=/images/mcmf/mcmf-1.png></p><center>图1 blocking-flow(黑色数字=容量,红色数字=流量)</center><p>如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，<code>阻塞流</code>，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。
结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点<code>s</code>以及他的出边，终点<code>t</code>以及他的入边，我们碰到了这样一个情况，我们选定了<code>s</code>的左出边以及<code>t</code>的右入边并且把它们两个给跑满了，而<code>s</code>的右出边和<code>t</code>的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，<code>t</code>的右入边跑满的流量不仅仅来自于<code>s</code>的左出边，还有<code>s</code>的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。</p><p>那么如何修正能够确保准确的找到最大流呢？</p><ul><li>再继续暴力的把<code>P</code>的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度)</li><li>前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈)<ul><li>我们避免使用到不合理的路径？那对路径打分？结合实时的 <code>residual graph(残量图，余量图，残量网络 等)</code>，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(<code>s</code> <code>t</code>除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖<code>residual graph</code>来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的</li><li>那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了</li></ul></li></ul><h2 id=ford-fulkerson>Ford-Fulkerson<a hidden class=anchor aria-hidden=true href=#ford-fulkerson>#</a></h2><p>一句话描述<code>Ford-Fulkerson</code>算法，就是在建立<code>residual graph</code>时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。
从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。
但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径)
不是的，还是用图1左举例，他的<code>residual graph</code>如下：</p><p><img alt="图2 图1左的residual graph" loading=lazy src=/images/mcmf/mcmf-2.png></p><center>图2 图1左部的residual-graph</center><p>图2中，我们可以继续找到这样一条路径<code>s->v2->v4->v1->v3->t 流量=1</code>，其中<code>v4->v1 流量=1</code>这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明<code>Ford-Fulkerson</code>算法是正确的。
那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在<code>residual graph</code>中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在<code>s</code>&mdash;><code>t</code>的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个<code>H</code>型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整<code>H</code>型的两条竖线之间的流量分配方式(即合理规划使用<code>H</code>的左上 左下 右上 右下四部分)，以使得整个<code>H</code>通过的流量最大。</p><h2 id=ford-fulkerson优化>Ford-Fulkerson优化<a hidden class=anchor aria-hidden=true href=#ford-fulkerson优化>#</a></h2><h3 id=edmonds-karp>Edmonds-Karp<a hidden class=anchor aria-hidden=true href=#edmonds-karp>#</a></h3><p>每次迭代选取路径时，把<code>residual graph</code>当作无权图寻找最短路径，价值是证明了这里复杂度降低了，证明过程自求多福吧</p><h3 id=dinicdinitz>Dinic(Dinitz)<a hidden class=anchor aria-hidden=true href=#dinicdinitz>#</a></h3><p>每次迭代时，按照<code>residual graph</code>中将各个节点与起点<code>s</code>的距离将图分层，只保留 <code>s</code>到第一层 第一层到第二层 &mldr; 的边，构造出<code>level graph</code>，然后在<code>level graph</code>中寻找阻塞流，而后更新<code>residual graph</code>(同样是记录反向边)，迭代迭代迭代&mldr;</p><h2 id=minimum-cuts-t-cut-最小割>Minimum Cut(S-T Cut, 最小割)<a hidden class=anchor aria-hidden=true href=#minimum-cuts-t-cut-最小割>#</a></h2><h3 id=最小割定义>最小割定义<a hidden class=anchor aria-hidden=true href=#最小割定义>#</a></h3><p>在一个带权有向图（通常为流量网络）中，割(Cut)是将顶点集V划分为两个不相交子集<code>S</code>和<code>T</code>（即<code>S ∪ T = V，S ∩ T = ∅</code>）的分割方式，其中源点<code>s ∈ S</code>，汇点<code>t ∈ T</code>.
割的容量定义为从子集S指向子集T的所有边的总容量(不包含反向边)，记为<code>c(S, T)</code>.
最小割则是所有可能的割中，容量最小的那个割；一个网络可能存在多个最小割，但它们的容量相等(==最大流)。</p><h3 id=最大流最小割定理>最大流最小割定理<a hidden class=anchor aria-hidden=true href=#最大流最小割定理>#</a></h3><p><code>在任何流量网络中，从源点到汇点的最大流值等于最小割的容量</code>.</p><p>要理解这个定理，还是结合物理意义最直观；我们这样想，流量一定是从<code>s</code>流向<code>t</code>的，我们把整个图抽象成一整根粗细不均的水管，那么每一个<code>割</code>，就是组成这个水管的一个个截面，那么那个最小的截面，就是这根水管的容量；为什么一个<code>割</code>是一个截面呢？因为<code>割</code>的性质就是把整个图完全切成了<code>S</code>和<code>T</code>（<code>S ∪ T = V, S ∩ T = ∅, s ∈ S, t ∈ T </code>），就像在水管上切了一刀，切出了一个平面。</p><h3 id=寻找最小割>寻找最小割<a hidden class=anchor aria-hidden=true href=#寻找最小割>#</a></h3><ul><li>先求最大流：通过最大流算法（如Dinic、Edmonds-Karp等）计算从源点s到汇点t的最大流f</li><li>利用残量网络确定割集：在最大流对应的残量网络中，从源点<code>s</code>出发，通过所有 “剩余容量大于0” 的边可到达的顶点构成集合S，其余顶点构成集合T(<code>t ∈ T</code>)，则 <code>(S, T)</code> 为最小割。</li></ul><p>为啥这样找？最终的残量网络中，那些完全被跑满的边，就是被<code>割</code>断的边，所以起点<code>s</code>还能触达的部分，就是割完以后<code>S</code>的部分，剩下的能触达<code>t</code>的部分，就是<code>T</code>。</p><h1 id=最小费用流问题>最小费用流问题<a hidden class=anchor aria-hidden=true href=#最小费用流问题>#</a></h1><p>在满足<strong>流量需求</strong>的前提下，使网络中传输流量的总费用最低。</p><ol><li>网络模型</li></ol><p>最小费用流问题基于一个带权有向图<code>G=(V, E)</code>，其中：<code>V</code>为顶点集（包含源点s和汇点t）；<code>E</code>为边集，每条边<code>(u, v)</code>具有两个属性：容量<code>c(u, v)</code>：该边可传输的最大流量；单位费用<code>w(u, v)</code>：通过该边传输 1 单位流量的费用（可正可负，但需避免负权环影响可行性）。</p><ol start=2><li>核心需求</li></ol><p>给定一个流量需求F（需从源点s传输到汇点t的总流量），找到一个可行流f，使得：</p><ul><li>流量满足：总流量<math xmlns="http://www.w3.org/1998/Math/MathML">
<msub>
<mi>f</mi>
<mn>总</mn>
</msub>
<mo>=</mo>
<mi>F</mi>
</math>（若F等于最大流，则问题退化为最小费用最大流）；</li><li>费用最小：总费用<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
<mi>cost</mi>
<mo>=</mo>
<munderover>
<mo>∑</mo>
<mrow>
<mo>(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>)</mo>
<mo>∈</mo>
<mi>E</mi>
</mrow>
<mspace width="0em"/>
</munderover>
<mrow>
<mi>f</mi>
<mo>(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>)</mo>
<mo>×</mo>
<mi>w</mi>
<mo>(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo>)</mo>
</mrow>
</mrow>
</math>最小。</li></ul><h2 id=successive-shortest-paths连续最短增广路算法>Successive Shortest Paths（连续最短增广路算法）<a hidden class=anchor aria-hidden=true href=#successive-shortest-paths连续最短增广路算法>#</a></h2><p>每次从残量网络中寻找从s到t的<code>费用最小的增广路径</code>，沿该路径增广尽可能多的流量，重复直到满足流量F或无法增广。</p><p><strong>步骤</strong>：</p><ol><li>初始化流f为 0，总费用为</li><li>在残量网络中，用最短路径算法（如 SPFA、Dijkstra + 势函数）寻找s到t的最小费用路</li><li>计算该路径的最大可增广流量（路径上的最小残量容量</li><li>沿路径增广流量，更新残量网络和总费</li><li>重复步骤 2-4，直到总流量达到F或无增广路径（此时F不可行）</li></ol><p><strong>还有很多算法，此处不赘述</strong>。</p><h1 id=再来看mcmf>再来看MCMF<a hidden class=anchor aria-hidden=true href=#再来看mcmf>#</a></h1><p>现在就好理解了，我们按照Ford-Fulkerson一定能够找到最大流，但是每次选择<code> 增广路(继续扩大流量的起点到终点的路径)</code> 时，结合最短路(带权)，寻找费用(权重)最小的那条路拉满，直至无法找到新的增广路为止。</p><p>思考：每次都是贪心寻找最小费用增广路，能够确保最终找到的一定是最小费用吗？</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://duck-dd.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://duck-dd.github.io/tags/2025/>2025</a></li></ul><nav class=paginav><a class=prev href=https://duck-dd.github.io/posts/2025-08-13-%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/><span class=title>« Prev</span><br><span>目标管理法</span>
</a><a class=next href=https://duck-dd.github.io/posts/2025-06-23-shortest-path/><span class=title>Next »</span><br><span>The Shortest Path</span></a></nav></footer><script src=https://utteranc.es/client.js repo=duck-dd/blog-comment issue-term=pathname label='💬 Comments' theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://duck-dd.github.io/>Duck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$",right:"$",display:!1},{left:"$$",right:"$$",display:!0}],throwOnError:!1})})</script></body></html>