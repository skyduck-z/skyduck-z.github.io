<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS-Other on skyduck</title>
    <link>https://skyduck-z.github.io/tags/cs-other/</link>
    <description>Recent content in CS-Other on skyduck</description>
    <image>
      <title>skyduck</title>
      <url>https://skyduck-z.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://skyduck-z.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Sun, 21 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://skyduck-z.github.io/tags/cs-other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>过滤器 - 布隆家族</title>
      <link>https://skyduck-z.github.io/posts/2025-12-21-%E8%BF%87%E6%BB%A4%E5%99%A8---%E5%B8%83%E9%9A%86%E5%AE%B6%E6%97%8F/</link>
      <pubDate>Sun, 21 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2025-12-21-%E8%BF%87%E6%BB%A4%E5%99%A8---%E5%B8%83%E9%9A%86%E5%AE%B6%E6%97%8F/</guid>
      <description>&lt;p&gt;TBD.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CDN</title>
      <link>https://skyduck-z.github.io/posts/2025-07-13-cdn/</link>
      <pubDate>Sun, 13 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2025-07-13-cdn/</guid>
      <description>&lt;h1 id=&#34;什么是cdn&#34;&gt;什么是CDN&lt;/h1&gt;
&lt;p&gt;CDN，Content Delivery Network，内容分发网络，是构建在基础网络之上的一层&amp;quot;智能分布式网络&amp;quot;&lt;/p&gt;
&lt;h1 id=&#34;cdn的流量接入&#34;&gt;CDN的流量接入&lt;/h1&gt;
&lt;h2 id=&#34;节点&#34;&gt;节点&lt;/h2&gt;
&lt;h3 id=&#34;l1边缘节点&#34;&gt;L1(边缘节点)&lt;/h3&gt;
&lt;h3 id=&#34;l2&#34;&gt;L2&lt;/h3&gt;
&lt;h3 id=&#34;l3&#34;&gt;L3&lt;/h3&gt;
&lt;h3 id=&#34;源站&#34;&gt;源站&lt;/h3&gt;
&lt;h1 id=&#34;缓存&#34;&gt;缓存&lt;/h1&gt;
&lt;h2 id=&#34;命中率回源带宽&#34;&gt;命中率&amp;amp;回源带宽&lt;/h2&gt;
&lt;h2 id=&#34;存储模型&#34;&gt;存储模型&lt;/h2&gt;
&lt;h2 id=&#34;内存淘汰算法&#34;&gt;内存淘汰算法&lt;/h2&gt;
&lt;h1 id=&#34;调度&#34;&gt;调度&lt;/h1&gt;
&lt;h2 id=&#34;dnsanycast&#34;&gt;[DNS]&amp;amp;[Anycast]&lt;/h2&gt;
&lt;h2 id=&#34;资源建设质量调度成本调度&#34;&gt;[资源建设]&amp;amp;[质量调度]&amp;amp;[成本调度]&lt;/h2&gt;
&lt;h3 id=&#34;资源建设&#34;&gt;资源建设&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;资源匹配
&lt;ul&gt;
&lt;li&gt;就近接入，流量&amp;amp;容量匹配&lt;/li&gt;
&lt;li&gt;按业务类型隔离，服务器资源(qps[cpu] 带宽[网卡])与业务流量匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;质量调度&#34;&gt;质量调度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;探测系统
&lt;ul&gt;
&lt;li&gt;外采：博睿等公司&lt;/li&gt;
&lt;li&gt;自建拨测系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户接入质量
&lt;ul&gt;
&lt;li&gt;正向探测(客户端-&amp;gt;接入ip)&lt;/li&gt;
&lt;li&gt;反向探测(服务端-&amp;gt;客户端)&lt;/li&gt;
&lt;li&gt;质量信号维度
&lt;ul&gt;
&lt;li&gt;运营商 -&amp;gt; 接入点(或ip粒度)：运营商可能有封ip行为&lt;/li&gt;
&lt;li&gt;运营商 -&amp;gt; 接入点(或ip粒度)端口：运营商可能有封端口行为&lt;/li&gt;
&lt;li&gt;省份(区域) -&amp;gt; 接入点(或ip粒度)&lt;/li&gt;
&lt;li&gt;省份*运营商 -&amp;gt; 接入点(或ip粒度)&lt;/li&gt;
&lt;li&gt;省份*运营商 -&amp;gt; 接入点(或ip粒度)端口&lt;/li&gt;
&lt;li&gt;省份&lt;em&gt;运营商&lt;/em&gt;HOST -&amp;gt; 接入点(或ip粒度)：七层业务探测，特定HOST质量分析，一般由业务侧客户端/服务端数据生产而来&lt;/li&gt;
&lt;li&gt;URL?业界目前还没这么细的质量需求，调度上一般也做不到这么细粒度的调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;成本调度&#34;&gt;成本调度&lt;/h3&gt;
&lt;p&gt;低价资源募集
价差调度
削峰填谷&lt;/p&gt;
&lt;h2 id=&#34;回源调度&#34;&gt;[回源调度]&lt;/h2&gt;
&lt;h1 id=&#34;业务类型&#34;&gt;业务类型&lt;/h1&gt;
&lt;h2 id=&#34;下载&#34;&gt;下载&lt;/h2&gt;
&lt;p&gt;压缩
小文件/大文件&lt;/p&gt;
&lt;h2 id=&#34;点播&#34;&gt;点播&lt;/h2&gt;
&lt;h3 id=&#34;流媒体传输&#34;&gt;流媒体传输&lt;/h3&gt;
&lt;p&gt;切片(TS, Transport Stream)
协议支持/优化：HLS,DASH,CMAF,FLV,RTMP&lt;/p&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;h3 id=&#34;图片处理&#34;&gt;图片处理&lt;/h3&gt;
&lt;p&gt;格式转换
裁剪&amp;amp;缩放
有损/无损压缩
渐进式加载(模糊图-&amp;gt;清晰图)
图像特效处理：水印 亮度/对比度等参数调节 旋转 等等&lt;/p&gt;</description>
    </item>
    <item>
      <title>怎么做抖音</title>
      <link>https://skyduck-z.github.io/posts/2025-07-13-%E6%80%8E%E4%B9%88%E5%81%9A%E6%8A%96%E9%9F%B3/</link>
      <pubDate>Sun, 13 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2025-07-13-%E6%80%8E%E4%B9%88%E5%81%9A%E6%8A%96%E9%9F%B3/</guid>
      <description>&lt;p&gt;前段时间面试被提问到，“如果要你做抖音这个产品,你都要考虑哪些技术问题?”  听到这个问题就脑袋瓜子嗡嗡的，我能大概明白这个问题的点(知识面宽度加相关领域深度?)，但是实在是回答的一塌糊涂，今天有充足的时间，再回头来慢慢思考总结下吧。&lt;/p&gt;
&lt;p&gt;分几个方向浅浅来看下吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端&lt;/li&gt;
&lt;li&gt;后端&lt;/li&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;li&gt;存储&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;安全合规&lt;/li&gt;
&lt;li&gt;生态&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;1-前端&#34;&gt;1. 前端&lt;/h1&gt;
&lt;p&gt;这里的前端，语义上主要指用户使用产品的入口，包括有 各类移动端、PC端、浏览器、H5、头部应用生态集成(例如微信小程序)等，这里为了美观、易用、流畅、轻量，可以做大量的工作，不了解，不展开讲&lt;/p&gt;
&lt;h1 id=&#34;2-后端&#34;&gt;2. 后端&lt;/h1&gt;
&lt;p&gt;技术栈庞大实在储备不足，随便写两句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务架构,云原生
&lt;ul&gt;
&lt;li&gt;技术底座：k8s 容器技术&lt;/li&gt;
&lt;li&gt;配置管理：配置中心&lt;/li&gt;
&lt;li&gt;API gateway：统一网关&lt;/li&gt;
&lt;li&gt;中间件：etcd es auth等&lt;/li&gt;
&lt;li&gt;服务拆分：结合产品特性拆分子服务，用户中心、内容中心、评论点赞中心 等&lt;/li&gt;
&lt;li&gt;通信：服务发现 服务网格 消息队列&lt;/li&gt;
&lt;li&gt;治理：可用性 负载均衡(限流、降级、熔断)&lt;/li&gt;
&lt;li&gt;服务发布&amp;amp;部署：镜像治理 交叉编译 CI/CD 弹性扩缩容&lt;/li&gt;
&lt;li&gt;可观测可运维(AIOPS)：日志系统(离线日志 在线日志) trace能力 数据体系(监控告警，数据分析看板)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-网络用户接入&#34;&gt;3. 网络(用户接入)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;端：网络库&lt;/li&gt;
&lt;li&gt;DNS/HTTPDNS(智能调度)&lt;/li&gt;
&lt;li&gt;Unicast/Anycast&lt;/li&gt;
&lt;li&gt;CDN(暂不展开)&lt;/li&gt;
&lt;li&gt;网关
&lt;ul&gt;
&lt;li&gt;四层网关&lt;/li&gt;
&lt;li&gt;七层网关&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议栈优化：TCP调优 UDP调优 QUIC DPDK 零拷贝 无锁 分页&lt;/li&gt;
&lt;li&gt;一些场景
&lt;ul&gt;
&lt;li&gt;PCDN&lt;/li&gt;
&lt;li&gt;弱网优化：协议优化 体验降级(降分辨率&amp;gt;抽帧)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-存储&#34;&gt;4. 存储&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;缓存+持久化存储
&lt;ul&gt;
&lt;li&gt;缓存：命中率 击穿&lt;/li&gt;
&lt;li&gt;持久化：压缩 分库分表 读写分离 ACID 分布式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关系型数据库vs非关系型数据库&lt;/li&gt;
&lt;li&gt;对象存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-算法&#34;&gt;5. 算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;压缩算法&lt;/li&gt;
&lt;li&gt;视频算法：视频编解码算法优化&lt;/li&gt;
&lt;li&gt;调度算法：贪心 稳定匹配 其他？&lt;/li&gt;
&lt;li&gt;推荐算法：用户画像 内容标签 多阶段递进式 召回+排序(粗排&amp;amp;精排)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-安全合规&#34;&gt;6. 安全合规&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;内容安全：bot 抽帧审核&lt;/li&gt;
&lt;li&gt;网络安全：synflood ddos sql注入 等攻击防护&lt;/li&gt;
&lt;li&gt;合规：不太了解&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7-生态&#34;&gt;7. 生态&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;开发者平台&lt;/li&gt;
&lt;li&gt;增值服务：例如抖音衍生出的剪映&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写在最后：其实上述就是浅浅的概括一些点，冷静思考都能想到的问题，但是如果平时不做思考很难能在第一时间按这个全局的思路讲清楚；总-分的结构来看，上述内容思路清晰的说出来，再把岗位相关的技术细节展开来深入讲解和交流，那么应该就能给人一个很好的体验，还是重在平时的积累和思考吧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>相似度</title>
      <link>https://skyduck-z.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/</guid>
      <description>&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;用于衡量多个对象（如文本、数值向量、图像、序列等）之间相似程度的数学方法。&lt;/p&gt;
&lt;p&gt;在计算机领域，通常将 “相似性” 转化为可计算的数值（例如 0~1 表示，1代表完全相似，0代表完全不相似）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;的应用十分广泛，例如推荐系统（如商品/内容推荐）、数据挖掘（如聚类、分类）、NLP（如文本查重、语义匹配）、图像识别等。&lt;/p&gt;
&lt;h1 id=&#34;文本相似度&#34;&gt;文本相似度&lt;/h1&gt;
&lt;h2 id=&#34;基于字符词频&#34;&gt;基于字符/词频&lt;/h2&gt;
&lt;p&gt;不依赖语义理解，仅从文本的字符或词语出现频率出发计算相似性，适合简单的短文本内容的场景。&lt;/p&gt;
&lt;h3 id=&#34;jaccard-系数杰卡德相似度&#34;&gt;Jaccard 系数（杰卡德相似度）&lt;/h3&gt;
&lt;p&gt;思路：将文本视为 “词语集合”（忽略词频和顺序），&lt;code&gt;相似性 = 两个集合的交集大小 / 两个集合的并集大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，sim(“小明球技很棒” &amp;amp; “小明球技真好”) = len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo;)/len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo;) = 0.5&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词频没有统计&lt;/li&gt;
&lt;li&gt;语义不做理解，&amp;ldquo;真好&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; 其实语义接近&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;余弦相似度cosine-similarity&#34;&gt;余弦相似度（Cosine Similarity）&lt;/h3&gt;
&lt;p&gt;思路：将文本转换为词频向量，&lt;code&gt;相似性 = 两个向量夹角余弦值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，(“小明球技很棒啊，小明不错” &amp;amp; “小明球技真好”)，构建&lt;code&gt;词袋&lt;/code&gt;=[&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo; &amp;ldquo;不错&amp;rdquo;]，对于词袋，计算向量值，“小明球技很棒”的词频向量A = [2,1,1,0,1]，“小明球技真好”的词频向量B = [1,1,0,1,0]，则 &lt;code&gt;相似性 = cos(A,B) = (A*B)/(||A||*||B||) = (2+1+0+0+0)/(√7*√3) = 3/√21 = 0.66&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;考虑了词频，长文本理解更准确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义还是没有理解&lt;/li&gt;
&lt;li&gt;高频无意义词，如“的” “地”等影响较大，需过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 常用的相似性判定方法主要通过 向量夹角余弦值(&lt;code&gt;向量点积/向量模乘积&lt;/code&gt;)
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;cos&lt;/mi&gt;
&lt;mi&gt;θ&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mfrac&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;/mrow&gt;
&lt;mrow&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;mo&gt;×&lt;/mo&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;/mfrac&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\cos\theta = \frac{\sum_{i=1}^n A_iB_i}{\sqrt{\sum_{i=1}^n A_i^2} \times \sqrt{\sum_{i=1}^n B_i^2}}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
or 向量间欧式距离
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;d&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;msqrt&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;mrow&gt;
&lt;mi&gt;(&lt;/mi&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mo&gt;-&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mi&gt;)&lt;/mi&gt;
&lt;/mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/mrow&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d = \sqrt{\sum_{i=1}^n (x_{2i} - x_{1i})^2}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
计算获得&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件架构设计原则</title>
      <link>https://skyduck-z.github.io/posts/2023-04-16-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2023-04-16-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;p&gt;每次接手一些老旧系统，总是很头疼，最近想，会不会别人接手了我的系统以后也是一样的感受，想到可能有人每天都在吐槽(骂)我头皮发麻啊&amp;hellip;&lt;/p&gt;
&lt;p&gt;知易行难，其实怎么做好一个后端服务大家都是门清的，只是受限于 &lt;code&gt;排期&lt;/code&gt; &lt;code&gt;业务价值&lt;/code&gt; &lt;code&gt;协作&lt;/code&gt; 等太多因素，往往事与愿违。只能说但行好事莫问前程吧，下面再把这些原则列一下，时刻提醒自己吧；以下原则从个人角度分先后，不是说有重要性区别，而是有些原则很高频，或者很容易被忽略，需要时刻牢记。&lt;/p&gt;
&lt;h1 id=&#34;一-职责逻辑-清晰&#34;&gt;一 职责/逻辑 清晰&lt;/h1&gt;
&lt;h2 id=&#34;单一职责原则single-responsibility-principle-srp&#34;&gt;单一职责原则（Single Responsibility Principle, SRP）&lt;/h2&gt;
&lt;p&gt;每个&lt;code&gt;单元&lt;/code&gt;只负责&lt;em&gt;一件事&lt;/em&gt;。
从总体架构上讲，这个单元是一个子系统，例如订单系统，日志系统；从系统架构上讲，这个单元是一个模块，例如文章管理模块，评论管理模块等；从代码模块内部讲，这个单元是一个组件，一个类，一个struct等。再往下看，一个类还有N多个方法&amp;hellip;
就像分子，原子，质子/电子，夸克&amp;hellip;从宏观到微观的过程，就是我们把一套复杂的系统一点一点拆解开的过程，而每次向下拆解一层的时候，这一层的个体，尽量做到每个都负责一件事&lt;/p&gt;
&lt;h2 id=&#34;迪米特法则law-of-demeter-lod&#34;&gt;迪米特法则（Law of Demeter, LoD）&lt;/h2&gt;
&lt;p&gt;一个模块应尽可能少地了解其他模块的内部细节。
反过来看，一个模块向外不暴露细节，别人就没法了解细节了；所以还是在讲控制耦合。&lt;/p&gt;
&lt;h2 id=&#34;高内聚低耦合high-cohesion-low-coupling&#34;&gt;高内聚，低耦合（High Cohesion, Low Coupling）&lt;/h2&gt;
&lt;p&gt;模块内部的功能紧密相关(高内聚)，模块间通过明确接口交互，依赖关系简单(低耦合)。
明牌了，直接再提醒你一下，控制耦合控制耦合控制耦合&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;接口隔离原则interface-segregation-principle-isp&#34;&gt;接口隔离原则（Interface Segregation Principle, ISP）&lt;/h2&gt;
&lt;p&gt;客户端不应被迫依赖它不需要的接口，应将大接口拆分为多个专用小接口。
这里不是对使用者的要求，而是对接口提供(设计)者提出要求，在设计对外暴露接口时，要尽可能小，单一，独立，这样使用起来更灵活。
对外是这样的，但是内部接口，说实话我做不到尽可能小。&lt;/p&gt;
&lt;h1 id=&#34;二-破坏性侵入性控制&#34;&gt;二 破坏性(侵入性)控制&lt;/h1&gt;
&lt;h2 id=&#34;开闭原则open-closed-principle-ocp&#34;&gt;开闭原则（Open-Closed Principle, OCP）&lt;/h2&gt;
&lt;p&gt;对扩展开放，对修改关闭。
从我的理解，这条原则更多还是在指导代码层面的设计；世界是动态发展的，没有一成不变的东西，那么对于代码，可扩展是必然的需求，那为什么对修改关闭呢？可能更多还是对原系统的侵入吧，你不知道你的使用方对你做出了怎么样的假设，总之目前为止世界和平，但当你修改了你的行为，假设被打破，世界就崩塌了&lt;/p&gt;
&lt;h2 id=&#34;里氏替换原则liskov-substitution-principle-lsp&#34;&gt;里氏替换原则（Liskov Substitution Principle, LSP）&lt;/h2&gt;
&lt;p&gt;子类必须能无缝替换父类，且不破坏原有系统的正确性。即父类出现的地方，子类可替代，且行为一致。&lt;/p&gt;
&lt;h1 id=&#34;三-依赖管理&#34;&gt;三 依赖管理&lt;/h1&gt;
&lt;h2 id=&#34;分层架构原则layered-architecture-principle&#34;&gt;分层架构原则（Layered Architecture Principle）&lt;/h2&gt;
&lt;p&gt;将系统按职责划分为清晰的层次，层间单向依赖，禁止跨层调用。&lt;/p&gt;
&lt;h2 id=&#34;依赖倒置原则dependency-inversion-principle-dip&#34;&gt;依赖倒置原则（Dependency Inversion Principle, DIP）&lt;/h2&gt;
&lt;p&gt;高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。&lt;/p&gt;
&lt;h1 id=&#34;四-可扩展性&#34;&gt;四 可扩展性&lt;/h1&gt;
&lt;h2 id=&#34;演进式架构原则evolutionary-architecture&#34;&gt;演进式架构原则（Evolutionary Architecture）&lt;/h2&gt;
&lt;p&gt;架构设计应预留扩展空间，支持系统随业务需求逐步演进，而非追求 “一步到位” 的完美设计。&lt;/p&gt;
&lt;h1 id=&#34;五-安全代码安全服务安全业务安全等&#34;&gt;五 安全(代码安全，服务安全，业务安全等)&lt;/h1&gt;
&lt;h2 id=&#34;安全性原则security-by-design&#34;&gt;安全性原则（Security by Design）&lt;/h2&gt;
&lt;p&gt;将安全性嵌入架构设计的每个环节，而非事后补丁。&lt;/p&gt;</description>
    </item>
    <item>
      <title>happens-before</title>
      <link>https://skyduck-z.github.io/posts/2021-08-19-happens-before/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2021-08-19-happens-before/</guid>
      <description>&lt;p&gt;在并发系统中，用于描述事件执行顺序关系；若事件A &amp;ldquo;happens-before&amp;rdquo; 事件B，则A的执行结果对B可见，且A在逻辑上先于B执行(并不要求在物理时间上A必须先于B执行)。&lt;/p&gt;
&lt;p&gt;所以这其实是一种逻辑关系，在并发系统中，P1 P2 两个过程在逻辑上&amp;quot;同时&amp;quot;在执行，P2过程中的事件B依赖P1过程中的事件A的结果，那么就需要逻辑上的 &amp;ldquo;happens-before&amp;rdquo; 来确保A&amp;amp;B间的依赖关系。&lt;/p&gt;
&lt;p&gt;常见的并发模型 &lt;strong&gt;共享内存&lt;/strong&gt; 和 &lt;strong&gt;消息传递&lt;/strong&gt;，都遵循 &amp;ldquo;happens-before&amp;quot;逻辑，消息传递中的happens-before好理解，消息的传入肯定是在消息的接收之前的，在共享内存模型的并发中，happens-before就是帮助我们在逻辑上自洽，理清楚不同并发单元(线程 协程 等)对某一个共享内存变量的操作顺序。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DNS</title>
      <link>https://skyduck-z.github.io/posts/2021-05-13-dns/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      <guid>https://skyduck-z.github.io/posts/2021-05-13-dns/</guid>
      <description>&lt;h1 id=&#34;dns&#34;&gt;DNS？&lt;/h1&gt;
&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。&lt;/li&gt;
&lt;li&gt;cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源&lt;/li&gt;
&lt;li&gt;forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。&lt;/li&gt;
&lt;li&gt;CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15
&lt;ul&gt;
&lt;li&gt;A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns做什么&#34;&gt;DNS做什么&lt;/h2&gt;
&lt;p&gt;ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。&lt;/p&gt;
&lt;p&gt;主机名的解析有一个发展的过程。&lt;/p&gt;
&lt;p&gt;最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。&lt;/p&gt;
&lt;p&gt;这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。&lt;/p&gt;
&lt;p&gt;这种方式问题很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）&lt;/li&gt;
&lt;li&gt;例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。&lt;/p&gt;
&lt;h2 id=&#34;bindberkeley-internet-name-domain&#34;&gt;BIND，Berkeley Internet Name Domain&lt;/h2&gt;
&lt;h3 id=&#34;bind管理方式&#34;&gt;BIND管理方式&lt;/h3&gt;
&lt;p&gt;BIND是一套阶层式的管理主机名与IP对应关系的系统。&lt;/p&gt;
&lt;p&gt;阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://skyduck-z.github.io/images/dns/1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;以www.baidu.com为例，最上层根服务器，domain name是&amp;quot;.&amp;quot;，然后有三个hostname &amp;ldquo;net com cn&amp;rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个&amp;quot;.&amp;ldquo;都拆分domain name&amp;amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。&lt;/p&gt;
&lt;p&gt;DNS阶层系统的最上方是一个&amp;rdquo;.&amp;quot;，root，是根服务器，本质上讲，这里的&amp;quot;.&amp;ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。&lt;/p&gt;
&lt;p&gt;每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&amp;rdquo;.&amp;quot;)；同一层内不允许同名，确保唯一性。&lt;/p&gt;
&lt;h3 id=&#34;bind查询流程&#34;&gt;BIND查询流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当浏览器输入 &lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt; ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录&lt;/li&gt;
&lt;li&gt;client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？
&lt;ul&gt;
&lt;li&gt;其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧&lt;/li&gt;
&lt;li&gt;然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果&lt;/li&gt;
&lt;li&gt;.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧
&lt;ul&gt;
&lt;li&gt;.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://skyduck-z.github.io/images/dns/2.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
