<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2022 on Duck</title>
    <link>https://duck-dd.github.io/tags/2022/</link>
    <description>Recent content in 2022 on Duck</description>
    <image>
      <title>Duck</title>
      <url>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Wed, 13 Apr 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://duck-dd.github.io/tags/2022/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang select case机会均等</title>
      <link>https://duck-dd.github.io/posts/2022-04-13-golang-select-case%E6%9C%BA%E4%BC%9A%E5%9D%87%E7%AD%89/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2022-04-13-golang-select-case%E6%9C%BA%E4%BC%9A%E5%9D%87%E7%AD%89/</guid>
      <description>&lt;h1 id=&#34;验证&#34;&gt;验证&lt;/h1&gt;
&lt;p&gt;我们每天都在使用下面这样的用法，对于这种多条件分支判定，我们从来不会指定权重，按固有思维，多条件间应该是机会均等的，那么golang如何做的呢？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select {
case &amp;lt;-ch1:
    do sth
case &amp;lt;-ch2:
    do sth
case &amp;lt;-ch3:
    do sth
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们先来看看到底是不是机会均等的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import(&amp;#34;fmt&amp;#34;)

func main() {
	sum1, sum2, sum3 := 0, 0, 0
	for loop:=0; loop&amp;lt;8 ; loop++ {
		count1, count2, count3 := 0, 0, 0
		ch1, ch2, ch3 := make(chan int), make(chan int), make(chan int)
		go func(){for { ch1&amp;lt;-1 }}()
		go func(){for { ch2&amp;lt;-1 }}()
		go func(){for { ch3&amp;lt;-1 }}()
		for i := 0; i &amp;lt; 10000; i++ {
			select {
			case &amp;lt;-ch1:
				count1++
				sum1++
			case &amp;lt;-ch2:
				count2++
				sum2++
			case &amp;lt;-ch3:
				count3++
				sum3++
			}
		}
		fmt.Println(&amp;#34;loop &amp;#34;, loop+1, &amp;#34;: &amp;#34;, count1, count2, count3)
	}
	fmt.Println(&amp;#34;sum: &amp;#34;, sum1, sum2, sum3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;结果:

loop  1 :  1535 5446 3019
loop  2 :  1607 5004 3389
loop  3 :  1146 3549 5305
loop  4 :  4100 2601 3299
loop  5 :  5938 2260 1802
loop  6 :  923 1268 7809
loop  7 :  4958 2273 2769
loop  8 :  3162 3432 3406
sum:  23369 25833 30798
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;诶，好像不太对啊，尤其&lt;code&gt;loop 7&lt;/code&gt;，偏差到飞起了啊&amp;hellip;总量的偏差也大的离谱&amp;hellip;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
