<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CS | skyduck</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content><link rel=canonical href=https://skyduck-z.github.io/categories/cs/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://skyduck-z.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://skyduck-z.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://skyduck-z.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://skyduck-z.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://skyduck-z.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://skyduck-z.github.io/categories/cs/index.xml><link rel=alternate hreflang=en href=https://skyduck-z.github.io/categories/cs/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://skyduck-z.github.io/categories/cs/"><meta property="og:site_name" content="skyduck"><meta property="og:title" content="CS"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://skyduck-z.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://skyduck-z.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CS"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://skyduck-z.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://skyduck-z.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://skyduck-z.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://skyduck-z.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://skyduck-z.github.io/about_me title=关于我><span>关于我</span></a></li><li><a href=https://skyduck-z.github.io/about_space title=关于这里><span>关于这里</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://skyduck-z.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://skyduck-z.github.io/categories/>Categories</a></div><h1>CS
<a href=/categories/cs/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>过滤器 - 布隆家族</h2></header><div class=entry-content><p>TBD.</p></div><footer class=entry-footer><span title='2025-12-21 00:00:00 +0000 UTC'>2025-12-21</span>&nbsp;·&nbsp;创建于:&nbsp;2025-12-21&nbsp;·&nbsp;1 min&nbsp;·&nbsp;word</footer><a class=entry-link aria-label="post link to 过滤器 - 布隆家族" href=https://skyduck-z.github.io/posts/2025-12-21-%E8%BF%87%E6%BB%A4%E5%99%A8---%E5%B8%83%E9%9A%86%E5%AE%B6%E6%97%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GMP温故知新</h2></header><div class=entry-content><p>TBD.</p></div><footer class=entry-footer><span title='2025-12-20 00:00:00 +0000 UTC'>2025-12-20</span>&nbsp;·&nbsp;创建于:&nbsp;2025-12-20&nbsp;·&nbsp;1 min&nbsp;·&nbsp;word</footer><a class=entry-link aria-label="post link to GMP温故知新" href=https://skyduck-z.github.io/posts/2025-12-20-gmp%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CDN</h2></header><div class=entry-content><p>什么是CDN CDN，Content Delivery Network，内容分发网络，是构建在基础网络之上的一层"智能分布式网络"
CDN的流量接入 节点 L1(边缘节点) L2 L3 源站 缓存 命中率&回源带宽 存储模型 内存淘汰算法 调度 [DNS]&[Anycast] [资源建设]&[质量调度]&[成本调度] 资源建设 资源匹配 就近接入，流量&容量匹配 按业务类型隔离，服务器资源(qps[cpu] 带宽[网卡])与业务流量匹配 质量调度 探测系统 外采：博睿等公司 自建拨测系统 用户接入质量 正向探测(客户端->接入ip) 反向探测(服务端->客户端) 质量信号维度 运营商 -> 接入点(或ip粒度)：运营商可能有封ip行为 运营商 -> 接入点(或ip粒度)端口：运营商可能有封端口行为 省份(区域) -> 接入点(或ip粒度) 省份*运营商 -> 接入点(或ip粒度) 省份*运营商 -> 接入点(或ip粒度)端口 省份运营商HOST -> 接入点(或ip粒度)：七层业务探测，特定HOST质量分析，一般由业务侧客户端/服务端数据生产而来 URL?业界目前还没这么细的质量需求，调度上一般也做不到这么细粒度的调度 成本调度 低价资源募集 价差调度 削峰填谷
[回源调度] 业务类型 下载 压缩 小文件/大文件
点播 流媒体传输 切片(TS, Transport Stream) 协议支持/优化：HLS,DASH,CMAF,FLV,RTMP
图片 图片处理 格式转换 裁剪&缩放 有损/无损压缩 渐进式加载(模糊图->清晰图) 图像特效处理：水印 亮度/对比度等参数调节 旋转 等等
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0000 UTC'>2025-07-13</span>&nbsp;·&nbsp;创建于:&nbsp;2025-07-13&nbsp;·&nbsp;1 min&nbsp;·&nbsp;113 words</footer><a class=entry-link aria-label="post link to CDN" href=https://skyduck-z.github.io/posts/2025-07-13-cdn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>怎么做抖音</h2></header><div class=entry-content><p>前段时间面试被提问到，“如果要你做抖音这个产品,你都要考虑哪些技术问题?” 听到这个问题就脑袋瓜子嗡嗡的，我能大概明白这个问题的点(知识面宽度加相关领域深度?)，但是实在是回答的一塌糊涂，今天有充足的时间，再回头来慢慢思考总结下吧。
分几个方向浅浅来看下吧：
前端 后端 网络 存储 算法 安全合规 生态 1. 前端 这里的前端，语义上主要指用户使用产品的入口，包括有 各类移动端、PC端、浏览器、H5、头部应用生态集成(例如微信小程序)等，这里为了美观、易用、流畅、轻量，可以做大量的工作，不了解，不展开讲
2. 后端 技术栈庞大实在储备不足，随便写两句
微服务架构,云原生 技术底座：k8s 容器技术 配置管理：配置中心 API gateway：统一网关 中间件：etcd es auth等 服务拆分：结合产品特性拆分子服务，用户中心、内容中心、评论点赞中心 等 通信：服务发现 服务网格 消息队列 治理：可用性 负载均衡(限流、降级、熔断) 服务发布&部署：镜像治理 交叉编译 CI/CD 弹性扩缩容 可观测可运维(AIOPS)：日志系统(离线日志 在线日志) trace能力 数据体系(监控告警，数据分析看板) 3. 网络(用户接入) 端：网络库 DNS/HTTPDNS(智能调度) Unicast/Anycast CDN(暂不展开) 网关 四层网关 七层网关 协议栈优化：TCP调优 UDP调优 QUIC DPDK 零拷贝 无锁 分页 一些场景 PCDN 弱网优化：协议优化 体验降级(降分辨率>抽帧) 4. 存储 缓存+持久化存储 缓存：命中率 击穿 持久化：压缩 分库分表 读写分离 ACID 分布式 关系型数据库vs非关系型数据库 对象存储 5. 算法 压缩算法 视频算法：视频编解码算法优化 调度算法：贪心 稳定匹配 其他？ 推荐算法：用户画像 内容标签 多阶段递进式 召回+排序(粗排&精排) 6. 安全合规 内容安全：bot 抽帧审核 网络安全：synflood ddos sql注入 等攻击防护 合规：不太了解 7. 生态 开源 开发者平台 增值服务：例如抖音衍生出的剪映 写在最后：其实上述就是浅浅的概括一些点，冷静思考都能想到的问题，但是如果平时不做思考很难能在第一时间按这个全局的思路讲清楚；总-分的结构来看，上述内容思路清晰的说出来，再把岗位相关的技术细节展开来深入讲解和交流，那么应该就能给人一个很好的体验，还是重在平时的积累和思考吧。
...</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0000 UTC'>2025-07-13</span>&nbsp;·&nbsp;创建于:&nbsp;2025-07-13&nbsp;·&nbsp;1 min&nbsp;·&nbsp;99 words</footer><a class=entry-link aria-label="post link to 怎么做抖音" href=https://skyduck-z.github.io/posts/2025-07-13-%E6%80%8E%E4%B9%88%E5%81%9A%E6%8A%96%E9%9F%B3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MCMF from scratch</h2></header><div class=entry-content><p>需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。 记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。
MCMF概念 Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：
有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；
求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量
在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。
最大流问题 最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。
第一印象 简单描述，有向有权图，起点s，终点t，我们要寻找s->t的最大的流量。 那么朴素的第一印象来看，暴力呗，BFS把所有s->t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边->剩余容量)，结束后得到一个总的流量值。 提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。 好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：
图1 blocking-flow(黑色数字=容量,红色数字=流量) 如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。 结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。
那么如何修正能够确保准确的找到最大流呢？
再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度) 前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈) 我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的 那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了 Ford-Fulkerson 一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。 从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。 但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径) 不是的，还是用图1左举例，他的residual graph如下：
图2 图1左部的residual-graph 图2中，我们可以继续找到这样一条路径s->v2->v4->v1->v3->t 流量=1，其中v4->v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。 那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s—>t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。
...</p></div><footer class=entry-footer><span title='2025-06-24 00:00:00 +0000 UTC'>2025-06-24</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-24&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words</footer><a class=entry-link aria-label="post link to MCMF from scratch" href=https://skyduck-z.github.io/posts/2025-06-24-mcmf/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>The Shortest Path</h2></header><div class=entry-content><p>最短路径问题 寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小
1 无权图最短路径 所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。
2 单源最短路径(SSSP, Single-Source Shortest Paths) 2.1 Dijkstra(堆优化) 限制：边权非负 思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径 步骤 初始化： 源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞) 所有节点标记为未访问 循环处理： 从未访问节点中选择距离最小的节点u，标记为已访问 对u的每个邻接节点v，进行 松弛操作: if distance[v] > distance[u] + weight(u, v): distance[v] = distance[u] + weight(u, v) predecessor[v] = u # 记录路径 终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点） 优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV) 记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序) 算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点 2.2 Bellman-Ford 限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小) 思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v] 步骤 初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞ 弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解) 检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环 优化：下面的SPFA 算法正确性理解：n个节点，那么起点到终点路径最长就是 1->2->3->...->n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成 2.3 SPFA, Shortest Path Faster Algorithm SPFA其实只是Bellman-Ford的筛选优化，本质相同
...</p></div><footer class=entry-footer><span title='2025-06-23 00:00:00 +0000 UTC'>2025-06-23</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-23&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words</footer><a class=entry-link aria-label="post link to The Shortest Path" href=https://skyduck-z.github.io/posts/2025-06-23-shortest-path/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>go tips(持续更新)</h2></header><div class=entry-content><p>有很多从其他大佬的总结中抄来的，不注明出处了
会记录一些:
有意义的小操作(可能有些比较tricky) 容易理解偏差的点 日常开发低频使用的知识点 golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。
了解更多可查看Golang内存模型规范。
golang内存对齐 内存对齐：数据在内存中的存储位置必须是特定字节数的倍数
CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问 golang内存对齐：
基础类型：通常是其自身大小（如int32为4字节，int64为8字节） 结构体 每个字段按各自的对齐系数作对齐 结构体自身的对齐系数为所有字段中最大的对齐系数 数组：与元素类型的对齐系数相同 例：
type demo1 struct { a int8 b int16 c int32 } type demo2 struct { a int8 c int32 b int16 } type demo3 struct { a int8 c int32 b int16 d int16 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) // 8 fmt.Println(unsafe.Sizeof(demo2{})) // 12 fmt.Println(unsafe.Sizeof(demo3{})) // 12 } demo1:
a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节 c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可 demo2:
...</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;创建于:&nbsp;2021-07-01&nbsp;·&nbsp;25 min&nbsp;·&nbsp;5264 words</footer><a class=entry-link aria-label="post link to go tips(持续更新)" href=https://skyduck-z.github.io/posts/2025-06-22-go-tips%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>相似度</h2></header><div class=entry-content><p>相似度算法用于衡量多个对象（如文本、数值向量、图像、序列等）之间相似程度的数学方法。
在计算机领域，通常将 “相似性” 转化为可计算的数值（例如 0~1 表示，1代表完全相似，0代表完全不相似）。
相似度算法的应用十分广泛，例如推荐系统（如商品/内容推荐）、数据挖掘（如聚类、分类）、NLP（如文本查重、语义匹配）、图像识别等。
文本相似度 基于字符/词频 不依赖语义理解，仅从文本的字符或词语出现频率出发计算相似性，适合简单的短文本内容的场景。
Jaccard 系数（杰卡德相似度） 思路：将文本视为 “词语集合”（忽略词频和顺序），相似性 = 两个集合的交集大小 / 两个集合的并集大小
举个例子，sim(“小明球技很棒” & “小明球技真好”) = len(“小明” “球技”)/len(“小明” “球技” “很棒” “真好”) = 0.5
优点
简单 缺点
词频没有统计 语义不做理解，“真好” “很棒” 其实语义接近 余弦相似度（Cosine Similarity） 思路：将文本转换为词频向量，相似性 = 两个向量夹角余弦值
举个例子，(“小明球技很棒啊，小明不错” & “小明球技真好”)，构建词袋=[“小明” “球技” “很棒” “真好” “不错”]，对于词袋，计算向量值，“小明球技很棒”的词频向量A = [2,1,1,0,1]，“小明球技真好”的词频向量B = [1,1,0,1,0]，则 相似性 = cos(A,B) = (A*B)/(||A||*||B||) = (2+1+0+0+0)/(√7*√3) = 3/√21 = 0.66
优点
简单 考虑了词频，长文本理解更准确 缺点
语义还是没有理解 高频无意义词，如“的” “地”等影响较大，需过滤 PS： 常用的相似性判定方法主要通过 向量夹角余弦值(向量点积/向量模乘积) cos θ = ∑ i = 1 n A i B i ∑ i = 1 n A i 2 × ∑ i = 1 n B i 2 \cos\theta = \frac{\sum_{i=1}^n A_iB_i}{\sqrt{\sum_{i=1}^n A_i^2} \times \sqrt{\sum_{i=1}^n B_i^2}} or 向量间欧式距离 d = ∑ i = 1 n ( x 2 i - x 1 i ) 2 d = \sqrt{\sum_{i=1}^n (x_{2i} - x_{1i})^2} 计算获得
...</p></div><footer class=entry-footer><span title='2025-06-03 00:00:00 +0000 UTC'>2025-06-03</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-03&nbsp;·&nbsp;2 min&nbsp;·&nbsp;240 words</footer><a class=entry-link aria-label="post link to 相似度" href=https://skyduck-z.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>golang singleflight</h2></header><div class=entry-content><p>高并发场景下，有时我们很多并发goroutine内有逻辑重合，可能拉了数据库同一张表的数据，可能拉了同一个远程图片，这些数据通常是偏静态的，那么没有必要在每个goroutine内部都做这个操作，可能会拉高上游服务的负载，可能会影响本地的执行效率，可能会浪费本地的网卡资源等。
通常我们会依赖缓存来解决这个问题，这也确实是行之有效的；但是golang并发场景也给了我们更简便的实现方法：golang.org/x/sync/singleflight。
如下面的例子，doSth有2s的Sleep模拟执行过程；我们分了两组for+routine，中间有1s的Sleep，确保第一个发起doSth的index是可控的，然后我们看到输出实际doSth只执行了一次，所有routine共享了同一份结果。 PS：所有的shared返回值都是true，可能并不是大脑第一印象的第一个实际执行者是false，其他人是true
package main import ( "fmt" "sync" "sync/atomic" "time" "golang.org/x/sync/singleflight" ) func doSth(index int) (any, error) { time.Sleep(2 * time.Second) return fmt.Sprintf("result_%d", index), nil } func main() { var g singleflight.Group var wg sync.WaitGroup var doCount int32 for i := 100; i &lt; 101; i++ { wg.Add(1) index := i go func() { defer wg.Done() ret, err, shared := g.Do("key", func() (interface{}, error) { atomic.AddInt32(&amp;doCount, 1) v,e := doSth(index) fmt.Printf("index:%d, v: %v, err: %v\n", index, v, e) return v,e }) fmt.Printf("index:%d, ret:%v, shared:%v, err:%v\n", index, ret, shared, err) }() } time.Sleep(time.Second) for i := 0; i &lt; 5; i++ { wg.Add(1) index := i go func() { defer wg.Done() ret, err, shared := g.Do("key", func() (interface{}, error) { atomic.AddInt32(&amp;doCount, 1) v,e := doSth(index) fmt.Printf("index:%d, v: %v, err: %v\n", index, v, e) return v,e }) fmt.Printf("index:%d, ret:%v, shared:%v, err:%v\n", index, ret, shared, err) }() } wg.Wait() fmt.Printf("实际执行次数: %d\n", doCount) } ------ output: index:100, v: result_100, err: &lt;nil> index:100, ret:result_100, shared:true, err:&lt;nil> index:0, ret:result_100, shared:true, err:&lt;nil> index:4, ret:result_100, shared:true, err:&lt;nil> index:2, ret:result_100, shared:true, err:&lt;nil> index:3, ret:result_100, shared:true, err:&lt;nil> index:1, ret:result_100, shared:true, err:&lt;nil> 实际执行次数: 1 真正发起共享的函数Do入参是有key的，我们把key做个替换，会发现不同key之间不共享，如下：
...</p></div><footer class=entry-footer><span title='2025-04-05 00:00:00 +0000 UTC'>2025-04-05</span>&nbsp;·&nbsp;创建于:&nbsp;2025-04-05&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words</footer><a class=entry-link aria-label="post link to golang singleflight" href=https://skyduck-z.github.io/posts/2025-04-05-golang-singleflight/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>软件架构设计原则</h2></header><div class=entry-content><p>每次接手一些老旧系统，总是很头疼，最近想，会不会别人接手了我的系统以后也是一样的感受，想到可能有人每天都在吐槽(骂)我头皮发麻啊…
知易行难，其实怎么做好一个后端服务大家都是门清的，只是受限于 排期 业务价值 协作 等太多因素，往往事与愿违。只能说但行好事莫问前程吧，下面再把这些原则列一下，时刻提醒自己吧；以下原则从个人角度分先后，不是说有重要性区别，而是有些原则很高频，或者很容易被忽略，需要时刻牢记。
一 职责/逻辑 清晰 单一职责原则（Single Responsibility Principle, SRP） 每个单元只负责一件事。 从总体架构上讲，这个单元是一个子系统，例如订单系统，日志系统；从系统架构上讲，这个单元是一个模块，例如文章管理模块，评论管理模块等；从代码模块内部讲，这个单元是一个组件，一个类，一个struct等。再往下看，一个类还有N多个方法… 就像分子，原子，质子/电子，夸克…从宏观到微观的过程，就是我们把一套复杂的系统一点一点拆解开的过程，而每次向下拆解一层的时候，这一层的个体，尽量做到每个都负责一件事
迪米特法则（Law of Demeter, LoD） 一个模块应尽可能少地了解其他模块的内部细节。 反过来看，一个模块向外不暴露细节，别人就没法了解细节了；所以还是在讲控制耦合。
高内聚，低耦合（High Cohesion, Low Coupling） 模块内部的功能紧密相关(高内聚)，模块间通过明确接口交互，依赖关系简单(低耦合)。 明牌了，直接再提醒你一下，控制耦合控制耦合控制耦合…
接口隔离原则（Interface Segregation Principle, ISP） 客户端不应被迫依赖它不需要的接口，应将大接口拆分为多个专用小接口。 这里不是对使用者的要求，而是对接口提供(设计)者提出要求，在设计对外暴露接口时，要尽可能小，单一，独立，这样使用起来更灵活。 对外是这样的，但是内部接口，说实话我做不到尽可能小。
二 破坏性(侵入性)控制 开闭原则（Open-Closed Principle, OCP） 对扩展开放，对修改关闭。 从我的理解，这条原则更多还是在指导代码层面的设计；世界是动态发展的，没有一成不变的东西，那么对于代码，可扩展是必然的需求，那为什么对修改关闭呢？可能更多还是对原系统的侵入吧，你不知道你的使用方对你做出了怎么样的假设，总之目前为止世界和平，但当你修改了你的行为，假设被打破，世界就崩塌了
里氏替换原则（Liskov Substitution Principle, LSP） 子类必须能无缝替换父类，且不破坏原有系统的正确性。即父类出现的地方，子类可替代，且行为一致。
三 依赖管理 分层架构原则（Layered Architecture Principle） 将系统按职责划分为清晰的层次，层间单向依赖，禁止跨层调用。
依赖倒置原则（Dependency Inversion Principle, DIP） 高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。
四 可扩展性 演进式架构原则（Evolutionary Architecture） 架构设计应预留扩展空间，支持系统随业务需求逐步演进，而非追求 “一步到位” 的完美设计。
五 安全(代码安全，服务安全，业务安全等) 安全性原则（Security by Design） 将安全性嵌入架构设计的每个环节，而非事后补丁。
...</p></div><footer class=entry-footer><span title='2023-04-16 00:00:00 +0000 UTC'>2023-04-16</span>&nbsp;·&nbsp;创建于:&nbsp;2023-04-16&nbsp;·&nbsp;1 min&nbsp;·&nbsp;71 words</footer><a class=entry-link aria-label="post link to 软件架构设计原则" href=https://skyduck-z.github.io/posts/2023-04-16-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://skyduck-z.github.io/categories/cs/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://skyduck-z.github.io/>skyduck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>