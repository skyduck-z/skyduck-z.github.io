<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Duck</title>
    <link>https://duck-dd.github.io/posts/</link>
    <description>Recent content in Posts on Duck</description>
    <image>
      <title>Duck</title>
      <url>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Nov 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://duck-dd.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>不靠运气赚钱? 选择vs决策</title>
      <link>https://duck-dd.github.io/posts/2025-11-16-%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E8%B5%9A%E9%92%B1/</link>
      <pubDate>Sun, 16 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-11-16-%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E8%B5%9A%E9%92%B1/</guid>
      <description>&lt;p&gt;今天看到一篇软文，引起我共鸣的点是：“你什么时候才能不靠运气赚钱？”&lt;/p&gt;
&lt;p&gt;说，A B两个人每个月都能赚1000块钱，A靠运气，B靠思路，区别是什么呢？区别在于A的未来充满了不确定，而B未来还会有更高的成就，可能就能够赚2000块钱了。&lt;/p&gt;
&lt;p&gt;那么这时候有老铁就要问了，到底什么叫&lt;strong&gt;靠运气&lt;/strong&gt;？引申出一个比较，&lt;code&gt;选择vs决策&lt;/code&gt;，&lt;code&gt;选择&lt;/code&gt;就是靠运气，&lt;code&gt;决策&lt;/code&gt;则不是；在与&lt;code&gt;决策&lt;/code&gt;语境对比下的&lt;code&gt;选择&lt;/code&gt;，带有一点贬义，就像是&lt;code&gt;实在没招了 随便选一条路吧&lt;/code&gt;。人生的选择题不像是试卷上的选择题，他们之间的差别主要体现在，人生的选择题大部分时候不是yes or no，人生的选择题可能需要很长时间以后才能知道哪一个选项是更优的；这种延时反馈，会极大的催生出侥幸心理，反正当下也没谁能说出个123，那么无论怎么做都没人能立刻否定我，至于很久以后，那会人们早就忘了10年前我们是选的A还是B了。但是恰恰，这些选择才是真正需要下功夫的，为人生的选择下功夫思考，那么你的任何成就才不算&lt;code&gt;靠运气&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在应试教育阶段，有一个始终受用的学习技巧，就是永远不相信“马虎”这个词。很多老师也会用这个词，A考题的难度低于B，小明A做错了B做对了，这种场景下，一般别人都会说，你怎么这么马虎，明明你是会的，如果你信了，那我感觉你大概率会吃亏。应试教育的解题根本就不是结果这一个评判标准，还有一个很重要的隐含限制就是时间(当然可能还有很多其他)，你要利用好时间，你的“马虎”，可能在于时间分配的不合理，可能在于时间压力下的思考变形，把这一点称为“马虎”，会极大的麻痹自己。得益于这个思路，人生的很多事，我不会归于运气，正确的路，不是&lt;code&gt;选择&lt;/code&gt;出来的，而是&lt;code&gt;决策&lt;/code&gt;出来的，选择本身就是一种努力，共勉。&lt;/p&gt;</description>
    </item>
    <item>
      <title>工作瓶颈</title>
      <link>https://duck-dd.github.io/posts/2025-11-15-%E5%B7%A5%E4%BD%9C%E7%93%B6%E9%A2%88/</link>
      <pubDate>Sat, 15 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-11-15-%E5%B7%A5%E4%BD%9C%E7%93%B6%E9%A2%88/</guid>
      <description>&lt;p&gt;跟非互联网行业的亲友聊天，他们最终都难免会提出灵魂拷问，&lt;code&gt;你现在P几呀?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原来&lt;code&gt;P序列&lt;/code&gt;的传播是如此的广泛。姑且不论当下，大部分人工作后的第一个长远目标应该都是&lt;code&gt;P8&lt;/code&gt;，因为这是在狭窄视野下能够理解的具体职级要求的极限(至少针对于我)，艰难险阻，走到今天，终于，彻底找不到路了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;技术水平的提升，本质上是时间投入，表面来看是&lt;code&gt;信息获取 -&amp;gt; 实践 -&amp;gt; 沉淀&lt;/code&gt;的过程；兴趣是最好的老师，但是30多岁的中登已经完全失去可塑性了，那么只能走偏门，搞一搞方法论；今天读到了大佬的一段捕鼠器案例，我简单总结一下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;工作中你接到了一个新任务 --- 优化捕鼠器；于是你去
1. 学习捕鼠器的工作原理
2. 查看其他捕鼠器的先进设计
3. 阅读学术界关于捕鼠器的最新论文和研究
4. 归并总结所有捕鼠器漏捕的失败案例
最终你基于上述分析，分别制定了短期优化方案和长期优化方案，开始排期执行落地。

PS: 我觉得能够把以上步骤执行好就已经很棒了

但是你发现，当你优化了捕鼠器，粮食的储存效果提升并不明显，可能受限于粮仓建设技术，温湿度精密控制技术等等的影响，每年储存的粮食总量依然不满足国家需求；再拓展开，粮食的产量本身可能是不足的，10%的储存损耗指标优化已经极度的边际递减，那么提高粮食产量，也能达成最终的目的(好，共和国勋章在等着你了)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这段话看下来，我的第一想法是，这是在告诉我们要提高视野，看到问题的本质，进而知道&amp;quot;自己到底在干什么&amp;quot;；换个具体的说法，你的工作能够最终体现到你&amp;quot;能理解&amp;quot;的最高级别的哪一个指标，GDP我们当然都在做贡献，但是看起来跟我们每个人并没有多大关系，但如果我们的工作能体现到公司财报的一个数字上，那么我相信也是相当幸福的一件事了。&lt;/p&gt;
&lt;p&gt;当然，以上只是我的理解。大佬对此做出的解释是，&lt;strong&gt;&amp;ldquo;解决问题的能力&amp;rdquo;&lt;/strong&gt;。我果然还是理解不了任何虚的东西啊&amp;hellip;&amp;hellip;但是看到这个具体的例子我至少是受到了很大的触动的，仿佛开窍了，终于理解了为什么每个人都在强调“业界影响力”，“市场嗅觉”，“用户至上”，原本我认为这些东西是管理者施加给普通工作者的要求，今天突然觉得，为什么我会止步不前？因为这些素质根本不应该是外界压下来的，这才是当前阶段，一个30出头十分迷茫的中登，能够去追求进步的内核。&lt;/p&gt;
&lt;p&gt;不知所言，多读书多看报吧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>泰国</title>
      <link>https://duck-dd.github.io/posts/2025-11-08-%E6%B3%B0%E5%9B%BD/</link>
      <pubDate>Sat, 08 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-11-08-%E6%B3%B0%E5%9B%BD/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;泰国地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/political_map_thailand.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 泰国地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天学习泰国，东南亚唯一未被殖民的国家。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：Thailand(Kingdom of Thailand)&lt;/li&gt;
&lt;li&gt;语言：泰语&lt;/li&gt;
&lt;li&gt;时区：UTC+7&lt;/li&gt;
&lt;li&gt;首都：曼谷 (Bangkok)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;51.3万&lt;/code&gt;平方公里&lt;/li&gt;
&lt;li&gt;位置：中南半岛中南部&lt;/li&gt;
&lt;li&gt;气候：热带季风气候&lt;/li&gt;
&lt;li&gt;邻(近)国：北部与老挝、缅甸接壤，东南部毗邻柬埔寨，南部与马来西亚相连&lt;/li&gt;
&lt;li&gt;人口：&lt;code&gt;6790万&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;教育：朱拉隆功大学（Chulalongkorn University） 玛希隆大学（Mahidol University） 清迈大学（Chiang Mai University）曼谷大学（Bangkok University） 泰国农业大学（Kasetsart University）&lt;/li&gt;
&lt;li&gt;政治体制：君主立宪制&lt;/li&gt;
&lt;li&gt;经济制度：自由经济政策  开放市场经济&lt;/li&gt;
&lt;li&gt;社会制度：资本主义&lt;/li&gt;
&lt;li&gt;货币：泰铢(Thai Baht). 货币符号 ฿ 国际标准货币代码 THB&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;5264.1 亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文化：传统服饰&amp;quot;纱笼(Sabai)&amp;quot;、&amp;ldquo;绊尾幔(Pha)&amp;rdquo;  寺庙多 家庭供奉佛龛 男性一生中通常会短期出家(几周至几年 视为成年礼的一部分) 合十礼(双手合十置于胸前，指尖高度对应尊重程度)  小费(用纸币支付 硬币视为施舍)&lt;/li&gt;
&lt;li&gt;宗教信仰：佛教(90%+)&lt;/li&gt;
&lt;li&gt;美食：冬阴功汤 泰式炒河粉 绿咖喱&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;全国按 府、县/区、镇、村 层级划分&lt;/li&gt;
&lt;li&gt;76个府 一个府级直辖市-曼谷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元前6世纪 - 公元13世纪：班清文化 曼荼罗式城邦联盟 13世纪前，先后被扶南、真腊（吴哥王朝）统治&lt;/li&gt;
&lt;li&gt;1238年 - 1438年：素可泰王朝；创立泰文字母，推广上座部佛教&lt;/li&gt;
&lt;li&gt;1350年 - 1767年：阿瑜陀耶王朝；&amp;ldquo;暹罗&amp;quot;成为国家正式名，完善中央集权制度，发展海上贸易，佛教进一步发展&lt;/li&gt;
&lt;li&gt;1767年 - 1782年：吞武里王朝；统一泰国全境，收复被缅甸占领的领土，拓展疆域至老挝、柬埔寨部分地区，同时修复佛教寺庙，恢复社会秩序&lt;/li&gt;
&lt;li&gt;1782年 - 至今：曼谷王朝(却克里王朝)
&lt;ul&gt;
&lt;li&gt;1932年，军人和文官集团发动不流血政变，结束君主专制，建立君主立宪制，颁布第一部宪法&lt;/li&gt;
&lt;li&gt;1939年，将国名从&amp;quot;暹罗&amp;quot;改为&amp;quot;泰国&amp;rdquo;(意为自由之地)；1945年二战结束后短暂恢复&amp;quot;暹罗&amp;quot;，1949年再次定为&amp;quot;泰国&amp;quot;&lt;/li&gt;
&lt;li&gt;二战期间，泰国一度与日本结盟，战后成为战败国，但因后期转向同盟国，未受严厉制裁&lt;/li&gt;
&lt;li&gt;1957年，沙立・他那叻政变上台，推行威权统治，同时推动经济发展，重点发展农业和轻工业&lt;/li&gt;
&lt;li&gt;1973年和1992年，爆发两次大规模民主运动，反对军人独裁，推动民选政府回归，确立议会民主制的基本框架&lt;/li&gt;
&lt;li&gt;2006年，军人再次政变推翻他信政府&lt;/li&gt;
&lt;li&gt;2014年，巴育发动政变，建立军政府&lt;/li&gt;
&lt;li&gt;2017年，颁布新宪法&lt;/li&gt;
&lt;li&gt;2019年举行大选，巴育当选总理&lt;/li&gt;
&lt;li&gt;2016年，拉玛九世（普密蓬大帝）去世；2019年，拉玛十世（玛哈・哇集拉隆功）正式加冕，延续曼谷王朝统治&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>菲律宾</title>
      <link>https://duck-dd.github.io/posts/2025-11-08-%E8%8F%B2%E5%BE%8B%E5%AE%BE/</link>
      <pubDate>Sat, 08 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-11-08-%E8%8F%B2%E5%BE%8B%E5%AE%BE/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;菲律宾地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/philippines_map.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 菲律宾地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天学习菲律宾，一个群岛国家(7641个岛屿组成)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：Philippines&lt;/li&gt;
&lt;li&gt;语言：菲律宾语(Filipino)&lt;/li&gt;
&lt;li&gt;时区：UTC+8&lt;/li&gt;
&lt;li&gt;首都：马尼拉(Manila)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;29.97万&lt;/code&gt;平方公里&lt;/li&gt;
&lt;li&gt;位置：亚洲东南部、西太平洋海域&lt;/li&gt;
&lt;li&gt;气候：季风型热带雨林气候&lt;/li&gt;
&lt;li&gt;邻(近)国：北部隔巴士海峡与中国台湾省相望 西部临南海与中国海南岛、越南、马来西亚隔海相对 南部与印度尼西亚、马来西亚的沙巴州隔苏拉威西海、苏禄海相邻&lt;/li&gt;
&lt;li&gt;人口：&lt;code&gt;1.168&lt;/code&gt;亿&lt;/li&gt;
&lt;li&gt;教育：菲律宾大学（University of the Philippines） 雅典耀大学（Ateneo de Manila University） 德拉萨大学（De La Salle University） 圣托马斯大学（University of Santo Tomas）&lt;/li&gt;
&lt;li&gt;政治体制：总统制共和制&lt;/li&gt;
&lt;li&gt;经济制度：出口导向型混合经济，服务业产值约占国内生产总值的60%&lt;/li&gt;
&lt;li&gt;社会制度：资本主义&lt;/li&gt;
&lt;li&gt;货币：菲律宾比索(Philippine Peso) 货币符号₱  国际标准货币代码PHP&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;4616.2 亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文化：圣诞节 家庭至上(家族长辈对家族成员生活决策有很大干预的权力)&lt;/li&gt;
&lt;li&gt;宗教信仰：天主教(主导) 伊斯兰教、基督教新教、佛教&lt;/li&gt;
&lt;li&gt;美食：阿多波(鸡肉/猪肉用醋、酱油、大蒜焖煮) 烤乳猪 芒果沙冰 春卷&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;四级自治单位+三大地理板块的格局&lt;/em&gt;，全国宏观上分为&lt;code&gt;吕宋&lt;/code&gt;、&lt;code&gt;维萨亚&lt;/code&gt;和&lt;code&gt;棉兰老&lt;/code&gt;三大岛群，行政体系上以&lt;code&gt;18个一级大区&lt;/code&gt;为核心，下设&lt;code&gt;省、自治市、描笼涯（镇）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元前 - 1521年：
&lt;ul&gt;
&lt;li&gt;史前时期：菲律宾群岛已有尼格利陀人、马来人等原住民定居，以狩猎、采集和原始农业为生，形成分散的部落社群&lt;/li&gt;
&lt;li&gt;公元10世纪起：与中国、印度、马来群岛建立海上贸易联系，华人、马来人陆续移民，带来农耕技术、金属工具和宗教信仰（印度教、佛教），部分部落形成早期城邦（如苏禄苏丹国）&lt;/li&gt;
&lt;li&gt;1521年 - 1898年：
&lt;ul&gt;
&lt;li&gt;1521年：麦哲伦船队抵达菲律宾，开启西班牙探索&lt;/li&gt;
&lt;li&gt;1565年：西班牙正式建立殖民统治，以马尼拉为殖民中心&lt;/li&gt;
&lt;li&gt;1872年：甲米地起义揭开民族觉醒序幕，何塞・黎刹等知识分子发起 “Propaganda Movement”（宣传运动），呼吁改革&lt;/li&gt;
&lt;li&gt;1896年：安德烈斯・博尼法西奥领导 “卡蒂普南” 起义，推翻西班牙殖民统治的呼声高涨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1898年6月12日：埃米利奥・阿奎纳多宣布菲律宾独立，成立第一共和&lt;/li&gt;
&lt;li&gt;1898年：美西战争后，西班牙将菲律宾 “转让” 给美国，美国击败菲律宾第一共和国，确立殖民统治&lt;/li&gt;
&lt;li&gt;1941年：日本入侵菲律宾，取代美国殖民统治，推行 “大东亚共荣圈” 政策&lt;/li&gt;
&lt;li&gt;1945年：美军收复菲律宾&lt;/li&gt;
&lt;li&gt;1946年7月4日：美国正式承认菲律宾独立，菲律宾共和国成立，标志着殖民时代结束&lt;/li&gt;
&lt;li&gt;1965年费迪南德・马科斯当选总统；1972年宣布军管，建立独裁政权，任内贪污腐败，压制反对声音，经济发展停滞&lt;/li&gt;
&lt;li&gt;1986年：科拉松・阿基诺领导民众起义，推翻马科斯政权，恢复民主制度，制定新宪法&lt;/li&gt;
&lt;li&gt;此后数十年，民选政府与军人势力交替影响，总统更迭频繁，期间经历多次政变未遂和地方叛乱&lt;/li&gt;
&lt;li&gt;2016年 - 2022年：杜特尔特政府时期；打击毒品犯罪和腐败，推动基础设施建设，但人权问题引发国际争议；经济在疫情前保持 6% 左右的年均增长，疫情期间遭受重创&lt;/li&gt;
&lt;li&gt;2022年 - 至今：小马科斯政府时期；&lt;code&gt;费迪南德・马科斯 Jr.&lt;/code&gt; 当选总统，聚焦经济复苏，推动农业现代化、吸引外资和改善民生；南部穆斯林自治区局势持续稳定，民族和解取得进展，但仍面临贫富差距、自然灾害等挑战&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>马来西亚</title>
      <link>https://duck-dd.github.io/posts/2025-11-01-%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A/</link>
      <pubDate>Sat, 01 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-11-01-%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;马来西亚地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/map-of-malaysia.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 马来西亚地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天学习马来西亚。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：Malaysia&lt;/li&gt;
&lt;li&gt;语言：马来语(国语)，通用英语，华语使用较广泛&lt;/li&gt;
&lt;li&gt;时区：UTC+8&lt;/li&gt;
&lt;li&gt;首都：吉隆坡 (Kuala Lumpur, 约200万人口)&lt;/li&gt;
&lt;li&gt;国土面积：约&lt;code&gt;33万平方公里&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;位置：亚洲东南部 是连接太平洋与印度洋的重要枢纽 其地理位置兼具半岛与岛屿特征&lt;/li&gt;
&lt;li&gt;气候：热带雨林气候 和 热带季风气候&lt;/li&gt;
&lt;li&gt;邻(近)国：泰国 印度尼西亚 文莱 新加坡 菲律宾&lt;/li&gt;
&lt;li&gt;人口：3000万+  其中马来裔占&lt;del&gt;70% 华裔占&lt;/del&gt;20% 印度裔占~7%&lt;/li&gt;
&lt;li&gt;教育：
&lt;ul&gt;
&lt;li&gt;马来亚大学(University of Malaya, UM)&lt;/li&gt;
&lt;li&gt;马来西亚国立大学(Universiti Kebangsaan Malaysia, UKM)&lt;/li&gt;
&lt;li&gt;马来西亚理科大学(Universiti Sains Malaysia, USM)&lt;/li&gt;
&lt;li&gt;马来西亚理工大学(Universiti Teknologi Malaysia, UTM)&lt;/li&gt;
&lt;li&gt;诺丁汉大学马来西亚分校(The University of Nottingham Malaysia Campus)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;政治体制：君主立宪议会民主制 联邦国家&lt;/li&gt;
&lt;li&gt;经济制度：市场经济制度；联邦与州政府实行分税制&lt;/li&gt;
&lt;li&gt;社会制度：资本主义&lt;/li&gt;
&lt;li&gt;货币：令吉(林吉特) 货币代码为MYR 货币符号为RM&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;4361.8 亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文化：扎宾舞 弄迎舞 银器 木雕 蜡染 高脚屋&lt;/li&gt;
&lt;li&gt;宗教信仰：伊斯兰教(国教)  佛教、印度教、基督教&lt;/li&gt;
&lt;li&gt;美食：椰浆饭 沙爹(炭火烤制的腌制肉串)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;全国划分为13个州和3个联邦直辖区&lt;/li&gt;
&lt;li&gt;州
&lt;ul&gt;
&lt;li&gt;西马：柔佛(JHR)、吉打、吉兰丹、马六甲(ML)、森美兰、彭亨、槟城(PG)、霹雳、玻璃市、雪兰莪、登嘉楼&lt;/li&gt;
&lt;li&gt;东马：沙巴、砂拉越&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;联邦直辖区：
&lt;ul&gt;
&lt;li&gt;吉隆坡(KL KUL)、纳闽、布城&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元1至7世纪，马来半岛南部出现了第一批具有王权特征的邦国，如狼牙修、揭茶、丹丹等&lt;/li&gt;
&lt;li&gt;公元7世纪中叶，苏门答腊岛上的室利佛逝国（三佛齐帝国）兴起，统治马来半岛南部的大部领土达700年&lt;/li&gt;
&lt;li&gt;约1400年，拜里迷苏剌率追随者到马六甲河的河口定居，建立马六甲苏丹王朝&lt;/li&gt;
&lt;li&gt;1511年，葡萄牙人占领马六甲，马六甲苏丹王朝灭亡 （马六甲苏丹王朝最后一位苏丹的儿子逃到民丹岛，建立柔佛苏丹王朝）&lt;/li&gt;
&lt;li&gt;16世纪末，柔佛主动出击挑战葡萄牙势力&lt;/li&gt;
&lt;li&gt;17世纪初，荷兰建立荷兰东印度公司，与柔佛结盟&lt;/li&gt;
&lt;li&gt;1641年，荷兰与柔佛的联军攻占马六甲，终结了葡萄牙统治&lt;/li&gt;
&lt;li&gt;18世纪末至19世纪初，英国开始逐步占领马来半岛和加里曼丹岛北部地区；20世纪初，马来西亚完全沦为英国殖民地&lt;/li&gt;
&lt;li&gt;1957年8月31日，马来亚联合邦宣布独立&lt;/li&gt;
&lt;li&gt;1963年9月16 日，马来亚联合邦同新加坡、沙捞越、沙巴合并组成马来西亚&lt;/li&gt;
&lt;li&gt;1965年8月9日，新加坡退出马来西亚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>新加坡</title>
      <link>https://duck-dd.github.io/posts/2025-10-31-%E6%96%B0%E5%8A%A0%E5%9D%A1/</link>
      <pubDate>Fri, 31 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-10-31-%E6%96%B0%E5%8A%A0%E5%9D%A1/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;新加坡地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/map_of_singapore.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 新加坡地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天了解新加坡，东南亚地区唯一的发达国家。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：新加坡 Singapore&lt;/li&gt;
&lt;li&gt;语言：英语(主)、马来语、华语、泰米尔语&lt;/li&gt;
&lt;li&gt;时区：UTC+8&lt;/li&gt;
&lt;li&gt;首都：新加坡(市)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;733.2&lt;/code&gt;平方公里&lt;/li&gt;
&lt;li&gt;位置：马来半岛南端、马六甲海峡出入口&lt;/li&gt;
&lt;li&gt;气候：热带雨林气候&lt;/li&gt;
&lt;li&gt;邻(近)国：马来西亚 印度尼西亚&lt;/li&gt;
&lt;li&gt;人口：约&lt;code&gt;570万&lt;/code&gt;(华人占比74%)&lt;/li&gt;
&lt;li&gt;教育：新加坡国立大学(NUS) 南洋理工大学(NTU)&lt;/li&gt;
&lt;li&gt;政治体制：议会共和制&lt;/li&gt;
&lt;li&gt;经济制度：政府主导型市场经济&lt;/li&gt;
&lt;li&gt;社会制度：资本主义制度&lt;/li&gt;
&lt;li&gt;货币：新加坡元，货币代码为&lt;code&gt;SGD&lt;/code&gt;，货币符号为 &lt;code&gt;S$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;5473.87 亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;PS: 2024年人均GDP 9.1万 美元，全球排名第，东南亚排名第一&lt;/li&gt;
&lt;li&gt;PS: 全球第四大国际金融中心(纽约、伦敦、香港);全球第二大财富管理中心(瑞士)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：一院制国会 和 总统 共同行使国家的立法权&lt;/li&gt;
&lt;li&gt;文化：多元融合(马来、南亚、东亚、欧亚)&lt;/li&gt;
&lt;li&gt;宗教信仰：佛教，道教，基督教，穆斯林，印度教&lt;/li&gt;
&lt;li&gt;美食：看起来没啥本土美食&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;全国划分为五个社区（行政区），由相应的社区发展理事会管理
&lt;ul&gt;
&lt;li&gt;中区社理会：是新加坡的核心区域，包含商业中心CBD、购物中心等&lt;/li&gt;
&lt;li&gt;东北社理会：主要包括宏茂桥、盛港、实龙岗、后港、榜鹅、实里达等地区，是新加坡近年来人口密度增长迅速的新区&lt;/li&gt;
&lt;li&gt;西北社理会：包括三巴旺、兀兰、义顺等区域，是组屋密集区，房价相对较为实惠&lt;/li&gt;
&lt;li&gt;东南社理会：由勿洛、巴耶利峇、淡滨尼、巴西立和樟宜机场区等组成&lt;/li&gt;
&lt;li&gt;西南社理会：商业中心在裕廊东，是新加坡的第二个CBD中心，新加坡国立大学和南洋理工大学也位于此区域附近&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元3世纪：三国时期东吴官员康泰所著《吴时外国传》中将新加坡称作 “蒲罗中国”，这是新加坡岛第一次见于书面记载&lt;/li&gt;
&lt;li&gt;公元8世纪，新加坡岛属于室利佛逝王朝&lt;/li&gt;
&lt;li&gt;公元13世纪，中国元代航海家汪大渊在《岛夷志略》中记载了一个叫 “淡马锡” 的地方，即新加坡的古称。1365 年，爪哇的《爪哇史颂》也记载新加坡岛上有一个名叫 “淡马锡” 的定居点，是一个繁荣的地区性港口&lt;/li&gt;
&lt;li&gt;约1390年，室利佛逝王子拜里米苏拉逃到淡马锡，并控制了这里，淡马锡的名称改成了 “新加坡拉”，意为 “狮城”。但很快又被泰国攻陷，后来新加坡成为马六甲苏丹国的属臣驻地&lt;/li&gt;
&lt;li&gt;1819年，英国东印度公司官员托马斯・斯坦福・莱佛士与英军少校威廉・法夸尔登上新加坡岛并设立办事处&lt;/li&gt;
&lt;li&gt;1824年，英国与荷兰签订了《伦敦条约》，划分了英荷两国在东南亚的势力范围，同年8月2日，柔佛王国把新加坡全岛割让给英国，新加坡沦为英国殖民地&lt;/li&gt;
&lt;li&gt;1826年，英国东印度公司将新加坡、槟榔屿和马六甲合并为 “海峡殖民管区”，使之成为英属印度的第四省、&lt;/li&gt;
&lt;li&gt;1867年，新加坡改为英国王室直辖殖民地&lt;/li&gt;
&lt;li&gt;1941年12月8日，日军强行登陆马来亚(马来西亚联邦成立前，位于东南亚马来半岛的一个地区名称)，次年2月15日，英军向日军投降，新加坡被日本占领，日本将其命名为 “昭南岛”&lt;/li&gt;
&lt;li&gt;1945年9月12日，日本新加坡驻军向盟军投降，新加坡重归英国统治&lt;/li&gt;
&lt;li&gt;1959年，新加坡举行立法议员大选，人民行动党获得压倒性胜利，新加坡成为自治邦，李光耀出任新加坡首任总理&lt;/li&gt;
&lt;li&gt;1963年9月16日，新加坡与马来亚、沙巴、沙捞越共同组成马来西亚联邦&lt;/li&gt;
&lt;li&gt;1965年8月9日，新加坡被驱逐出马来西亚联邦(马来人的马来西亚 还是 马来西亚人的马来西亚)，宣布独立，成立新加坡共和国&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>日本</title>
      <link>https://duck-dd.github.io/posts/2025-10-08-%E6%97%A5%E6%9C%AC/</link>
      <pubDate>Wed, 08 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-10-08-%E6%97%A5%E6%9C%AC/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;日本地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/cities_of_japan_map.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 日本地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天系统了解一下日本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：日本 Japan&lt;/li&gt;
&lt;li&gt;语言：日语&lt;/li&gt;
&lt;li&gt;时区：UTC+9&lt;/li&gt;
&lt;li&gt;首都：东京 Tokyo&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;37.8万&lt;/code&gt;平方公里(陆)&lt;/li&gt;
&lt;li&gt;位置：亚洲东部&lt;/li&gt;
&lt;li&gt;气候：亚寒带气候 / 温带气候 / 亚热带气候&lt;/li&gt;
&lt;li&gt;邻(近)国：无陆地接壤邻国 都是隔海 俄罗斯 朝鲜 韩国 中国&lt;/li&gt;
&lt;li&gt;人口：约&lt;code&gt;1.2亿&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;教育：东京大学 早稻田大学 庆应义塾大学 京都大学 东北大学&lt;/li&gt;
&lt;li&gt;政治体制：议会制君主立宪制&lt;/li&gt;
&lt;li&gt;经济制度：政府主导型市场经济&lt;/li&gt;
&lt;li&gt;社会制度：资本主义制度&lt;/li&gt;
&lt;li&gt;货币：日元，货币代码&lt;code&gt;JPY&lt;/code&gt;，符号&lt;code&gt;¥&lt;/code&gt;(同人民币)&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;4.02万亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：国会主导 官僚支撑 内阁推动&lt;/li&gt;
&lt;li&gt;文化：三道(茶道 花道 书道) 能剧 和服 武士道&lt;/li&gt;
&lt;li&gt;宗教信仰：神道(祭祀：神社，信仰万物有灵，伟人/山川/岩石均可为神) 佛教 基督教&lt;/li&gt;
&lt;li&gt;美食：寿司 刺身 天妇罗 怀石料理 神户牛肉 关东煮 拉面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;都道府县 &amp;mdash;&amp;gt; 市町村&lt;/li&gt;
&lt;li&gt;1都(东京都)、1道(北海道)、2府(京都府 大阪府)、43县&lt;/li&gt;
&lt;li&gt;市(人口较多的城市区域) 町(城镇) 村(农村或小规模聚居区) 区(拥有类似市的自治权，如东京都下辖涩谷区)&lt;/li&gt;
&lt;li&gt;主要城市：
&lt;ul&gt;
&lt;li&gt;东京：首都&lt;/li&gt;
&lt;li&gt;大阪：日本西部，是大阪府的府厅&lt;/li&gt;
&lt;li&gt;横滨：东临东京湾，是神奈川县东部的国际港口城市&lt;/li&gt;
&lt;li&gt;名古屋：爱知县首府，日本五大国际贸易港之一&lt;/li&gt;
&lt;li&gt;神户：兵库县首府，位于本州岛西南&lt;/li&gt;
&lt;li&gt;福冈：位于九州北部，福冈县西部，是福冈县县厅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元645年，大化革新推翻旧贵族势力，效仿中国唐朝制度建立中央集权制，定“日本”为国名，推行“班田收授法”，佛教传入并逐渐本土化&lt;/li&gt;
&lt;li&gt;公元794年迁都平安京（今京都），进入平安时代，贵族文化繁荣（如《源氏物语》），但中央集权逐渐衰落，地方武士阶层兴起&lt;/li&gt;
&lt;li&gt;公元1185年，源赖朝击败平氏，1192年在镰仓建立镰仓幕府，这是日本首个武士政权，天皇沦为象征性存在&lt;/li&gt;
&lt;li&gt;公元1336年，足利尊氏建立室町幕府，但统治松散，1467年爆发 “应仁之乱”，日本进入长达百余年的战国时代（1467—1590 年），各地大名（诸侯）割据混战；1590年，丰臣秀吉统一日本，试图对外扩张（侵略朝鲜），但死后政权分裂&lt;/li&gt;
&lt;li&gt;公元1603年，德川家康在江户（今东京）建立江户幕府（德川幕府），开启近 265 年的稳定统治&lt;/li&gt;
&lt;li&gt;近代：明治维新与对外扩张（1868—1945年）
&lt;ul&gt;
&lt;li&gt;1853年，美国佩里舰队 “黑船来航”，迫使日本开国；1868 年，倒幕派（萨摩、长州藩）推翻江户幕府，拥立明治天皇，迁都东京，推行 “明治维新”：政治上废藩置县、建立中央集权，废除武士特权；经济上殖产兴业（建工厂、修铁路），引入西方技术；文化上 “文明开化”（普及教育、穿西装）；军事上建立近代军队（征兵制），走上工业化道路，1894 年成为亚洲首个立宪君主制国家&lt;/li&gt;
&lt;li&gt;明治维新后，日本逐渐走上对外扩张道路：1894 年甲午战争击败中国，1904 年日俄战争获胜，1910 年吞并朝鲜；20 世纪 30 年代，军部势力崛起，1931 年发动 “九一八事变”，1937 年全面侵华，1941 年偷袭珍珠港，卷入太平洋战争&lt;/li&gt;
&lt;li&gt;1945 年 8 月，美国在广岛、长崎投下原子弹，苏联对日宣战，日本天皇宣布无条件投降，二战结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1945—1952 年，美国对日本实行占领，推动民主改革：废除天皇专制，颁布《和平宪法》（规定 “放弃战争”），解散财阀，推行土地改革（解放农民），确立议会制君主立宪制&lt;/li&gt;
&lt;li&gt;1950年代起，日本依托朝鲜战争 “特需”、技术引进与创新，经济快速增长，1968 年成为世界第二大经济体，创造 “日本奇迹”，汽车（丰田）、电子（索尼）等产业全球领先&lt;/li&gt;
&lt;li&gt;2000年后，日本面临少子老龄化、经济停滞（“失去的二十年”）；外交上强化与美国同盟，同时寻求 “正常国家” 地位（如推动修宪讨论）；文化上动漫、游戏等流行文化全球输出，保持国际影响力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>越南</title>
      <link>https://duck-dd.github.io/posts/2025-08-19-%E8%B6%8A%E5%8D%97/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-08-19-%E8%B6%8A%E5%8D%97/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;越南地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/map_of_vietnam.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 越南地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天简单了解一下越南。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：越南 越南社会主义共和国 Vietnam&lt;/li&gt;
&lt;li&gt;语言：越南语&lt;/li&gt;
&lt;li&gt;时区：UTC+7&lt;/li&gt;
&lt;li&gt;首都：河内(Ha Noi)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;33万&lt;/code&gt;平方公里&lt;/li&gt;
&lt;li&gt;位置：中南半岛东部&lt;/li&gt;
&lt;li&gt;气候：热带季风气候；高温多雨，北方分春、夏、秋、冬四季，南方雨旱两季分明&lt;/li&gt;
&lt;li&gt;邻(近)国：北与中国接壤，西与老挝、柬埔寨交界，东和南 临南海&lt;/li&gt;
&lt;li&gt;人口：&lt;code&gt;1亿&lt;/code&gt;多一点&lt;/li&gt;
&lt;li&gt;教育：维新大学 河内国家大学 胡志明市国家大学 孙德胜大学 阮必成大学(PS 阮必成==胡志明) 顺化大学&lt;/li&gt;
&lt;li&gt;政治体制：一党制，越南共产党是越南唯一的政党&lt;/li&gt;
&lt;li&gt;经济制度：社会主义定向的市场经济制度&lt;/li&gt;
&lt;li&gt;社会制度：社会主义制度&lt;/li&gt;
&lt;li&gt;货币：越南盾，简称越盾，货币代码VND，货币符号 &amp;ldquo;₫&amp;rdquo;&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：&lt;code&gt;11.511万亿&lt;/code&gt;越盾，约合&lt;code&gt;4763亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：国会是越南的国家最高权力机关，也是全国唯一的立法机构&lt;/li&gt;
&lt;li&gt;文化：越南文化融合了本土、中国影响、东南亚民族特色、殖民影响等因素；传统服饰：奥黛&lt;/li&gt;
&lt;li&gt;宗教信仰：佛教、天主教、和好教、高台教&lt;/li&gt;
&lt;li&gt;美食：以 “新鲜、清淡、均衡” 为核心，充满东南亚风情与中国饮食痕迹，使用筷子；“鲜 香 酸 辣”；河粉、春卷&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;省/直辖市 &amp;mdash;&amp;gt; 县/市社/郡 &amp;mdash;&amp;gt; 社(农村)/市镇(介于农村和城市之间)/坊(城市)&lt;/li&gt;
&lt;li&gt;全国划分为28个省和6个直辖市(河内市、胡志明市、海防市、岘港市、芹苴市和顺化市)&lt;/li&gt;
&lt;li&gt;主要城市：
&lt;ul&gt;
&lt;li&gt;河内市(Hà Nội, HN, HAN)：首都，越南政治、文化中心&lt;/li&gt;
&lt;li&gt;胡志明市(Thành phố Hồ Chí Minh, HCM, SGN)：旧称西贡，是越南的经济中心、全国最大的港口和交通枢纽，位于湄公河三角洲的东北侧、南临南中国海&lt;/li&gt;
&lt;li&gt;海防(Hai Phong, HP, HPH)：越南北部最大港口城市，位于红河三角洲东北端，京泰河下游，东临北部湾&lt;/li&gt;
&lt;li&gt;岘港(Da Nang, DN, DAD)：位于越南中部，濒临南海，是全国重要的工业城市和海港&lt;/li&gt;
&lt;li&gt;芹苴(Can Tho, CT, VCA)：在后江省南面，下辖4郡4县，是湄公河三角洲上最大的城市，是南部湄公河三角洲农产品集散地和轻工业基地&lt;/li&gt;
&lt;li&gt;顺化：位于越南中部，是越南古都&lt;/li&gt;
&lt;li&gt;下龙(这个不是直辖市)：广宁省省会，位于北部湾的西岸，濒临下龙湾，是越南著名的旅游城市和重要海港，也是越南乃至东南亚的煤都；其著名景点下龙湾有着“海上桂林”的美誉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;红河三角洲地区早在新石器时代就有人类活动，公元前3世纪出现“瓯雒国”（传说由骆越部落建立），是越南最早的政权雏形&lt;/li&gt;
&lt;li&gt;公元前214年，秦始皇征服岭南，越南北部纳入中国版图，此后历经两汉、三国、隋唐等朝代，设 “交趾”“安南都护府” 等行政机构&lt;/li&gt;
&lt;li&gt;公元968年成为独立的封建国家，丁部领建立“丁朝”，定都华闾（今宁平省），正式脱离中国独立，称“大瞿越”，随后历经前黎朝、李朝、陈朝、胡朝、后黎朝等朝代&lt;/li&gt;
&lt;li&gt;1858年，法国以传教士问题为借口，逐步占领越南&lt;/li&gt;
&lt;li&gt;1887年，法国将越南与柬埔寨、老挝合并为 “法属印度支那联邦”，实行殖民统治，掠夺资源并推行西方化改革&lt;/li&gt;
&lt;li&gt;1930年，越南民族主义觉醒，胡志明等革命者成立“越南共产党”&lt;/li&gt;
&lt;li&gt;1940年，日本趁机占领越南，取代法国控制权，越南人民同时抗击法、日侵略&lt;/li&gt;
&lt;li&gt;1945年，“八月革命”后，胡志明宣布成立“越南民主共和国”（北越）；但法国试图重建殖民统治，引发“抗法战争”（1946—1954年）。1954年“奠边府战役”北越获胜，《日内瓦协定》签订，越南以北纬17度线分为北越（社会主义）和南越（资本主义）&lt;/li&gt;
&lt;li&gt;1955—1975年，南越在美国支持下成立政权，南北越矛盾激化。20世纪60年代，美国为遏制共产主义，逐步升级对越南的军事干预，发动“越南战争”（1961—1973年），美军最多投入50万兵力，战争造成巨大伤亡和破坏&lt;/li&gt;
&lt;li&gt;1973年，美军撤军&lt;/li&gt;
&lt;li&gt;1975年，北越军队攻占西贡（今胡志明市），南越政权覆灭&lt;/li&gt;
&lt;li&gt;1976年，越南正式统一，定国名为 “越南社会主义共和国”，定都河内&lt;/li&gt;
&lt;li&gt;1986年，越共六大推行 “革新开放” 政策，引入市场经济元素，吸引外资，发展出口加工产业，经济快速增长&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;额外说明：中国对越自卫反击战(苏联与越南签订军事同盟条约，试图通过越南牵制中国，形成对华战略包围圈)
&lt;ul&gt;
&lt;li&gt;作战阶段：1979年&lt;/li&gt;
&lt;li&gt;边境轮战阶段：1980-1989&lt;/li&gt;
&lt;li&gt;停战：1990越南主动寻求停战&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>印尼</title>
      <link>https://duck-dd.github.io/posts/2025-08-15-%E5%8D%B0%E5%B0%BC/</link>
      <pubDate>Fri, 15 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-08-15-%E5%8D%B0%E5%B0%BC/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;印尼地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%9B%BD%E5%AE%B6/republic_of_indonesia_map.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 印尼地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;最近深度参与一些海外业务，今天了解一下印尼。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：印度尼西亚 印尼 Indonesia&lt;/li&gt;
&lt;li&gt;语言：印度尼西亚语&lt;/li&gt;
&lt;li&gt;时区：UTC+7(西部) UTC+8(中部) UTC+9(东部)&lt;/li&gt;
&lt;li&gt;首都：雅加达(Jakarta，JKT) 逐步迁移至 努山塔拉(Ibu Kota Nusantara，缩写IKN)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;191.4万&lt;/code&gt;平方公里(陆) &lt;code&gt;316.6万&lt;/code&gt;平方公里(海)&lt;/li&gt;
&lt;li&gt;位置：亚洲东南部，太平洋印度洋之间&lt;/li&gt;
&lt;li&gt;气候：赤道海洋性气候；炎热，潮湿多雨；旱季6-9月，雨季12-3月&lt;/li&gt;
&lt;li&gt;邻(近)国：巴布亚新几内亚 东帝汶 马来西亚 泰国 新加坡 菲律宾 澳大利亚&lt;/li&gt;
&lt;li&gt;人口：约&lt;code&gt;3亿&lt;/code&gt; 世界第四&lt;/li&gt;
&lt;li&gt;教育：印度尼西亚大学&lt;/li&gt;
&lt;li&gt;政治体制：总统制共和制&lt;/li&gt;
&lt;li&gt;经济制度：市场经济体制&lt;/li&gt;
&lt;li&gt;社会制度：资本主义制度&lt;/li&gt;
&lt;li&gt;货币：印度尼西亚盾，简称印尼盾，货币代码&lt;code&gt;IDR&lt;/code&gt;，货币符号&lt;code&gt;RP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;22138.96万亿&lt;/code&gt;印尼盾，折合&lt;code&gt;13967.87亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：每个省有自己的立法机关&lt;/li&gt;
&lt;li&gt;文化：传统服饰“巴迪克”；舞蹈(巴厘舞，爪哇舞)；雕塑&lt;/li&gt;
&lt;li&gt;宗教信仰：伊斯兰教(87%) 基督教(6%) 天主教(3.6%)&lt;/li&gt;
&lt;li&gt;美食：沙嗲、印尼炒饭、gado-gado（什锦蔬菜沙拉）等；口味融合了甜、辣、酸等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;省 &amp;mdash;&amp;gt; 县/市 &amp;mdash;&amp;gt; 区 &amp;mdash;&amp;gt; 村/社区&lt;/li&gt;
&lt;li&gt;38个省&lt;/li&gt;
&lt;li&gt;主要城市：
&lt;ul&gt;
&lt;li&gt;雅加达(Jakarta, JKT)：印尼最大的城市，位于爪哇岛西北部沿海&lt;/li&gt;
&lt;li&gt;泗水(Surabaya, SUB,SUR)：印尼第二大城市，东爪哇省的省会，位于爪哇岛东北沿海的泗水海峡西南侧&lt;/li&gt;
&lt;li&gt;万隆（Bandung, BDO）：西爪哇省的省会，位于爪哇岛西部的万隆盆地中&lt;/li&gt;
&lt;li&gt;棉兰（Medan, MES）：苏北省省会，位于苏门答腊岛北部，是苏门答腊岛最大城市&lt;/li&gt;
&lt;li&gt;三宝垄（Semarang, SRG,CGK）：中爪哇省的省会，位于爪哇岛中部北岸，是爪哇岛中部地区重要的交通枢纽及商品集散地&lt;/li&gt;
&lt;li&gt;望加锡（Makassar, MAK,UPG）：南苏拉威西省的省会，位于苏拉威西岛南端，是苏拉威西岛最大的城市&lt;/li&gt;
&lt;li&gt;登巴萨（Denpasar, DPS）：巴厘省的省会，位于巴厘岛南部，是巴厘岛的政治、经济和文化中心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元3-7世纪开始有部落记载&lt;/li&gt;
&lt;li&gt;13世纪末14世纪初，满者伯夷帝国在东爪哇建立&lt;/li&gt;
&lt;li&gt;1602年荷兰成立东印度公司，成为荷兰殖民地&lt;/li&gt;
&lt;li&gt;1942年日本入侵，印尼进入日本统治时期&lt;/li&gt;
&lt;li&gt;1945年8月15日，日本投降，苏加诺宣布印度尼西亚独立&lt;/li&gt;
&lt;li&gt;1949年12月，荷兰正式承认印尼独立&lt;/li&gt;
&lt;li&gt;1970年代后，从传统的计划经济向市场经济转变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>目标管理法</title>
      <link>https://duck-dd.github.io/posts/2025-08-13-%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/</link>
      <pubDate>Wed, 13 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-08-13-%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/</guid>
      <description>&lt;p&gt;当我们写KPI时，我们在写什么？当我们写OKR时，我们在写什么？&lt;/p&gt;
&lt;p&gt;这个问题困扰了许久，从个人的角度，我一直把这些东西当成枷锁，今晚突然寻思，我为什么不能认真审视这个东西，既然总是要花精力来处理，那不如把这个工具用起来。
人都是渴望自由的，或者至少这么说，放纵总是使绝大多数人快乐的；所以前面我们说目标管理是一种枷锁，但是枷锁未必是坏的东西，它也可能是一种推你向上的动力。
在第一次工作中接触OKR时，我当天就给自己的生活也定了好几个OKR，虽然一个也没实现，但是却还是给了我一些挣扎的动力来往前走了几步。&lt;strong&gt;求其上者得其中，求其下者无所得&lt;/strong&gt;，希望无论是工作还是生活，我们能够永远保持对&lt;code&gt;O&lt;/code&gt;的无上憧憬。&lt;/p&gt;
&lt;h2 id=&#34;我理解的-okr&#34;&gt;我理解的 O+KR&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;O&lt;/code&gt;，我认为就一个原则，把最终状态描述清楚，这个状态一般比较遥远(美好)但却不是遥不可及(务实)，精髓在于对于 &lt;strong&gt;遥远&lt;/strong&gt; 的把控。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;KR&lt;/code&gt;，人们常说的最关键的特性就是，&lt;strong&gt;可量化&lt;/strong&gt;。一组&lt;code&gt;KR&lt;/code&gt;是达成一个O的具体行动指引list，每一个&lt;code&gt;KR&lt;/code&gt;的制定需要提前考虑好他的量化评估指标，每一个&lt;code&gt;KR&lt;/code&gt;是可评估的这样才能够保证&lt;code&gt;O&lt;/code&gt;是可评估的，那么这一组&lt;code&gt;OKR&lt;/code&gt;才是有意义的。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O1: 我要做一个帅哥(这个O很美好，能够充分激发主观能动性(牛马工厂管这叫owner意识))
&lt;ul&gt;
&lt;li&gt;KR1: 八块腹肌(这个KR制定的很好，量化方式很简单)&lt;/li&gt;
&lt;li&gt;KR2: 皮肤状态变好(这个KR定的不好，“状态变好”很难量化，都不如改成12点前睡觉/一年用光一瓶洗面奶/每个月用完10片面膜)&lt;/li&gt;
&lt;li&gt;KR3: 搞个酷酷的发型(这个KR制定的也不太好，有一点过于具体了，很容易就做完了，这种应该是某一个KR里面的一个子项)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;smart目标法&#34;&gt;SMART目标法&lt;/h2&gt;
&lt;p&gt;下面记录巩固一下前人总结的制定目标的SMART法则(from 豆包)。&lt;/p&gt;
&lt;h3 id=&#34;sspecific明确具体&#34;&gt;S（Specific）：明确具体&lt;/h3&gt;
&lt;p&gt;目标必须清晰、具体，避免模糊笼统，明确 “做什么、谁来做、怎么做”。
反面示例：“提高业绩”（模糊，未明确提高多少、针对哪个业务）。
正面示例：“销售团队在第三季度将产品 A 的销售额提升 20%”（明确主体、对象、时间、指标）。&lt;/p&gt;
&lt;h3 id=&#34;mmeasurable可衡量&#34;&gt;M（Measurable）：可衡量&lt;/h3&gt;
&lt;p&gt;目标需有量化标准，便于跟踪进度和判断是否完成，避免 “完成了但说不清完成度” 的情况。
反面示例：“改善客户满意度”（无法量化 “改善” 的程度）。
正面示例：“通过季度调研，将客户满意度评分从 80 分提升至 90 分以上”（用具体分数衡量）。&lt;/p&gt;
&lt;h3 id=&#34;aachievable可实现&#34;&gt;A（Achievable）：可实现&lt;/h3&gt;
&lt;p&gt;目标需具有挑战性，但在现有资源（时间、能力、预算等）下可达成，避免因目标过高而失去动力，或过低而缺乏意义。
反面示例：“零基础 1 个月内成为 AI 专家”（资源和时间不匹配，难以实现）。
正面示例：“3 个月内通过系统学习，掌握 Python 基础编程并独立完成一个数据分析项目”（结合现有基础和学习路径，可实现）。&lt;/p&gt;
&lt;h3 id=&#34;rrelevant相关性&#34;&gt;R（Relevant）：相关性&lt;/h3&gt;
&lt;p&gt;目标需与个人 / 团队的核心目标、长期愿景相关联，确保资源投入有价值，避免偏离核心方向。
反面示例：“市场部花大量时间学习财务软件”（与市场部核心职责关联度低）。
正面示例：“市场部学习新媒体运营工具，提升短视频内容曝光量”（直接服务于 “扩大品牌影响力” 的核心目标）。&lt;/p&gt;
&lt;h3 id=&#34;ttime-bound有时限&#34;&gt;T（Time-bound）：有时限&lt;/h3&gt;
&lt;p&gt;目标必须设定明确的完成时间，避免无限期拖延，同时便于规划阶段任务。
反面示例：“完成产品迭代”（无时间限制，易导致进度松散）。
正面示例：“在 2024 年 12 月 31 日前完成 V2.0 版本的功能开发并上线”（明确截止时间，可拆分阶段任务）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MCMF from scratch</title>
      <link>https://duck-dd.github.io/posts/2025-06-24-mcmf/</link>
      <pubDate>Tue, 24 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-06-24-mcmf/</guid>
      <description>&lt;p&gt;需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。
记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。&lt;/p&gt;
&lt;h1 id=&#34;mcmf概念&#34;&gt;MCMF概念&lt;/h1&gt;
&lt;p&gt;Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。&lt;/p&gt;
&lt;h1 id=&#34;最大流问题&#34;&gt;最大流问题&lt;/h1&gt;
&lt;p&gt;最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法。&lt;/p&gt;
&lt;h2 id=&#34;第一印象&#34;&gt;第一印象&lt;/h2&gt;
&lt;p&gt;简单描述，有向有权图，起点&lt;code&gt;s&lt;/code&gt;，终点&lt;code&gt;t&lt;/code&gt;，我们要寻找&lt;code&gt;s-&amp;gt;t&lt;/code&gt;的最大的流量。
那么朴素的第一印象来看，暴力呗，BFS把所有&lt;code&gt;s-&amp;gt;t&lt;/code&gt;路径集合&lt;code&gt;P&lt;/code&gt;全部记录下来，然后逐条路径遍历&lt;code&gt;P&lt;/code&gt;，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个&lt;code&gt;边-&amp;gt;剩余容量&lt;/code&gt;)，结束后得到一个总的流量值。
提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于&lt;code&gt;s&lt;/code&gt;的所有出边都满，或者&lt;code&gt;t&lt;/code&gt;的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，&lt;code&gt;P&lt;/code&gt;的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，&lt;code&gt;P&lt;/code&gt;中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对&lt;code&gt;P&lt;/code&gt;剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。
好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;图1 blocking-flow(黑色数字=容量,红色数字=流量)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/mcmf/mcmf-1.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 blocking-flow(黑色数字=容量,红色数字=流量)&lt;/center&gt;
&lt;p&gt;如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，&lt;code&gt;阻塞流&lt;/code&gt;，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。
结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点&lt;code&gt;s&lt;/code&gt;以及他的出边，终点&lt;code&gt;t&lt;/code&gt;以及他的入边，我们碰到了这样一个情况，我们选定了&lt;code&gt;s&lt;/code&gt;的左出边以及&lt;code&gt;t&lt;/code&gt;的右入边并且把它们两个给跑满了，而&lt;code&gt;s&lt;/code&gt;的右出边和&lt;code&gt;t&lt;/code&gt;的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，&lt;code&gt;t&lt;/code&gt;的右入边跑满的流量不仅仅来自于&lt;code&gt;s&lt;/code&gt;的左出边，还有&lt;code&gt;s&lt;/code&gt;的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。&lt;/p&gt;
&lt;p&gt;那么如何修正能够确保准确的找到最大流呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再继续暴力的把&lt;code&gt;P&lt;/code&gt;的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度)&lt;/li&gt;
&lt;li&gt;前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈)
&lt;ul&gt;
&lt;li&gt;我们避免使用到不合理的路径？那对路径打分？结合实时的 &lt;code&gt;residual graph(残量图，余量图，残量网络 等)&lt;/code&gt;，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(&lt;code&gt;s&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖&lt;code&gt;residual graph&lt;/code&gt;来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的&lt;/li&gt;
&lt;li&gt;那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ford-fulkerson&#34;&gt;Ford-Fulkerson&lt;/h2&gt;
&lt;p&gt;一句话描述&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法，就是在建立&lt;code&gt;residual graph&lt;/code&gt;时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。
从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。
但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径)
不是的，还是用图1左举例，他的&lt;code&gt;residual graph&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;图2 图1左的residual graph&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/mcmf/mcmf-2.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 图1左部的residual-graph&lt;/center&gt;
&lt;p&gt;图2中，我们可以继续找到这样一条路径&lt;code&gt;s-&amp;gt;v2-&amp;gt;v4-&amp;gt;v1-&amp;gt;v3-&amp;gt;t 流量=1&lt;/code&gt;，其中&lt;code&gt;v4-&amp;gt;v1 流量=1&lt;/code&gt;这一段是我们选中的反向边(我们只对这一条边做了&amp;quot;撤销&amp;quot;)，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法是正确的。
那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在&lt;code&gt;residual graph&lt;/code&gt;中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在&lt;code&gt;s&lt;/code&gt;&amp;mdash;&amp;gt;&lt;code&gt;t&lt;/code&gt;的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个&lt;code&gt;H&lt;/code&gt;型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整&lt;code&gt;H&lt;/code&gt;型的两条竖线之间的流量分配方式(即合理规划使用&lt;code&gt;H&lt;/code&gt;的左上 左下 右上 右下四部分)，以使得整个&lt;code&gt;H&lt;/code&gt;通过的流量最大。&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Shortest Path</title>
      <link>https://duck-dd.github.io/posts/2025-06-23-shortest-path/</link>
      <pubDate>Mon, 23 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-06-23-shortest-path/</guid>
      <description>&lt;h1 id=&#34;最短路径问题&#34;&gt;最短路径问题&lt;/h1&gt;
&lt;p&gt;寻找有向图中两个顶点之间的路径，使得 &lt;code&gt;路径最短&lt;/code&gt; 或 &lt;code&gt;路径上各边的权重之和最小&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-无权图最短路径&#34;&gt;1 无权图最短路径&lt;/h2&gt;
&lt;p&gt;所有边权重相同，最短路径退化为寻找两点间边数最少的路径，&lt;code&gt;BFS&lt;/code&gt;搞定。&lt;/p&gt;
&lt;h2 id=&#34;2-单源最短路径sssp-single-source-shortest-paths&#34;&gt;2 单源最短路径(SSSP, Single-Source Shortest Paths)&lt;/h2&gt;
&lt;h3 id=&#34;21-dijkstra堆优化&#34;&gt;2.1 Dijkstra(堆优化)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限制：边权非负&lt;/li&gt;
&lt;li&gt;思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径&lt;/li&gt;
&lt;li&gt;步骤
&lt;ul&gt;
&lt;li&gt;初始化：
&lt;ul&gt;
&lt;li&gt;源点&lt;code&gt;s&lt;/code&gt;的距离为0，源点&lt;code&gt;s&lt;/code&gt;一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞)&lt;/li&gt;
&lt;li&gt;所有节点标记为未访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环处理：
&lt;ul&gt;
&lt;li&gt;从未访问节点中选择距离最小的节点&lt;code&gt;u&lt;/code&gt;，标记为已访问&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;u&lt;/code&gt;的每个邻接节点&lt;code&gt;v&lt;/code&gt;，进行 &lt;strong&gt;松弛操作&lt;/strong&gt;:
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if distance[v] &amp;gt; distance[u] + weight(u, v):
    distance[v] = distance[u] + weight(u, v)
    predecessor[v] = u  # 记录路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为&lt;code&gt;O(logV)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录路径：通过记录&lt;code&gt;前驱节点&lt;/code&gt;可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序)&lt;/li&gt;
&lt;li&gt;算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-bellman-ford&#34;&gt;2.2 Bellman-Ford&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小)&lt;/li&gt;
&lt;li&gt;思路：通过 &lt;strong&gt;松弛操作&lt;/strong&gt; 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边&lt;code&gt;(u, v)&lt;/code&gt;，若从源点到&lt;code&gt;u&lt;/code&gt;的距离 &lt;code&gt;dist[u]&lt;/code&gt;加上边权&lt;code&gt;w(u, v)&lt;/code&gt;小于当前到&lt;code&gt;v&lt;/code&gt;的距离&lt;code&gt;dist[v]&lt;/code&gt;，则更新&lt;code&gt;dist[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;步骤
&lt;ul&gt;
&lt;li&gt;初始化：源点距离&lt;code&gt;dist[source] = 0&lt;/code&gt;，其他顶点距离&lt;code&gt;dist[v] = ∞&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;弛操作：对图中所有边进行&lt;code&gt;n-1&lt;/code&gt;轮松弛（&lt;code&gt;n&lt;/code&gt;为顶点数）；因为最短路径最多包含&lt;code&gt;n-1&lt;/code&gt;条边(否则存在环，若为正权环可忽略，负权环则无法求解)&lt;/li&gt;
&lt;li&gt;检测负权环：第&lt;code&gt;n&lt;/code&gt;次松弛时，若仍能更新距离，则说明存在从源点可达的负权环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化：下面的SPFA&lt;/li&gt;
&lt;li&gt;算法正确性理解：&lt;code&gt;n&lt;/code&gt;个节点，那么起点到终点路径最长就是 &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;...-&amp;gt;n&lt;/code&gt; 最多有&lt;code&gt;n-1&lt;/code&gt;跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代&lt;code&gt;x&lt;/code&gt;轮，那么&lt;code&gt;x&lt;/code&gt;跳能到达的节点的最短路径都会被优化完成，所以经过&lt;code&gt;n-1&lt;/code&gt;轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-spfa-shortest-path-faster-algorithm&#34;&gt;2.3 SPFA, Shortest Path Faster Algorithm&lt;/h3&gt;
&lt;p&gt;SPFA其实只是Bellman-Ford的筛选优化，本质相同&lt;/p&gt;</description>
    </item>
    <item>
      <title>go tips(持续更新)</title>
      <link>https://duck-dd.github.io/posts/2025-06-22-go-tips/</link>
      <pubDate>Sun, 22 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-06-22-go-tips/</guid>
      <description>&lt;p&gt;有很多从其他大佬的总结中抄来的，不注明出处了&lt;/p&gt;
&lt;p&gt;会记录一些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有意义的小操作(可能有些比较tricky)&lt;/li&gt;
&lt;li&gt;容易理解偏差的点&lt;/li&gt;
&lt;li&gt;日常开发低频使用的知识点&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;golang代码执行顺序&#34;&gt;golang代码执行顺序&lt;/h2&gt;
&lt;p&gt;没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。&lt;/p&gt;
&lt;p&gt;了解更多可查看Golang内存模型规范。&lt;/p&gt;
&lt;h2 id=&#34;golang内存对齐&#34;&gt;golang内存对齐&lt;/h2&gt;
&lt;p&gt;内存对齐：数据在内存中的存储位置必须是特定字节数的倍数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;golang内存对齐：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础类型：通常是其自身大小（如int32为4字节，int64为8字节）&lt;/li&gt;
&lt;li&gt;结构体
&lt;ul&gt;
&lt;li&gt;每个字段按各自的对齐系数作对齐&lt;/li&gt;
&lt;li&gt;结构体自身的对齐系数为所有字段中最大的对齐系数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组：与元素类型的对齐系数相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
    fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;demo1:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节&lt;/li&gt;
&lt;li&gt;b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节&lt;/li&gt;
&lt;li&gt;c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;demo2:&lt;/p&gt;</description>
    </item>
    <item>
      <title>相似度</title>
      <link>https://duck-dd.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-06-03-%E7%9B%B8%E4%BC%BC%E5%BA%A6/</guid>
      <description>&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;用于衡量多个对象（如文本、数值向量、图像、序列等）之间相似程度的数学方法。&lt;/p&gt;
&lt;p&gt;在计算机领域，通常将 “相似性” 转化为可计算的数值（例如 0~1 表示，1代表完全相似，0代表完全不相似）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;的应用十分广泛，例如推荐系统（如商品/内容推荐）、数据挖掘（如聚类、分类）、NLP（如文本查重、语义匹配）、图像识别等。&lt;/p&gt;
&lt;h1 id=&#34;文本相似度&#34;&gt;文本相似度&lt;/h1&gt;
&lt;h2 id=&#34;基于字符词频&#34;&gt;基于字符/词频&lt;/h2&gt;
&lt;p&gt;不依赖语义理解，仅从文本的字符或词语出现频率出发计算相似性，适合简单的短文本内容的场景。&lt;/p&gt;
&lt;h3 id=&#34;jaccard-系数杰卡德相似度&#34;&gt;Jaccard 系数（杰卡德相似度）&lt;/h3&gt;
&lt;p&gt;思路：将文本视为 “词语集合”（忽略词频和顺序），&lt;code&gt;相似性 = 两个集合的交集大小 / 两个集合的并集大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，sim(“小明球技很棒” &amp;amp; “小明球技真好”) = len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo;)/len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo;) = 0.5&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词频没有统计&lt;/li&gt;
&lt;li&gt;语义不做理解，&amp;ldquo;真好&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; 其实语义接近&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;余弦相似度cosine-similarity&#34;&gt;余弦相似度（Cosine Similarity）&lt;/h3&gt;
&lt;p&gt;思路：将文本转换为词频向量，&lt;code&gt;相似性 = 两个向量夹角余弦值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，(“小明球技很棒啊，小明不错” &amp;amp; “小明球技真好”)，构建&lt;code&gt;词袋&lt;/code&gt;=[&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo; &amp;ldquo;不错&amp;rdquo;]，对于词袋，计算向量值，“小明球技很棒”的词频向量A = [2,1,1,0,1]，“小明球技真好”的词频向量B = [1,1,0,1,0]，则 &lt;code&gt;相似性 = cos(A,B) = (A*B)/(||A||*||B||) = (2+1+0+0+0)/(√7*√3) = 3/√21 = 0.66&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;考虑了词频，长文本理解更准确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义还是没有理解&lt;/li&gt;
&lt;li&gt;高频无意义词，如“的” “地”等影响较大，需过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 常用的相似性判定方法主要通过 向量夹角余弦值(&lt;code&gt;向量点积/向量模乘积&lt;/code&gt;)
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;cos&lt;/mi&gt;
&lt;mi&gt;θ&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mfrac&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;/mrow&gt;
&lt;mrow&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;mo&gt;×&lt;/mo&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;/mfrac&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\cos\theta = \frac{\sum_{i=1}^n A_iB_i}{\sqrt{\sum_{i=1}^n A_i^2} \times \sqrt{\sum_{i=1}^n B_i^2}}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
or 向量间欧式距离
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;d&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;msqrt&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;mrow&gt;
&lt;mi&gt;(&lt;/mi&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mo&gt;-&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mi&gt;)&lt;/mi&gt;
&lt;/mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/mrow&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d = \sqrt{\sum_{i=1}^n (x_{2i} - x_{1i})^2}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
计算获得&lt;/p&gt;</description>
    </item>
    <item>
      <title>认清自己</title>
      <link>https://duck-dd.github.io/posts/2025-05-28-%E8%AE%A4%E6%B8%85%E8%87%AA%E5%B7%B1/</link>
      <pubDate>Wed, 28 May 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-05-28-%E8%AE%A4%E6%B8%85%E8%87%AA%E5%B7%B1/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;渭城朝雨浥轻尘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客舍青青柳色新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;劝君更尽一杯酒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;西出阳关无故人&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;回首向来萧瑟处，归去，也无风雨也无晴&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;“孩子若是平凡之辈，那就承欢膝下；若是出类拔萃，那就让其展翅高飞。接受孩子的平庸，就像孩子从来没有要求父母一定要多么优秀一样。” &amp;mdash;&amp;mdash; 梁晓声《人世间》&lt;/p&gt;
&lt;p&gt;平凡的周秉义，也是精彩绝伦的一生。&lt;/p&gt;
&lt;p&gt;这句话也会被总结为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受父母的平凡&lt;/li&gt;
&lt;li&gt;接受自己的平凡&lt;/li&gt;
&lt;li&gt;接受子女的平凡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个阶段不在今天的讨论范围。今天主要说第二个阶段，因为今天的我认为，时至今日，我终于走完了这个阶段。&lt;/p&gt;
&lt;p&gt;从小在小山村长大，得益于父母给的脑子，在学习上有一定的竞争力。对小学时期，印象深刻的有两件事。&lt;/p&gt;
&lt;p&gt;第一件事，就是每到期末，村里面所有的孩子会成为一车面包人，前往“中心校”，参加期末考试；每次去的路上，几十分钟的路程，那是我最紧张的时候，因为进入考场后反而会平静，用现在的词，叫“心流”；紧张的时候小小的脑袋在想什么呢，我就在想，“今天就是最终的战役了，放手一搏吧”，反正就大概这个意思吧，延续这个思维，后面人生很多场关于学习的考试，考前都是这种心态。&lt;/p&gt;
&lt;p&gt;第二件事，是在大概四五年级的时候，乡里面举办了一场“竞赛”，每个村小学出一个队，齐聚“中心校”，比赛的过程大概就是全程举牌抢答，答对加分，答错扣分，题目范围也不仅限于小学课本，涉及了一些课外知识；没错，作为团队主力，我们村拿到了最高分(我得到了一些文具，好像还有一个枕套)；小小的我，在教育资源极度匮乏的村里，第一次深刻感受“激烈的”比赛；这是我对学习的第一次“觉醒”，虚荣心得到了满足，学到的知识也有了用武之地。&lt;/p&gt;
&lt;p&gt;后面就是按部就班的到城里上中学，靠着虚荣心，靠着别人的称赞，靠着自己的一点拼劲，一路学习成绩都还不错。中考和高考的成绩其实都不咋地，但是也没有差到不能接受；当看到自己的高考排名，第一次产生了自我怀疑，自己其实根本没有自己想象的那么厉害呀！&lt;/p&gt;
&lt;p&gt;成长的背景简单总结如上，这一路“虚荣心”提供了极大的动力，也给自己营造了自己还不错的假象。这种自我暗示一旦形成，我感觉是很难从内自我打破的。第一份工作自己没太多思考，更多是被推着走，最大的收获在于很多思考方式的转变和能力的成长，所以当这一段旅程结束时，心态是感恩 感谢 积极向上的；当我带着自我预期走进第二段经历的时候，觉得自己可以做出一番成绩；今天来看，平台有，自由度有，只是自己没有做好；这里的自我剖析过程，简直“罄竹难书”了；一句话概括，&lt;strong&gt;&amp;ldquo;求其下者无所得&amp;rdquo;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;所以当今天再次走向下一段旅程，心情是平淡的，怀抱美好憧憬，但是能够一定程度上提前认识到旅途的艰辛和失败的苦涩；这么多年，社会终于教会了我，接受自己的平凡。&lt;/p&gt;
&lt;p&gt;此刻心里只有一个愿望，到底什么时候能找到创业的方向啊。&lt;/p&gt;
&lt;p&gt;安顺的山清晰透明，黄果树的汛期滔滔不绝；瀑布上的每一滴水都惊涛骇浪，但那么大的水量，跌落后都回归进了平静的河流。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang singleflight</title>
      <link>https://duck-dd.github.io/posts/2025-04-05-golang-singleflight/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2025-04-05-golang-singleflight/</guid>
      <description>&lt;p&gt;高并发场景下，有时我们很多并发goroutine内有逻辑重合，可能拉了数据库同一张表的数据，可能拉了同一个远程图片，这些数据通常是偏静态的，那么没有必要在每个goroutine内部都做这个操作，可能会拉高上游服务的负载，可能会影响本地的执行效率，可能会浪费本地的网卡资源等。&lt;/p&gt;
&lt;p&gt;通常我们会依赖缓存来解决这个问题，这也确实是行之有效的；但是golang并发场景也给了我们更简便的实现方法：&lt;code&gt;golang.org/x/sync/singleflight&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如下面的例子，&lt;code&gt;doSth&lt;/code&gt;有2s的Sleep模拟执行过程；我们分了两组for+routine，中间有1s的Sleep，确保第一个发起&lt;code&gt;doSth&lt;/code&gt;的&lt;code&gt;index&lt;/code&gt;是可控的，然后我们看到输出实际&lt;code&gt;doSth&lt;/code&gt;只执行了一次，所有routine共享了同一份结果。
PS：所有的&lt;code&gt;shared&lt;/code&gt;返回值都是&lt;code&gt;true&lt;/code&gt;，可能并不是大脑第一印象的第一个实际执行者是&lt;code&gt;false&lt;/code&gt;，其他人是&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;sync&amp;#34;
	&amp;#34;sync/atomic&amp;#34;
	&amp;#34;time&amp;#34;
	&amp;#34;golang.org/x/sync/singleflight&amp;#34;
)

func doSth(index int) (any, error) {
	time.Sleep(2 * time.Second)
	return fmt.Sprintf(&amp;#34;result_%d&amp;#34;, index), nil
}

func main() {
	var g singleflight.Group
	var wg sync.WaitGroup
	var doCount int32 

	for i := 100; i &amp;lt; 101; i++ {
		wg.Add(1)
		index := i
		go func() {
			defer wg.Done()
			ret, err, shared := g.Do(&amp;#34;key&amp;#34;, func() (interface{}, error) {
				atomic.AddInt32(&amp;amp;doCount, 1)
				v,e := doSth(index)
				fmt.Printf(&amp;#34;index:%d, v: %v, err: %v\n&amp;#34;, index, v, e)
				return v,e
			})
			fmt.Printf(&amp;#34;index:%d, ret:%v, shared:%v, err:%v\n&amp;#34;, index, ret, shared, err)
		}()
	}
	
	
	time.Sleep(time.Second)
	
	for i := 0; i &amp;lt; 5; i++ {
		wg.Add(1)
		index := i
		go func() {
			defer wg.Done()
			ret, err, shared := g.Do(&amp;#34;key&amp;#34;, func() (interface{}, error) {
				atomic.AddInt32(&amp;amp;doCount, 1)
				v,e := doSth(index)
				fmt.Printf(&amp;#34;index:%d, v: %v, err: %v\n&amp;#34;, index, v, e)
				return v,e
			})
			fmt.Printf(&amp;#34;index:%d, ret:%v, shared:%v, err:%v\n&amp;#34;, index, ret, shared, err)
		}()
	}
	
	wg.Wait()
	
	fmt.Printf(&amp;#34;实际执行次数: %d\n&amp;#34;, doCount)
}

------
output:

index:100, v: result_100, err: &amp;lt;nil&amp;gt;
index:100, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:0, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:4, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:2, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:3, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:1, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
实际执行次数: 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正发起共享的函数&lt;code&gt;Do&lt;/code&gt;入参是有&lt;code&gt;key&lt;/code&gt;的，我们把&lt;code&gt;key&lt;/code&gt;做个替换，会发现不同&lt;code&gt;key&lt;/code&gt;之间不共享，如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>装修那些事儿</title>
      <link>https://duck-dd.github.io/posts/2023-06-24-%E8%A3%85%E4%BF%AE/</link>
      <pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2023-06-24-%E8%A3%85%E4%BF%AE/</guid>
      <description>&lt;p&gt;这个行业，是一个没有监管，没有行业标准(有的大部分也是扯淡)，群魔乱舞的行业，这行业人的话，不要相信，不要相信，不要相信&lt;/p&gt;
&lt;p&gt;从我自身经历来说，这件事真的不复杂，完全不值他现在的价钱；一开始这件事很神秘，你觉得付多少钱都是合理的，但真不是这样，到处都是骗钱的；所以装修开始前真正的第一件事，就是你要了解一下背景评估一下工作量，放心大胆的去砍价吧&lt;/p&gt;
&lt;p&gt;本文从自己的亲身经历出发来分析一下装修这件令人头疼的事情，没有展开太多的细节，只以各个阶段的典型选择题为切入点，欢迎指正和交流，预祝你获得你的梦中情屋～&lt;/p&gt;
&lt;h1 id=&#34;全包-or-半包&#34;&gt;全包 or 半包&lt;/h1&gt;
&lt;p&gt;如果你刚开始考虑装修，那你一定是特别开心和兴奋的。&lt;/p&gt;
&lt;p&gt;你面临的第一个问题大概就是，&amp;ldquo;半包&amp;rdquo; or &amp;ldquo;全包&amp;rdquo;（自己找工人的方式，不太了解就不谈了）；很多声音会告诉你说，全包这种完全黑盒的行为会有太多坑了，给你用的东西都是差的balabala&lt;/p&gt;
&lt;p&gt;但是，如果你想省心，或者在装修的这几个月里你没有太多的时间精力能够投入进这件事，那么还是建议你咬咬牙忽略这些有一丢丢危言耸听的说法，果断的选择全包&lt;/p&gt;
&lt;p&gt;如果你选择了全包，那么我们对最终效果的确认无非靠两个关键指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 是不是我想要的样子&lt;/li&gt;
&lt;li&gt;2 是不是环保&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了第一点，你需要查看素材库确认好自己喜欢的样子，跟设计师做充分的沟通，并在施工过程的关键节点约设计师一起去现场做阶段性的沟通和double check，因为省心，所以你做的功课可能不多，其实这比较依赖设计师的专业性&lt;/p&gt;
&lt;p&gt;为了第二点，你需要做的功课是，查一查装修过程中哪些使用到的材料可能会不环保，然后直接在合同里声明好这些材料具体使用哪些品牌的哪些型号，并在这些材料入场时做好检查(其实可以找类似&amp;quot;监工&amp;quot;的角色来帮助你执行，应该总比你完全不去现场要好)&lt;/p&gt;
&lt;p&gt;朋友，如果你选择了半包，那你是真的勇士，对你表示敬佩，以下的讨论咱们就默认你已经做了大量的背景&amp;amp;功课的学习。&lt;/p&gt;
&lt;h1 id=&#34;入户门&#34;&gt;入户门&lt;/h1&gt;
&lt;p&gt;换！你99%不喜欢开发商的这个，相比换锁，就干脆直接换门吧&lt;/p&gt;
&lt;h1 id=&#34;窗户&#34;&gt;窗户&lt;/h1&gt;
&lt;p&gt;如果允许，换！拉满配(可能很多地方政策不允许动外立面，那就没办法了)&lt;/p&gt;
&lt;h1 id=&#34;隔音&#34;&gt;隔音&lt;/h1&gt;
&lt;p&gt;如果你对声音要求很高，考虑做全屋音响，那是肯定得做了&lt;/p&gt;
&lt;p&gt;如果你没有考虑做全屋音响，那么我还是强！烈！建！议！做！隔！音！&lt;/p&gt;
&lt;h1 id=&#34;全屋定制-or-成品家具&#34;&gt;全屋定制 or 成品家具&lt;/h1&gt;
&lt;p&gt;个人观点，全屋定制真的不咋地，建议祛魅，认真的去逛一逛成品家具市场&lt;/p&gt;
&lt;p&gt;还往下看，你果然还是跟我一样，头铁的选择了全屋定制，那这个子方向发个千八百个论文感觉都泛不起一点水花；
商家贩卖的焦虑点：甲醛，苯系化合物；你要想死磕，得先学化学&lt;/p&gt;
&lt;p&gt;标准：国外国内太多标准，但有一点个人觉得有参考意义，就是 &lt;code&gt;抽检&lt;/code&gt; &amp;amp; &lt;code&gt;送检&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;品牌选择：大商场大品牌的品牌溢价确实太高了，而且也确实代加工，所以有判断能力那就果断直接找工厂吧&lt;/p&gt;
&lt;p&gt;细节不展开讲了，说一点注意点，跟电位/管道做配合要提前做规划，这也是为什么把这个问题放得这么靠前&lt;/p&gt;
&lt;h1 id=&#34;布局&#34;&gt;布局&lt;/h1&gt;
&lt;p&gt;该砸就砸别犹豫(非承重) 新砌墙时考虑好用途，如果有承重需求(例如挂电视 挂柜子等)，考虑好墙体的材料
砌墙后多晾一晾 否则后期墙上面搞得任何东西都容易剥离&lt;/p&gt;
&lt;p&gt;墙的&lt;em&gt;&lt;strong&gt;平&lt;/strong&gt;&lt;/em&gt;的问题，从小白视角来看，就是表面是平面，并且这个平面跟其他平面的角度(一般90度)是正常的，这点不管施工方是冲筋 垂平还是啥方法，总之先讲清楚要求并让他们严格执行&lt;/p&gt;
&lt;p&gt;坐便or蹲便？多个卫生间可以考虑留一个蹲便，不仅健康，而且后期小孩使用也好扩展（这个问题需要提前考虑因为可能影响卫生间地面高度布局）&lt;/p&gt;
&lt;h1 id=&#34;水电&#34;&gt;水电&lt;/h1&gt;
&lt;p&gt;水管线管一定选择最好的品牌的好的型号，避免后期出问题太麻烦&lt;/p&gt;
&lt;p&gt;至于是按使用长度算，还是一口价模式，自己来衡量对比，是否点对点走线？可以看网上大量的分析&lt;/p&gt;
&lt;p&gt;电箱位置挪不挪？如果风水问题(那么你一定是相信这个的)，挪；如果只是为了好看，那后期挺多方法弄好看，可以看看效果自己能不能接受&lt;/p&gt;
&lt;p&gt;前置过滤器：空间允许，就安；拉满配，本身没多贵，影响水压就不好了&lt;/p&gt;
&lt;p&gt;全屋软水：没考虑清楚，就做&lt;/p&gt;
&lt;p&gt;下水：有顾虑该做的位置就做，用不用得上再说&lt;/p&gt;
&lt;p&gt;电位：有顾虑就做，总比后期拉插线板强(70个/100平 ？)&lt;/p&gt;
&lt;p&gt;开关：一开多控别顾虑，想做就做，方便生活&lt;/p&gt;
&lt;p&gt;全屋智能：已经在考虑这个问题了？那就做。。。有点贵，但应了那句话，贵的东西，除了贵，没有其他的毛病&lt;/p&gt;
&lt;p&gt;智能开关记得留零线&lt;/p&gt;
&lt;p&gt;这里不展开讲了，太复杂了，完全可以单开一页的东西，有两个容易忽略的点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 墙面别开长横槽(脑补一下这确实会影响墙的稳定性)&lt;/li&gt;
&lt;li&gt;2 强弱电磁场干扰隔离（物理已经还给老师了，但是避免干扰这个要保持距离还是符合常识的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来让我们一起进入&lt;strong&gt;木瓦油&lt;/strong&gt;环节&lt;/p&gt;
&lt;h1 id=&#34;全屋吊顶-or-部分吊顶&#34;&gt;全屋吊顶 or 部分吊顶&lt;/h1&gt;
&lt;p&gt;如果考虑做无主灯，那么肯定全屋吊顶&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件架构设计原则</title>
      <link>https://duck-dd.github.io/posts/2023-04-16-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2023-04-16-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;p&gt;每次接手一些老旧系统，总是很头疼，最近想，会不会别人接手了我的系统以后也是一样的感受，想到可能有人每天都在吐槽(骂)我头皮发麻啊&amp;hellip;&lt;/p&gt;
&lt;p&gt;知易行难，其实怎么做好一个后端服务大家都是门清的，只是受限于 &lt;code&gt;排期&lt;/code&gt; &lt;code&gt;业务价值&lt;/code&gt; &lt;code&gt;协作&lt;/code&gt; 等太多因素，往往事与愿违。只能说但行好事莫问前程吧，下面再把这些原则列一下，时刻提醒自己吧；以下原则从个人角度分先后，不是说有重要性区别，而是有些原则很高频，或者很容易被忽略，需要时刻牢记。&lt;/p&gt;
&lt;h1 id=&#34;一-职责逻辑-清晰&#34;&gt;一 职责/逻辑 清晰&lt;/h1&gt;
&lt;h2 id=&#34;单一职责原则single-responsibility-principle-srp&#34;&gt;单一职责原则（Single Responsibility Principle, SRP）&lt;/h2&gt;
&lt;p&gt;每个&lt;code&gt;单元&lt;/code&gt;只负责&lt;em&gt;一件事&lt;/em&gt;。
从总体架构上讲，这个单元是一个子系统，例如订单系统，日志系统；从系统架构上讲，这个单元是一个模块，例如文章管理模块，评论管理模块等；从代码模块内部讲，这个单元是一个组件，一个类，一个struct等。再往下看，一个类还有N多个方法&amp;hellip;
就像分子，原子，质子/电子，夸克&amp;hellip;从宏观到微观的过程，就是我们把一套复杂的系统一点一点拆解开的过程，而每次向下拆解一层的时候，这一层的个体，尽量做到每个都负责一件事&lt;/p&gt;
&lt;h2 id=&#34;迪米特法则law-of-demeter-lod&#34;&gt;迪米特法则（Law of Demeter, LoD）&lt;/h2&gt;
&lt;p&gt;一个模块应尽可能少地了解其他模块的内部细节。
反过来看，一个模块向外不暴露细节，别人就没法了解细节了；所以还是在讲控制耦合。&lt;/p&gt;
&lt;h2 id=&#34;高内聚低耦合high-cohesion-low-coupling&#34;&gt;高内聚，低耦合（High Cohesion, Low Coupling）&lt;/h2&gt;
&lt;p&gt;模块内部的功能紧密相关(高内聚)，模块间通过明确接口交互，依赖关系简单(低耦合)。
明牌了，直接再提醒你一下，控制耦合控制耦合控制耦合&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;接口隔离原则interface-segregation-principle-isp&#34;&gt;接口隔离原则（Interface Segregation Principle, ISP）&lt;/h2&gt;
&lt;p&gt;客户端不应被迫依赖它不需要的接口，应将大接口拆分为多个专用小接口。
这里不是对使用者的要求，而是对接口提供(设计)者提出要求，在设计对外暴露接口时，要尽可能小，单一，独立，这样使用起来更灵活。
对外是这样的，但是内部接口，说实话我做不到尽可能小。&lt;/p&gt;
&lt;h1 id=&#34;二-破坏性侵入性控制&#34;&gt;二 破坏性(侵入性)控制&lt;/h1&gt;
&lt;h2 id=&#34;开闭原则open-closed-principle-ocp&#34;&gt;开闭原则（Open-Closed Principle, OCP）&lt;/h2&gt;
&lt;p&gt;对扩展开放，对修改关闭。
从我的理解，这条原则更多还是在指导代码层面的设计；世界是动态发展的，没有一成不变的东西，那么对于代码，可扩展是必然的需求，那为什么对修改关闭呢？可能更多还是对原系统的侵入吧，你不知道你的使用方对你做出了怎么样的假设，总之目前为止世界和平，但当你修改了你的行为，假设被打破，世界就崩塌了&lt;/p&gt;
&lt;h2 id=&#34;里氏替换原则liskov-substitution-principle-lsp&#34;&gt;里氏替换原则（Liskov Substitution Principle, LSP）&lt;/h2&gt;
&lt;p&gt;子类必须能无缝替换父类，且不破坏原有系统的正确性。即父类出现的地方，子类可替代，且行为一致。&lt;/p&gt;
&lt;h1 id=&#34;三-依赖管理&#34;&gt;三 依赖管理&lt;/h1&gt;
&lt;h2 id=&#34;分层架构原则layered-architecture-principle&#34;&gt;分层架构原则（Layered Architecture Principle）&lt;/h2&gt;
&lt;p&gt;将系统按职责划分为清晰的层次，层间单向依赖，禁止跨层调用。&lt;/p&gt;
&lt;h2 id=&#34;依赖倒置原则dependency-inversion-principle-dip&#34;&gt;依赖倒置原则（Dependency Inversion Principle, DIP）&lt;/h2&gt;
&lt;p&gt;高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。&lt;/p&gt;
&lt;h1 id=&#34;四-可扩展性&#34;&gt;四 可扩展性&lt;/h1&gt;
&lt;h2 id=&#34;演进式架构原则evolutionary-architecture&#34;&gt;演进式架构原则（Evolutionary Architecture）&lt;/h2&gt;
&lt;p&gt;架构设计应预留扩展空间，支持系统随业务需求逐步演进，而非追求 “一步到位” 的完美设计。&lt;/p&gt;
&lt;h1 id=&#34;五-安全代码安全服务安全业务安全等&#34;&gt;五 安全(代码安全，服务安全，业务安全等)&lt;/h1&gt;
&lt;h2 id=&#34;安全性原则security-by-design&#34;&gt;安全性原则（Security by Design）&lt;/h2&gt;
&lt;p&gt;将安全性嵌入架构设计的每个环节，而非事后补丁。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang select case机会均等</title>
      <link>https://duck-dd.github.io/posts/2022-04-13-golang-select-case%E6%9C%BA%E4%BC%9A%E5%9D%87%E7%AD%89/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2022-04-13-golang-select-case%E6%9C%BA%E4%BC%9A%E5%9D%87%E7%AD%89/</guid>
      <description>&lt;h1 id=&#34;验证&#34;&gt;验证&lt;/h1&gt;
&lt;p&gt;我们每天都在使用下面这样的用法，对于这种多条件分支判定，我们从来不会指定权重，按固有思维，多条件间应该是机会均等的，那么golang如何做的呢？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select {
case &amp;lt;-ch1:
    do sth
case &amp;lt;-ch2:
    do sth
case &amp;lt;-ch3:
    do sth
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们先来看看到底是不是机会均等的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import(&amp;#34;fmt&amp;#34;)

func main() {
	sum1, sum2, sum3 := 0, 0, 0
	for loop:=0; loop&amp;lt;8 ; loop++ {
		count1, count2, count3 := 0, 0, 0
		ch1, ch2, ch3 := make(chan int), make(chan int), make(chan int)
		go func(){for { ch1&amp;lt;-1 }}()
		go func(){for { ch2&amp;lt;-1 }}()
		go func(){for { ch3&amp;lt;-1 }}()
		for i := 0; i &amp;lt; 10000; i++ {
			select {
			case &amp;lt;-ch1:
				count1++
				sum1++
			case &amp;lt;-ch2:
				count2++
				sum2++
			case &amp;lt;-ch3:
				count3++
				sum3++
			}
		}
		fmt.Println(&amp;#34;loop &amp;#34;, loop+1, &amp;#34;: &amp;#34;, count1, count2, count3)
	}
	fmt.Println(&amp;#34;sum: &amp;#34;, sum1, sum2, sum3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;结果:

loop  1 :  1535 5446 3019
loop  2 :  1607 5004 3389
loop  3 :  1146 3549 5305
loop  4 :  4100 2601 3299
loop  5 :  5938 2260 1802
loop  6 :  923 1268 7809
loop  7 :  4958 2273 2769
loop  8 :  3162 3432 3406
sum:  23369 25833 30798
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;诶，好像不太对啊，尤其&lt;code&gt;loop 7&lt;/code&gt;，偏差到飞起了啊&amp;hellip;总量的偏差也大的离谱&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang schedule</title>
      <link>https://duck-dd.github.io/posts/2021-08-21-go-schedule/</link>
      <pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2021-08-21-go-schedule/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;runtime包实现了所有&lt;code&gt;goroutine scheduler&lt;/code&gt;、&lt;code&gt;memory allocator&lt;/code&gt;、&lt;code&gt;garbage collector&lt;/code&gt;细节，理论上可以从runtime包获取一切信息，没有直接怼源码，而是站在巨人的肩膀上（直接吃大佬们吃剩下的）。&lt;/p&gt;
&lt;p&gt;搜集到的材料，大家都是基于不同的go版本做的分析，而go版本迭代调度算法也在持续更新，所以整理的可能有些乱。但是可以保证的是，所有材料都是GM-&amp;gt;GMP演化后的材料。&lt;/p&gt;
&lt;h2 id=&#34;gm&#34;&gt;GM&lt;/h2&gt;
&lt;p&gt;go1.1版本以前，调度使用GM模型，如下图所示。简单的理解GM模型，就是有一个始终执行的调度函数schedule不停的执行调度计算，当某个M的G执行完成了，调度器就把这个M放回M队列，可绑定执行其他G（如果某个M+G发生了syscall，那么本来并发度是通过M数量控制的，此时并发度就降低了？）；如果G执行过程中创建新的G，会将新的G放入到G全局可执行队列中。G全局可执行队列的操作有一把全局锁，这导致了各个M对G全局队列的操作存在严重的竞争。&lt;/p&gt;
&lt;p&gt;下面这段完全是我的臆测，请别太相信：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;简单概括呢，所以可以认为有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G全局可执行队列(以下也可能简称G可执行队列)&lt;/li&gt;
&lt;li&gt;M可用队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调度器要做的事就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从G的可执行队列取G并从M的可用队列取M，将二者绑定开始执行G&lt;/li&gt;
&lt;li&gt;对于已经执行完的G，销毁G并立即将M释放回M可用队列供后续使用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt=&#34;GM-model&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/go-schedule/gm.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么GM模型有哪些问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(&lt;strong&gt;重点问题&lt;/strong&gt;)单一的全局mutex(sched.lock)和集中状态管理
&lt;ul&gt;
&lt;li&gt;mutex需要保护所有与全局goroutine队列相关操作(创建、完成、重排等等)，竞争严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(&lt;strong&gt;重点问题&lt;/strong&gt;)per-M内存(M.mcache)问题
&lt;ul&gt;
&lt;li&gt;每个M都需要一个mcache，会导致资源消耗过大(每个mcache可以吸纳到2MB的内存缓存和其他缓存)
&lt;ul&gt;
&lt;li&gt;举个栗子，一个陷入syscall的M并不需要使用cache，但是在全部的M中，陷入系统调用的M与执行goroutine的M的比例可能是&lt;code&gt;N:1(N&amp;gt;&amp;gt;1)&lt;/code&gt;，这就导致了&lt;code&gt;N/(N+1)&lt;/code&gt;比例的mcache在闲置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据局部性差&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;举个栗子，M1执行G1，此时创建了G2，G2通常是立刻进入了G全局可执行队列，而此时M1还在执行G1，所以G2通常被其他M执行，但是G1和G2通常强相关，所以G2最好也在M1上执行，因为G2对M1的缓存命中率更高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;goroutine传递问题
&lt;ul&gt;
&lt;li&gt;goroutine(G)交接(G.nextg)，M之间会经常交接可运行的G&lt;/li&gt;
&lt;li&gt;再通俗点说，就是G空转，本来能够好好在一个M上执行完，但是由于全局队列的存在，G一旦回全局队列了，下次就不知道被哪个M取走了，所以叫“空转”；M加载G的上下文是有开销的，所以空转会导致性能下降&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;频繁的线程阻塞/解阻塞
&lt;ul&gt;
&lt;li&gt;syscalls情况下，线程经常被阻塞和解阻塞，增加了很多额外开销&lt;/li&gt;
&lt;li&gt;通俗点说，M+G syscall，M阻塞，syscall完成后，M解阻塞继续执行G（如果是通过M数量控制并发度，这是不是就导致了并发度降低？）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gmp&#34;&gt;GMP&lt;/h2&gt;
&lt;p&gt;基于以上说的GM的问题，go1.1以后开始使用GMP调度模型。
G、M、P的定义如下(***/src/runtime/runtime2.go)。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the C stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic       *_panic // innermost panic - offset known to liblink
	_defer       *_defer // innermost defer
	m            *m      // current m; offset known to arm liblink
	sched        gobuf
	syscallsp    uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc
	syscallpc    uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc
	stktopsp     uintptr        // expected sp at top of stack, to check in traceback
	param        unsafe.Pointer // passed parameter on wakeup
	atomicstatus uint32
	stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid         int64
	schedlink    guintptr
	waitsince    int64      // approx time when the g become blocked
	waitreason   waitReason // if status==Gwaiting

	preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt
	preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule
	preemptShrink bool // shrink stack at synchronous safe point

	// asyncSafePoint is set if g is stopped at an asynchronous
	// safe point. This means there are frames on the stack
	// without precise pointer information.
	asyncSafePoint bool

	paniconfault bool // panic (instead of crash) on unexpected fault address
	gcscandone   bool // g has scanned stack; protected by _Gscan bit in status
	throwsplit   bool // must not split stack
	// activeStackChans indicates that there are unlocked channels
	// pointing into this goroutine&amp;#39;s stack. If true, stack
	// copying needs to acquire channel locks to protect these
	// areas of the stack.
	activeStackChans bool
	// parkingOnChan indicates that the goroutine is about to
	// park on a chansend or chanrecv. Used to signal an unsafe point
	// for stack shrinking. It&amp;#39;s a boolean value, but is updated atomically.
	parkingOnChan uint8

	raceignore     int8     // ignore race detection events
	sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine
	sysexitticks   int64    // cputicks when syscall has returned (for tracing)
	traceseq       uint64   // trace event sequencer
	tracelastp     puintptr // last P emitted an event for this goroutine
	lockedm        muintptr
	sig            uint32
	writebuf       []byte
	sigcode0       uintptr
	sigcode1       uintptr
	sigpc          uintptr
	gopc           uintptr         // pc of go statement that created this goroutine
	ancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
	startpc        uintptr         // pc of goroutine function
	racectx        uintptr
	waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
	cgoCtxt        []uintptr      // cgo traceback context
	labels         unsafe.Pointer // profiler labels
	timer          *timer         // cached timer for time.Sleep
	selectDone     uint32         // are we participating in a select and did someone win the race?

	// Per-G GC state

	// gcAssistBytes is this G&amp;#39;s GC assist credit in terms of
	// bytes allocated. If this is positive, then the G has credit
	// to allocate gcAssistBytes bytes without assisting. If this
	// is negative, then the G must correct this by performing
	// scan work. We track this in bytes to make it fast to update
	// and check for debt in the malloc hot path. The assist ratio
	// determines how this corresponds to scan work debt.
	gcAssistBytes int64
}

type m struct {
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack
	divmod  uint32 // div/mod denominator for arm - known to liblink

	// Fields not known to debuggers.
	procid        uint64       // for debuggers, but offset not hard-coded
	gsignal       *g           // signal-handling g
	goSigStack    gsignalStack // Go-allocated signal handling stack
	sigmask       sigset       // storage for saved signal mask
	tls           [6]uintptr   // thread-local storage (for x86 extern register)
	mstartfn      func()
	curg          *g       // current running goroutine
	caughtsig     guintptr // goroutine running during fatal signal
	p             puintptr // attached p for executing go code (nil if not executing go code)
	nextp         puintptr
	oldp          puintptr // the p that was attached before executing a syscall
	id            int64
	mallocing     int32
	throwing      int32
	preemptoff    string // if != &amp;#34;&amp;#34;, keep curg running on this m
	locks         int32
	dying         int32
	profilehz     int32
	spinning      bool // m is out of work and is actively looking for work
	blocked       bool // m is blocked on a note
	newSigstack   bool // minit on C thread called sigaltstack
	printlock     int8
	incgo         bool   // m is executing a cgo call
	freeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)
	fastrand      [2]uint32
	needextram    bool
	traceback     uint8
	ncgocall      uint64      // number of cgo calls in total
	ncgo          int32       // number of cgo calls currently in progress
	cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily
	cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call
	park          note
	alllink       *m // on allm
	schedlink     muintptr
	lockedg       guintptr
	createstack   [32]uintptr // stack that created this thread.
	lockedExt     uint32      // tracking for external LockOSThread
	lockedInt     uint32      // tracking for internal lockOSThread
	nextwaitm     muintptr    // next m waiting for lock
	waitunlockf   func(*g, unsafe.Pointer) bool
	waitlock      unsafe.Pointer
	waittraceev   byte
	waittraceskip int
	startingtrace bool
	syscalltick   uint32
	freelink      *m // on sched.freem

	// these are here because they are too large to be on the stack
	// of low-level NOSPLIT functions.
	libcall   libcall
	libcallpc uintptr // for cpu profiler
	libcallsp uintptr
	libcallg  guintptr
	syscall   libcall // stores syscall parameters on windows

	vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)
	vdsoPC uintptr // PC for traceback while in VDSO call

	// preemptGen counts the number of completed preemption
	// signals. This is used to detect when a preemption is
	// requested, but fails. Accessed atomically.
	preemptGen uint32

	// Whether this is a pending preemption signal on this M.
	// Accessed atomically.
	signalPending uint32

	dlogPerM

	mOS

	// Up to 10 locks held by this m, maintained by the lock ranking code.
	locksHeldLen int
	locksHeld    [10]heldLockInfo
}

type p struct {
	id          int32
	status      uint32 // one of pidle/prunning/...
	link        puintptr
	schedtick   uint32     // incremented on every scheduler call
	syscalltick uint32     // incremented on every system call
	sysmontick  sysmontick // last tick observed by sysmon
	m           muintptr   // back-link to associated m (nil if idle)
	mcache      *mcache
	pcache      pageCache
	raceprocctx uintptr

	deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)
	deferpoolbuf [5][32]*_defer

	// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
	goidcache    uint64
	goidcacheend uint64

	// Queue of runnable goroutines. Accessed without lock.
	runqhead uint32
	runqtail uint32
	runq     [256]guintptr
	// runnext, if non-nil, is a runnable G that was ready&amp;#39;d by
	// the current G and should be run next instead of what&amp;#39;s in
	// runq if there&amp;#39;s time remaining in the running G&amp;#39;s time
	// slice. It will inherit the time left in the current time
	// slice. If a set of goroutines is locked in a
	// communicate-and-wait pattern, this schedules that set as a
	// unit and eliminates the (potentially large) scheduling
	// latency that otherwise arises from adding the ready&amp;#39;d
	// goroutines to the end of the run queue.
	runnext guintptr

	// Available G&amp;#39;s (status == Gdead)
	gFree struct {
		gList
		n int32
	}

	sudogcache []*sudog
	sudogbuf   [128]*sudog

	// Cache of mspan objects from the heap.
	mspancache struct {
		// We need an explicit length here because this field is used
		// in allocation codepaths where write barriers are not allowed,
		// and eliminating the write barrier/keeping it eliminated from
		// slice updates is tricky, moreso than just managing the length
		// ourselves.
		len int
		buf [128]*mspan
	}

	tracebuf traceBufPtr

	// traceSweep indicates the sweep events should be traced.
	// This is used to defer the sweep start event until a span
	// has actually been swept.
	traceSweep bool
	// traceSwept and traceReclaimed track the number of bytes
	// swept and reclaimed by sweeping in the current sweep loop.
	traceSwept, traceReclaimed uintptr

	palloc persistentAlloc // per-P to avoid mutex

	_ uint32 // Alignment for atomic fields below

	// The when field of the first entry on the timer heap.
	// This is updated using atomic functions.
	// This is 0 if the timer heap is empty.
	timer0When uint64

	// Per-P GC state
	gcAssistTime         int64    // Nanoseconds in assistAlloc
	gcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)
	gcBgMarkWorker       guintptr // (atomic)
	gcMarkWorkerMode     gcMarkWorkerMode

	// gcMarkWorkerStartTime is the nanotime() at which this mark
	// worker started.
	gcMarkWorkerStartTime int64

	// gcw is this P&amp;#39;s GC work buffer cache. The work buffer is
	// filled by write barriers, drained by mutator assists, and
	// disposed on certain GC state transitions.
	gcw gcWork

	// wbBuf is this P&amp;#39;s GC write barrier buffer.
	//
	// TODO: Consider caching this in the running G.
	wbBuf wbBuf

	runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point

	// Lock for timers. We normally access the timers while running
	// on this P, but the scheduler can also do it from a different P.
	timersLock mutex

	// Actions to take at some time. This is used to implement the
	// standard library&amp;#39;s time package.
	// Must hold timersLock to access.
	timers []*timer

	// Number of timers in P&amp;#39;s heap.
	// Modified using atomic instructions.
	numTimers uint32

	// Number of timerModifiedEarlier timers on P&amp;#39;s heap.
	// This should only be modified while holding timersLock,
	// or while the timer status is in a transient state
	// such as timerModifying.
	adjustTimers uint32

	// Number of timerDeleted timers in P&amp;#39;s heap.
	// Modified using atomic instructions.
	deletedTimers uint32

	// Race context used while executing timer functions.
	timerRaceCtx uintptr

	// preempt is set to indicate that this P should be enter the
	// scheduler ASAP (regardless of what G is running on it).
	preempt bool

	pad cpu.CacheLinePad
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;gmp模型的一些概念&#34;&gt;GMP模型的一些概念&lt;/h3&gt;
&lt;p&gt;上面M中有两个g需要关注下，curg和g0。
curg就是M当前绑定的G。
g0是带有调度栈的goroutine，普通的G的栈是分配在堆上的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中执行。即，线程的栈也是用的g实现，而不是使用的OS。&lt;/p&gt;</description>
    </item>
    <item>
      <title>happens-before</title>
      <link>https://duck-dd.github.io/posts/2021-08-19-happens-before/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2021-08-19-happens-before/</guid>
      <description>&lt;p&gt;在并发系统中，用于描述事件执行顺序关系；若事件A &amp;ldquo;happens-before&amp;rdquo; 事件B，则A的执行结果对B可见，且A在逻辑上先于B执行(并不要求在物理时间上A必须先于B执行)。&lt;/p&gt;
&lt;p&gt;所以这其实是一种逻辑关系，在并发系统中，P1 P2 两个过程在逻辑上&amp;quot;同时&amp;quot;在执行，P2过程中的事件B依赖P1过程中的事件A的结果，那么就需要逻辑上的 &amp;ldquo;happens-before&amp;rdquo; 来确保A&amp;amp;B间的依赖关系。&lt;/p&gt;
&lt;p&gt;常见的并发模型 &lt;strong&gt;共享内存&lt;/strong&gt; 和 &lt;strong&gt;消息传递&lt;/strong&gt;，都遵循 &amp;ldquo;happens-before&amp;quot;逻辑，消息传递中的happens-before好理解，消息的传入肯定是在消息的接收之前的，在共享内存模型的并发中，happens-before就是帮助我们在逻辑上自洽，理清楚不同并发单元(线程 协程 等)对某一个共享内存变量的操作顺序。&lt;/p&gt;</description>
    </item>
    <item>
      <title>离职人生体验</title>
      <link>https://duck-dd.github.io/posts/2021-07-08-%E7%A6%BB%E8%81%8C%E4%BA%BA%E7%94%9F%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2021-07-08-%E7%A6%BB%E8%81%8C%E4%BA%BA%E7%94%9F%E4%BD%93%E9%AA%8C/</guid>
      <description>&lt;p&gt;2018年7月4日，星期三，天气晴。&lt;/p&gt;
&lt;p&gt;早晨7点半，太阳已经很大，收拾好材料，出发，今天是上班的第一天，也是第一天上班。浑浑噩噩的流程，脑子里什么都没进，然后晕头转向的上了班车，从大厦到了科技园。找工位，认识同事，熟悉环境，然后第一天就心大的开始午睡，睡了2小时，爬起来，心想，坏了，睡过了，然后，发现并没有人关注我，呼～，长出一口气，心想社畜生活貌似还挺轻松。&lt;/p&gt;
&lt;p&gt;leader下午快到晚饭才开完会（以至于后面很长一段时间我觉得自己菜的评判标准就是没会开，太年轻啊），找到我，“走，一块吃个晚饭”，我怀着无比的尴尬，回，“哥，我吃完了。。。（心想完了第一天就摸鱼还被发现了）”，leader说，那走吧，随便找个空会议室聊两句。“别叫哥，我们这里都不这样叫，直接叫我名字就行”，我心想，业界都传的XX有着最好的氛围，看来是真的，跟学校没什么两样哈。leader说，“BFE听过吧”，我理直气壮的回，“没啊”  （冷场大概有两秒钟吧，这里可能原本应该有十分钟左右的技术交谈，然后大概是临时取消了吧） “我是你的导师，但是平时时间不太充裕，你有问题多问问我们组的人吧，其中还有一个是你的师兄”，“好的”。本次谈话就此结束，我开始回去看材料学习，第一天到底学会了啥，完全不记得了，可能甚至大概都没搞懂BFE全称到底是啥吧。&lt;/p&gt;
&lt;p&gt;对于这一天只记得这么多，但是三年了，能对一天记得这么多，于我也是难得。直到后来，我才知道，团队有几十人，有N多个方向，leader甚至是身边每一个同事，都是大佬。&lt;/p&gt;
&lt;p&gt;反而是接下来的三年，此时此刻回想起来，感觉只是恍惚间。唯一记得就只是18年底，接到了春晚项目，一个月没休息，回家过年下飞机的第一件事，就是开机看一眼**备战群（唉，总是这样，一有事就各种备战，搞得人很紧张）。2018，把春晚从头看到尾，红包没抢到几块钱，但是第一次从工作中获得一点成就感。那些加过的班，熬过的夜，回头看，都不记得了。同时，不记得的，还有这三年学会的知识，真是悲哀。&lt;/p&gt;
&lt;p&gt;上百万封邮件(收)，几万行代码，几千条SQL，几百张图，几十周值班，几个case（呸，我没case @_@ 真的没一个线上有损case，难道应了老话，干的少错的少？）。&lt;/p&gt;
&lt;p&gt;没学到东西当然是玩笑话，从心底里感谢XX教给我的一身本领，不大，但是贵在积累。也希望我的工作，没有让任何人感到过失望。&lt;/p&gt;
&lt;p&gt;来公司的第一天，就看到了“离职申请”这个页面，从第一天就在好奇点开到底长什么样子，担心有log，所以没点。。。唉，其实点开了，没什么，也是一个普通的页面而已。&lt;/p&gt;
&lt;p&gt;交接过程中，每天还是会零星接到几个客官老爷，但是渐渐的，大家注意到签名了。“诶，你要走啦”。越来越多的人前来告别，大部分人，都没有见过面。告别语中，祝福偏多，偶尔也会得到几句赞许，所幸没有挨一句骂（是不是有点幸存者偏差了@-@）。就觉得，回报应该真的与付出成正比，延迟满足带来的幸福感甚至可能是指数级的。也觉得，与人为善总是好的（也可以理解为我大部分时间都很怂@_@）。&lt;/p&gt;
&lt;p&gt;最后的工作月，迟到的次数反而比平时更少了，真是怪哉。小伙伴们总是开我的玩笑，工作3年，工作经验6年。我觉得吧，夸张了，工作3年工作经验顶多4年吧，还是得算上划水时间。&lt;/p&gt;
&lt;p&gt;遗憾的是，没有打破自己的人生魔咒，“在一个地方超过三年”。&lt;/p&gt;
&lt;p&gt;感谢一起共事过的所有伙伴，你们教会我的知识和道理，我还会继续学习。&lt;/p&gt;
&lt;p&gt;如果未来还能有机会发声，会提一条建议，离职窗口的工作人员，能不能多一项培训，“减少冷漠”。要走的人，总是感性的，一个善意的微笑，可能比文化部门铺天盖地的宣传更有效果。再多一条建议，离职窗口旁边收集下即将离开的伙伴的建议和意见，或者就随便写几句，这里可能才是最真实的声音。感谢，感恩，祝福XX越来越好。&lt;/p&gt;
&lt;p&gt;再多的感触，就留在心里了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;爱过&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DNS</title>
      <link>https://duck-dd.github.io/posts/2021-05-13-dns/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/2021-05-13-dns/</guid>
      <description>&lt;h1 id=&#34;dns&#34;&gt;DNS？&lt;/h1&gt;
&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。&lt;/li&gt;
&lt;li&gt;cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源&lt;/li&gt;
&lt;li&gt;forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。&lt;/li&gt;
&lt;li&gt;CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15
&lt;ul&gt;
&lt;li&gt;A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns做什么&#34;&gt;DNS做什么&lt;/h2&gt;
&lt;p&gt;ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。&lt;/p&gt;
&lt;p&gt;主机名的解析有一个发展的过程。&lt;/p&gt;
&lt;p&gt;最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。&lt;/p&gt;
&lt;p&gt;这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。&lt;/p&gt;
&lt;p&gt;这种方式问题很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）&lt;/li&gt;
&lt;li&gt;例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。&lt;/p&gt;
&lt;h2 id=&#34;bindberkeley-internet-name-domain&#34;&gt;BIND，Berkeley Internet Name Domain&lt;/h2&gt;
&lt;h3 id=&#34;bind管理方式&#34;&gt;BIND管理方式&lt;/h3&gt;
&lt;p&gt;BIND是一套阶层式的管理主机名与IP对应关系的系统。&lt;/p&gt;
&lt;p&gt;阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/dns/1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;以www.baidu.com为例，最上层根服务器，domain name是&amp;quot;.&amp;quot;，然后有三个hostname &amp;ldquo;net com cn&amp;rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个&amp;quot;.&amp;ldquo;都拆分domain name&amp;amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。&lt;/p&gt;
&lt;p&gt;DNS阶层系统的最上方是一个&amp;rdquo;.&amp;quot;，root，是根服务器，本质上讲，这里的&amp;quot;.&amp;ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。&lt;/p&gt;
&lt;p&gt;每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&amp;rdquo;.&amp;quot;)；同一层内不允许同名，确保唯一性。&lt;/p&gt;
&lt;h3 id=&#34;bind查询流程&#34;&gt;BIND查询流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当浏览器输入 &lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt; ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录&lt;/li&gt;
&lt;li&gt;client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？
&lt;ul&gt;
&lt;li&gt;其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧&lt;/li&gt;
&lt;li&gt;然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果&lt;/li&gt;
&lt;li&gt;.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧
&lt;ul&gt;
&lt;li&gt;.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/dns/2.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
